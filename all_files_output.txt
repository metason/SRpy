Generating documentation of all files in 'include' and 'src' directories...
==============================================================
Generated on: Mon Feb  3 15:20:15 CET 2025
==============================================================

Warning: Directory 'include' does not exist. Skipping.
==> src/BBoxSector.py <==
# src/BBoxSector.py

from enum import IntFlag
from typing import Any
from src.SpatialPredicate import SpatialPredicate


class BBoxSectorFlags(IntFlag):
    none = 0  # no sector specified
    i = 1 << 0  # i : inside, inner
    a = 1 << 1  # a : ahead
    b = 1 << 2  # b : behind
    l = 1 << 3  # l : left
    r = 1 << 4  # r : right
    o = 1 << 5  # o : over
    u = 1 << 6  # u : under

    # Composite sectors
    al = a | l
    ar = a | r
    bl = b | l
    br = b | r
    ao = a | o
    au = a | u
    bo = b | o
    bu = b | u
    lo = l | o
    lu = l | u
    ro = r | o
    ru = r | u
    alo = a | l | o
    aro = a | r | o
    blo = b | l | o
    bro = b | r | o
    alu = a | l | u
    aru = a | r | u
    blu = b | l | u
    bru = b | r | u


class BBoxSector:
    """
    A mutable class that represents spatial sectors using bitmask flags.
    Mimics Swift's OptionSet behavior.
    """

    # Predefined descriptions for composite and individual sectors
    debug_descriptions = {
        BBoxSectorFlags.i: "i",
        BBoxSectorFlags.a: "a",
        BBoxSectorFlags.b: "b",
        BBoxSectorFlags.l: "l",
        BBoxSectorFlags.r: "r",
        BBoxSectorFlags.o: "o",
        BBoxSectorFlags.u: "u",
        BBoxSectorFlags.al: "al",
        BBoxSectorFlags.ar: "ar",
        BBoxSectorFlags.bl: "bl",
        BBoxSectorFlags.br: "br",
        BBoxSectorFlags.ao: "ao",
        BBoxSectorFlags.au: "au",
        BBoxSectorFlags.bo: "bo",
        BBoxSectorFlags.bu: "bu",
        BBoxSectorFlags.lo: "lo",
        BBoxSectorFlags.lu: "lu",
        BBoxSectorFlags.ro: "ro",
        BBoxSectorFlags.ru: "ru",
        BBoxSectorFlags.alo: "alo",
        BBoxSectorFlags.aro: "aro",
        BBoxSectorFlags.blo: "blo",
        BBoxSectorFlags.bro: "bro",
        BBoxSectorFlags.alu: "alu",
        BBoxSectorFlags.aru: "aru",
        BBoxSectorFlags.blu: "blu",
        BBoxSectorFlags.bru: "bru",
    }

    # Define base flags (individual flags only)
    base_flags = {
        BBoxSectorFlags.i,
        BBoxSectorFlags.a,
        BBoxSectorFlags.b,
        BBoxSectorFlags.l,
        BBoxSectorFlags.r,
        BBoxSectorFlags.o,
        BBoxSectorFlags.u
    }

    def __init__(self, flags=BBoxSectorFlags.none):
        """
        Initialize a BBoxSector instance.

        Args:
            flags (BBoxSectorFlags, optional): Initial sector flags. Defaults to BBoxSectorFlags.none.
        """
        self.flags = flags

    def insert(self, flag: BBoxSectorFlags):
        """
        Insert a sector flag.

        Args:
            flag (BBoxSectorFlags): The flag to insert.
        """
        self.flags |= flag

    def remove(self, flag: BBoxSectorFlags):
        """
        Remove a sector flag.

        Args:
            flag (BBoxSectorFlags): The flag to remove.
        """
        self.flags &= ~flag

    def contains_flag(self, flag: BBoxSectorFlags) -> bool:
        """
        Check if a sector flag is present.

        Args:
            flag (BBoxSectorFlags): The flag to check.

        Returns:
            bool: True if the flag is present, False otherwise.
        """
        return (self.flags & flag) == flag

    def contains(self, flag: BBoxSectorFlags) -> bool:
        """
        Alias for contains_flag to maintain backward compatibility.

        Args:
            flag (BBoxSectorFlags): The flag to check.

        Returns:
            bool: True if the flag is present, False otherwise.
        """
        return self.contains_flag(flag)

    def divergencies(self) -> int:
        """
        Calculate the amount of divergency from the inner zone in all 3 directions.

        Returns:
            int: 0 if the sector includes 'i' (inside), otherwise the number of set bits.
        """
        if self.contains_flag(BBoxSectorFlags.i):
            return 0
        return bin(self.flags.value).count('1')

    def list_base_flags(self):
        """
        List only the base flags present in the sector.
        """
        return [name for name, member in BBoxSectorFlags.__members__.items()
                if member in self.flags and name != 'none' and member in BBoxSector.base_flags]

    def __str__(self) -> str:
        """
        Provide a string representation for the sector.

        Returns:
            str: The descriptive string of the sector.
        """
        # Always list base flags to match test expectations
        flags = self.list_base_flags()
        if flags:
            return ''.join(flags)
        elif self.flags == BBoxSectorFlags.none:
            return "no sector"
        else:
            # If no base flags are set, but some composite flags are, list them
            # This can happen if only composite flags are set without their base flags
            composite_flags = [name for name, member in BBoxSectorFlags.__members__.items()
                               if member in self.flags and name != 'none' and member not in BBoxSector.base_flags]
            if composite_flags:
                return ''.join(composite_flags)
            return "no sector"

    def __eq__(self, other: Any) -> bool:
        """
        Check equality with another BBoxSector instance.

        Args:
            other (Any): The object to compare.

        Returns:
            bool: True if equal, False otherwise.
        """
        if isinstance(other, BBoxSector):
            return self.flags == other.flags
        return False

    def __repr__(self) -> str:
        """
        Return the official string representation of the sector.

        Returns:
            str: The string representation.
        """
        return f"BBoxSector(flags={self.flags})"

    def __or__(self, other: Any) -> 'BBoxSector':
        """
        Define the behavior of the | operator.

        Args:
            other (BBoxSector or BBoxSectorFlags): The other sector or flag to combine.

        Returns:
            BBoxSector: A new BBoxSector instance with combined flags.
        """
        if isinstance(other, BBoxSector):
            return BBoxSector(self.flags | other.flags)
        elif isinstance(other, BBoxSectorFlags):
            return BBoxSector(self.flags | other)
        else:
            return NotImplemented

    def __ior__(self, other: Any) -> 'BBoxSector':
        """
        Define the behavior of the |= operator.

        Args:
            other (BBoxSector or BBoxSectorFlags): The other sector or flag to combine.

        Returns:
            BBoxSector: The updated BBoxSector instance.
        """
        if isinstance(other, BBoxSector):
            self.flags |= other.flags
            return self
        elif isinstance(other, BBoxSectorFlags):
            self.flags |= other
            return self
        else:
            return NotImplemented

    def __contains__(self, item: Any) -> bool:
        """
        Enable the 'in' operator to check for SpatialPredicate or BBoxSectorFlags.

        Args:
            item (Any): SpatialPredicate or BBoxSectorFlags to check.

        Returns:
            bool: True if the item is present, False otherwise.
        """
        if isinstance(item, SpatialPredicate):
            # Map SpatialPredicate to BBoxSectorFlags
            flag_map = {
                SpatialPredicate.l: BBoxSectorFlags.l,
                SpatialPredicate.r: BBoxSectorFlags.r,
                SpatialPredicate.a: BBoxSectorFlags.a,
                SpatialPredicate.b: BBoxSectorFlags.b,
                SpatialPredicate.o: BBoxSectorFlags.o,
                SpatialPredicate.u: BBoxSectorFlags.u,
                SpatialPredicate.i: BBoxSectorFlags.i,
                SpatialPredicate.al: BBoxSectorFlags.al,
                SpatialPredicate.ar: BBoxSectorFlags.ar,
                SpatialPredicate.bl: BBoxSectorFlags.bl,
                SpatialPredicate.br: BBoxSectorFlags.br,
                SpatialPredicate.ao: BBoxSectorFlags.ao,
                SpatialPredicate.au: BBoxSectorFlags.au,
                SpatialPredicate.bo: BBoxSectorFlags.bo,
                SpatialPredicate.bu: BBoxSectorFlags.bu,
                SpatialPredicate.lo: BBoxSectorFlags.lo,
                SpatialPredicate.lu: BBoxSectorFlags.lu,
                SpatialPredicate.ro: BBoxSectorFlags.ro,
                SpatialPredicate.ru: BBoxSectorFlags.ru,
                SpatialPredicate.alo: BBoxSectorFlags.alo,
                SpatialPredicate.aro: BBoxSectorFlags.aro,
                SpatialPredicate.blo: BBoxSectorFlags.blo,
                SpatialPredicate.bro: BBoxSectorFlags.bro,
                SpatialPredicate.alu: BBoxSectorFlags.alu,
                SpatialPredicate.aru: BBoxSectorFlags.aru,
                SpatialPredicate.blu: BBoxSectorFlags.blu,
                SpatialPredicate.bru: BBoxSectorFlags.bru,
                # Add more mappings as needed
            }
            flag = flag_map.get(item, None)
            if flag is not None:
                return self.contains_flag(flag)
        elif isinstance(item, BBoxSectorFlags):
            return self.contains_flag(item)
        return False


# Example Usage

if __name__ == "__main__":
    # Initialize with a predefined composite sector
    sector = BBoxSector(BBoxSectorFlags.alo)
    print(f"Sector: {sector}")  # Output: Sector: a+l+o
    print(f"Divergencies: {sector.divergencies()}")  # Output: Divergencies: 3

    # Create an empty sector and insert flags
    combined_sector = BBoxSector()
    combined_sector.insert(BBoxSectorFlags.a)
    combined_sector.insert(BBoxSectorFlags.l)
    combined_sector.insert(BBoxSectorFlags.o)
    print(f"Combined Sector: {combined_sector}")  # Output: Combined Sector: a+l+o
    print(f"Divergencies: {combined_sector.divergencies()}")  # Output: Divergencies: 3

    # Initialize with the 'inside' sector
    inner_sector = BBoxSector(BBoxSectorFlags.i)
    print(f"Inner Sector: {inner_sector}")  # Output: Inner Sector: i
    print(f"Divergencies: {inner_sector.divergencies()}")  # Output: Divergencies: 0

    # Initialize with no sector
    no_sector = BBoxSector()
    print(f"No Sector: {no_sector}")  # Output: No Sector: no sector
    print(f"Divergencies: {no_sector.divergencies()}")  # Output: Divergencies: 0

    # Undefined composite sector example
    undefined_sector = BBoxSector()
    undefined_sector.insert(BBoxSectorFlags.a)
    undefined_sector.insert(BBoxSectorFlags.b)
    undefined_sector.insert(BBoxSectorFlags.l)
    undefined_sector.insert(BBoxSectorFlags.r)
    print(f"Undefined Combined Sector: {undefined_sector}")  # Output: Undefined Combined Sector: a+b+l+r
    print(f"Divergencies: {undefined_sector.divergencies()}")  # Output: Divergencies: 4

--------------------------------------------------------------

==> src/SpatialBasics.py <==
from enum import Enum
import math
from typing import Dict


# Calculation schema to determine nearby radius
class NearbySchema(Enum):
    fixed = "fixed"      # use nearbyFactor as fix nearby radius
    circle = "circle"    # use base circle radius of bbox multiplied with nearbyFactor
    sphere = "sphere"    # use sphere radius of bbox multiplied with nearbyFactor
    perimeter = "perimeter"  # use base perimeter multiplied with nearbyFactor
    area = "area"        # use area multiplied with nearbyFactor

    @staticmethod
    def named(name: str):
        return NearbySchema(name) if name in NearbySchema.__members__ else None


# Calculation schema to determine sector size for extruding bbox area
class SectorSchema(Enum):
    fixed = "fixed"      # use sectorFactor as fix sector length for extruding area
    dimension = "dimension"  # use same dimension as object bbox multiplied with sectorFactor
    perimeter = "perimeter"  # use base perimeter multiplied with sectorFactor
    area = "area"        # use area multiplied with sectorFactor
    nearby = "nearby"    # use nearby settings of spatial adjustment for extruding

    @staticmethod
    def named(name: str):
        return SectorSchema(name) if name in SectorSchema.__members__ else None


# Set adjustment parameters before executing pipeline or calling relate() method.
# SpatialReasoner has its own local adjustment that should be set upfront.
class SpatialAdjustment:
    def __init__(
        self,
        maxGap: float = 0.02,
        angle: float = 0.05 * math.pi,
        sector_schema: SectorSchema = SectorSchema.nearby,
        sector_factor: float = 1.0,
        sector_limit: float = 2.5,
        nearby_schema: NearbySchema = NearbySchema.circle,
        nearby_factor: float = 2.0,
        nearby_limit: float = 2.5
    ):
        # Max deviations
        self.maxGap: float = maxGap  # max distance of deviation in all directions in meters
        self.maxAngleDelta: float = angle  # max angle delta in both directions in radians

        # Sector size
        self.sectorSchema: SectorSchema = sector_schema
        self.sectorFactor: float = sector_factor  # multiplying result of calculation schema
        self.sectorLimit: float = sector_limit  # maximal length

        # Vicinity
        self.nearbySchema: NearbySchema = nearby_schema
        self.nearbyFactor: float = nearby_factor  # multiplying radius sum of object and subject (relative to size) as max distance
        self.nearbyLimit: float = nearby_limit  # maximal absolute distance

        # Proportions
        self.longRatio: float = 4.0  # one dimension is factor larger than both others
        self.thinRatio: float = 10.0  # one dimension is 1/factor smaller than both others

    @property
    def yaw(self) -> float:
        """Get max delta of orientation in degrees."""
        return self.maxAngleDelta * 180.0 / math.pi

    def setYaw(self, degrees: float):
        """Set max delta of orientation in degrees."""
        self.maxAngleDelta = degrees * math.pi / 180.0


# Default adjustment only used when no SpatialReasoner builds context
defaultAdjustment = SpatialAdjustment()
tightAdjustment = SpatialAdjustment(maxGap=0.002, angle=0.01 * math.pi, sector_factor=0.5)


class SpatialPredicateCategories:
    def __init__(self):
        self.topology: bool = True
        self.connectivity: bool = True
        self.comparability: bool = False
        self.similarity: bool = False
        self.sectoriality: bool = False
        self.visibility: bool = False
        self.geography: bool = False


class ObjectConfidence:
    """Plausibility values between 0.0 and 1.0"""

    def __init__(self):
        self.pose: float = 0.0  # plausibility of position and orientation of (partially) detected part
        self.dimension: float = 0.0  # plausibility of size of spatial object
        self.label: float = 0.0  # plausibility of classification: label, type, supertype
        self.look: float = 0.0  # plausibility of look and shape

    @property
    def value(self) -> float:
        return (self.pose + self.dimension + self.label) / 3.0

    def setValue(self, value: float):
        self.pose = value
        self.dimension = value
        self.label = value

    @property
    def spatial(self) -> float:
        return (self.pose + self.dimension) / 2.0

    def setSpatial(self, value: float):
        self.pose = value
        self.dimension = value

    def asDict(self) -> Dict[str, float]:
        return {
            "pose": self.pose,
            "dimension": self.dimension,
            "label": self.label,
            "look": self.look
        }


# Searchable, metric, spatio-temporal attributes
class SpatialAtribute(Enum):
    none = "none"
    width = "width"
    height = "height"
    depth = "depth"
    length = "length"
    angle = "angle"
    yaw = "yaw"
    azimuth = "azimuth"  # deviation from north direction
    footprint = "footprint"  # base surface
    frontface = "frontface"  # front surface
    sideface = "sideface"  # side surface
    surface = "surface"  # total bbox surface
    volume = "volume"
    perimeter = "perimeter"
    baseradius = "baseradius"  # radius of 2D floorground circle
    radius = "radius"  # radius of sphere including 3D bbox around center
    speed = "speed"
    confidence = "confidence"
    lifespan = "lifespan"


class SpatialExistence(Enum):
    undefined = "undefined"
    real = "real"  # visual, detected, real object
    virtual = "virtual"  # visual, created, virtual object
    conceptual = "conceptual"  # non-visual, conceptual area, e.g., corner, zone, sensing area, region of interest, interaction field
    aggregational = "aggregational"  # non-visual part-of group, container

    @staticmethod
    def named(name: str):
        return SpatialExistence(name) if name in SpatialExistence.__members__ else SpatialExistence.undefined


class ObjectCause(Enum):
    unknown = "unknown"
    plane_detected = "plane_detected"  # on-device plane detection
    object_detected = "object_detected"  # on-device object detection
    self_tracked = "self_tracked"  # device of user registered and tracked in space
    user_captured = "user_captured"  # captured by user
    user_generated = "user_generated"  # generated by user
    rule_produced = "rule_produced"  # produced by rule or by program logic
    remote_created = "remote_created"  # created by remote service

    @staticmethod
    def named(name: str):
        return ObjectCause(name) if name in ObjectCause.__members__ else ObjectCause.unknown


class MotionState(Enum):
    unknown = "unknown"
    stationary = "stationary"  # immobile
    idle = "idle"  # idle
    moving = "moving"  # moving


class ObjectShape(Enum):
    unknown = "unknown"
    planar = "planar"  # plane, thin box
    cubical = "cubical"  # box
    spherical = "spherical"
    cylindrical = "cylindrical"  # along longest dimension when long
    conical = "conical"
    irregular = "irregular"  # complex shape
    changing = "changing"  # changing shape, e.g., of creature

    @staticmethod
    def named(name: str):
        return ObjectShape(name) if name in ObjectShape.__members__ else ObjectShape.unknown


# TODO: operable?
class ObjectHandling(Enum):
    none = "none"
    movable = "movable"
    slidable = "slidable"
    liftable = "liftable"
    portable = "portable"
    rotatable = "rotatable"
    openable = "openable"
    # tangible = "tangible"  # ?? user-dep.


# Example Usage
if __name__ == "__main__":
    # SpatialAdjustment example
    adjustment = SpatialAdjustment()
    print(f"Default Adjustment Max Gap: {adjustment.maxGap}")  # Output: 0.02
    print(f"Default Adjustment Yaw: {adjustment.yaw} degrees")  # Output: ~2.864788975654116 degrees

    adjustment.setYaw(10.0)
    print(f"Updated Adjustment Max Angle Delta: {adjustment.maxAngleDelta} radians")  # Output: ~0.17453292519943295 radians

    # ObjectConfidence example
    confidence = ObjectConfidence()
    confidence.pose = 0.8
    confidence.dimension = 0.7
    confidence.label = 0.9
    confidence.look = 0.6
    print(f"Object Confidence Value: {confidence.value}")  # Output: (0.8 + 0.7 + 0.9) / 3 = 0.8
    print(f"Object Confidence Spatial: {confidence.spatial}")  # Output: (0.8 + 0.7) / 2 = 0.75
    print(f"Object Confidence as Dictionary: {confidence.asDict()}")  # Output: {'pose': 0.8, 'dimension': 0.7, 'label': 0.9, 'look': 0.6}

    # Enum usage example
    schema = NearbySchema.circle
    print(f"Nearby Schema: {schema.value}")  # Output: "circle"

    existence = SpatialExistence.named("virtual")
    print(f"Spatial Existence: {existence.value}")  # Output: "virtual"

    cause = ObjectCause.named("user_generated")
    print(f"Object Cause: {cause.value}")  # Output: "user_generated"

    shape = ObjectShape.named("spherical")
    print(f"Object Shape: {shape.value}")  # Output: "spherical"

    handling = ObjectHandling.movable
    print(f"Object Handling: {handling.value}")  # Output: "movable"

--------------------------------------------------------------

==> src/SpatialInference.py <==
import datetime
from typing import List, Dict, Optional, Any
import re

# Placeholder imports for dependencies.
# Ensure that these classes are properly defined in your Python project.
# from spatial_adjustment import SpatialAdjustment
# from spatial_predicate_categories import SpatialPredicateCategories
# from spatial_object import SpatialObject
# from spatial_relation import SpatialRelation
# from spatial_reasoner import SpatialReasoner

class SpatialInference:
    def __init__(self, input_indices: List[int], operation: str, fact: 'SpatialReasoner'):
        self.input: List[int] = input_indices  # Indices to fact.base["objects"]
        self.output: List[int] = []            # Indices to fact.base["objects"]
        self.operation: str = operation
        self.succeeded: bool = False
        self.error: str = ""
        self.fact: 'SpatialReasoner' = fact

        # Parse and execute the operation
        try:
            if self.operation.startswith("filter(") and self.operation.endswith(")"):
                condition = self.operation[7:-1].strip()
                self.filter(condition)
            elif self.operation.startswith("pick(") and self.operation.endswith(")"):
                relations = self.operation[5:-1].strip()
                self.pick(relations)
            elif self.operation.startswith("select(") and self.operation.endswith(")"):
                terms = self.operation[7:-1].strip()
                self.select(terms)
            elif self.operation.startswith("sort(") and self.operation.endswith(")"):
                attribute = self.operation[5:-1].strip()
                self.sort(attribute)
            elif self.operation.startswith("slice(") and self.operation.endswith(")"):
                range_str = self.operation[6:-1].strip()
                self.slice(range_str)
            elif self.operation.startswith("produce(") and self.operation.endswith(")"):
                terms = self.operation[8:-1].strip()
                self.produce(terms)
            elif self.operation.startswith("calc(") and self.operation.endswith(")"):
                assignments = self.operation[5:-1].strip()
                self.calc(assignments)
            elif self.operation.startswith("map(") and self.operation.endswith(")"):
                assignments = self.operation[4:-1].strip()
                self.map(assignments)
            elif self.operation.startswith("reload(") and self.operation.endswith(")"):
                self.reload()
            else:
                self.error = f"Unknown inference operation: {self.operation}"
        except Exception as e:
            self.error = f"Exception during operation '{self.operation}': {str(e)}"

    def add(self, index: int):
        if index not in self.output:
            self.output.append(index)

    def filter(self, condition: str):
        predicate = SpatialInference.attribute_predicate(condition)
        if predicate is None:
            self.error = f"Invalid filter condition: {condition}"
            return

        base_objects = self.fact.base.get("objects", [])
        for i in self.input:
            obj = base_objects[i]
            try:
                result = predicate(obj)
                if result:
                    self.add(i)
            except Exception as e:
                self.error = f"Filter evaluation error for object {i}: {str(e)}"
                return
        self.succeeded = True

    def pick(self, relations: str):
        predicates = SpatialInference.extract_keywords(relations)
        for i in self.input:
            for j, subject in enumerate(self.fact.objects):
                if i != j:
                    cond = relations
                    for predicate in predicates:
                        if self.fact.does(subject=self.fact.objects[j], have=predicate, with_obj_idx=i):
                            cond = cond.replace(predicate, "True")
                        else:
                            cond = cond.replace(predicate, "False")
                    try:
                        result = eval(cond)
                        if result:
                            self.add(j)
                    except Exception as e:
                        self.error = f"Pick evaluation error for relation '{relations}' between {i} and {j}: {str(e)}"
                        return
        self.succeeded = bool(self.output)

    def select(self, terms: str):
        parts = [part.strip() for part in terms.split("?")]
        if len(parts) == 1:
            relations = parts[0]
            conditions = ""
        elif len(parts) == 2:
            relations, conditions = parts
        else:
            self.error = "Invalid select query format."
            return

        predicates = SpatialInference.extract_keywords(relations)
        base_objects = self.fact.base.get("objects", [])
        for i in self.input:
            for j, subject in enumerate(self.fact.objects):
                if i != j:
                    cond = relations
                    for predicate in predicates:
                        if self.fact.does(subject=self.fact.objects[j], have=predicate, with_obj_idx=i):
                            cond = cond.replace(predicate, "True")
                        else:
                            cond = cond.replace(predicate, "False")
                    try:
                        result = eval(cond)
                        if result:
                            if conditions:
                                attr_predicate = SpatialInference.attribute_predicate(conditions)
                                if attr_predicate and attr_predicate(base_objects[j]):
                                    self.add(i)
                            else:
                                self.add(i)
                    except Exception as e:
                        self.error = f"Select evaluation error for object {i}: {str(e)}"
                        return
        self.succeeded = bool(self.output)

    def map(self, assignments: str):
        self.assign(assignments, self.input)
        self.fact.load()  # Reload the fact base after mapping
        self.output = self.input.copy()
        self.succeeded = bool(self.output)

    def assign(self, assignments: str, indices: List[int]):
        assignment_list = [assignment.strip() for assignment in assignments.split(";")]
        base_objects = self.fact.base.get("objects", [])

        for i in indices:
            obj_dict = dict(base_objects[i])  # Create a copy to modify
            data_dict = self.fact.base.get("data", {}).copy()
            obj_dict.update(data_dict)

            for assignment in assignment_list:
                if "=" in assignment:
                    key, expr = [part.strip() for part in assignment.split("=", 1)]
                    try:
                        # Prepare the local variables for eval
                        local_vars = obj_dict.copy()
                        value = eval(expr, {"__builtins__": {}}, local_vars)
                        if value is not None:
                            obj_dict[key] = value
                    except Exception as e:
                        self.error = f"Assign evaluation error for object {i}, assignment '{assignment}': {str(e)}"
                        return

            # Update the SpatialObject with the new dictionary
            self.fact.objects[i].from_any(obj_dict)
            # Also update the fact base
            self.fact.base["objects"][i] = obj_dict

    def calc(self, assignments: str):
        assignment_list = [assignment.strip() for assignment in assignments.split(";")]
        for assignment in assignment_list:
            if "=" in assignment:
                key, expr = [part.strip() for part in assignment.split("=", 1)]
                try:
                    # Prepare the local variables for eval
                    local_vars = self.fact.base.copy()
                    value = eval(expr, {"__builtins__": {}}, local_vars)
                    if value is not None:
                        self.fact.set_data(key, value)
                except Exception as e:
                    self.error = f"Calc evaluation error for assignment '{assignment}': {str(e)}"
                    return
        self.output = self.input.copy()
        self.succeeded = bool(self.output)

    def slice(self, range_str: str):
        # Replace ".." with "." to handle inclusive ranges
        range_str = range_str.replace("..", ".")
        parts = [part.strip() for part in range_str.split(".")]
        lower = 0
        upper = 0

        if len(parts) >= 1 and parts[0]:
            lower = int(parts[0])
            if lower >= len(self.input):
                lower = len(self.input)
            if lower < 0:
                lower = len(self.input) + lower
            else:
                lower = lower - 1

        if len(parts) >= 2 and parts[1]:
            upper = int(parts[1])
            if upper >= len(self.input):
                upper = len(self.input)
            if upper < 0:
                upper = len(self.input) + upper
            else:
                upper = upper - 1
        else:
            upper = lower

        if lower > upper:
            lower, upper = upper, lower

        # Clamp the range within valid indices
        lower = max(0, lower)
        upper = min(len(self.input) - 1, upper)

        idx_range = range(lower, upper + 1)
        self.output = [self.input[i] for i in idx_range]
        self.succeeded = bool(self.output)

    def sort(self, attribute: str):
        ascending = False
        sorted_objects = []
        input_objects = [self.fact.objects[i] for i in self.input]
        sorted_objects = input_objects.copy()

        # Check for ascending order if specified
        match = re.match(r"(\w+)\s*([<>])", attribute)
        if match:
            attr_name, order = match.groups()
            if order == "<":
                ascending = True
            else:
                ascending = False
            attr_name = attr_name.strip()
        else:
            attr_name = attribute.strip()

        # Determine the sorting key
        def sort_key(obj: 'SpatialObject'):
            if "." in attr_name:
                # Sort by relation value
                return obj.relation_value(attr_name, pre=self.fact.backtrace())
            else:
                # Sort by attribute value
                return obj.get_attribute_value(attr_name)

        try:
            sorted_objects.sort(key=sort_key, reverse=not ascending)
        except Exception as e:
            self.error = f"Sort evaluation error for attribute '{attribute}': {str(e)}"
            return

        # Update the output indices based on sorted order
        self.output = []
        for obj in sorted_objects:
            idx = self.fact.objects.index(obj)
            self.add(idx)
        self.succeeded = bool(self.output)

    def sort_by_relation(self, attribute: str):
        ascending = False
        sorted_objects = []
        pre_indices = self.fact.backtrace()
        input_objects = [self.fact.objects[i] for i in self.input]
        sorted_objects = input_objects.copy()

        # Check for ascending order if specified
        match = re.match(r"(\w+)\s*([<>])", attribute)
        if match:
            attr_name, order = match.groups()
            if order == "<":
                ascending = True
            else:
                ascending = False
            attr_name = attr_name.strip()
        else:
            attr_name = attribute.strip()

        # Determine the sorting key
        def sort_key(obj: 'SpatialObject'):
            try:
                return obj.relation_value(attr_name, pre=pre_indices)
            except Exception:
                return 0  # Default value if relation_value fails

        try:
            sorted_objects.sort(key=sort_key, reverse=not ascending)
        except Exception as e:
            self.error = f"Sort by relation error for attribute '{attribute}': {str(e)}"
            return

        # Update the output indices based on sorted order
        self.output = []
        for obj in sorted_objects:
            idx = self.fact.objects.index(obj)
            self.add(idx)
        self.succeeded = bool(self.output)

    def produce(self, terms: str):
        print(terms)  # Debug print, can be removed or replaced with logging
        parts = [part.strip() for part in terms.split(":")]
        if not parts:
            self.error = "Invalid produce terms."
            return

        rule = parts[0]
        assignments = parts[1] if len(parts) > 1 else ""
        indices: List[int] = []
        new_objects: List[Dict[str, Any]] = []

        if rule in ["group", "aggregate"]:
            if self.input:
                input_objects = [self.fact.objects[i] for i in self.input]
                sorted_objects = sorted(input_objects, key=lambda o: o.volume, reverse=True)
                largest_object = sorted_objects[0] if sorted_objects else None

                if largest_object:
                    min_y = 0.0
                    max_y = largest_object.height
                    min_x = -largest_object.width / 2.0
                    max_x = largest_object.width / 2.0
                    min_z = -largest_object.depth / 2.0
                    max_z = largest_object.depth / 2.0
                    group_id = f"group:{largest_object.id}"

                    for obj in sorted_objects[1:]:
                        local_pts = largest_object.into_local(obj.points(local=False))
                        for pt in local_pts:
                            min_x = min(min_x, float(pt.x))
                            max_x = max(max_x, float(pt.x))
                            min_y = min(min_y, float(pt.y))
                            max_y = max(max_y, float(pt.y))
                            min_z = min(min_z, float(pt.z))
                            max_z = max(max_z, float(pt.z))
                        group_id += f"+{obj.id}"

                    w = max_x - min_x
                    h = max_y - min_y
                    d = max_z - min_z
                    dx = min_x + w / 2.0
                    dy = min_y + h / 2.0
                    dz = min_z + d / 2.0

                    obj_idx = self.fact.index_of_id(group_id) or -1
                    group = self.fact.objects[obj_idx] if obj_idx >= 0 else SpatialObject(id=group_id)
                    group.set_position(largest_object.pos)
                    group.rot_shift(-largest_object.angle, dx, dy, dz)
                    group.angle = largest_object.angle
                    group.width = w
                    group.height = h
                    group.depth = d
                    group.cause = "rule_produced"

                    if obj_idx < 0:
                        new_objects.append(group.as_dict())
                        indices.append(len(self.fact.objects))
                        self.fact.objects.append(group)

        elif rule in ["copy", "duplicate"]:
            for i in self.input:
                copy_id = f"copy:{self.fact.objects[i].id}"
                idx = self.fact.index_of_id(copy_id)
                if idx is None:
                    copy_obj = SpatialObject(id=copy_id)
                    copy_obj.from_any(self.fact.objects[i].to_any())
                    copy_obj.cause = "rule_produced"
                    copy_obj.set_position(self.fact.objects[i].pos)
                    copy_obj.angle = self.fact.objects[i].angle
                    new_objects.append(copy_obj.as_dict())
                    indices.append(len(self.fact.objects))
                    self.fact.objects.append(copy_obj)
                else:
                    indices.append(idx)

        elif rule == "by":
            processed_bys = set()
            for i in self.input:
                rels = self.fact.relations_with(i, predicate="by")
                for rel in rels:
                    subject_idx = self.fact.index_of_id(rel.subject.id)
                    if subject_idx is not None and subject_idx in self.input:
                        key = f"{self.fact.objects[i].id}-{rel.subject.id}"
                        if key not in processed_bys:
                            nearest_pts = self.fact.objects[i].pos.nearest(rel.subject.points())
                            by_id = f"by:{self.fact.objects[i].id}-{rel.subject.id}"
                            obj_idx = self.fact.index_of_id(by_id) or -1
                            obj = self.fact.objects[obj_idx] if obj_idx >= 0 else SpatialObject(id=by_id)
                            obj.cause = "rule_produced"
                            if nearest_pts:
                                obj.set_position(nearest_pts[0])
                                obj.angle = self.fact.objects[i].angle
                                obj.width = max(rel.delta, self.fact.adjustment.maxGap)
                                obj.depth = max(rel.delta, self.fact.adjustment.maxGap)
                                obj.height = rel.subject.height
                                new_objects.append(obj.as_dict())
                                indices.append(len(self.fact.objects))
                                self.fact.objects.append(obj)
                            processed_bys.add(key)

        else:
            self.error = f"Unknown rule '{rule}' in produce()"
            return

        if indices:
            self.fact.base["objects"].extend(new_objects)
            if assignments:
                self.assign(assignments, indices)
            self.output = self.input.copy()
            for idx in indices:
                if idx not in self.output:
                    self.output.append(idx)
        else:
            self.output = self.input.copy()

        self.fact.load()
        self.succeeded = not self.error

    def reload(self):
        self.fact.sync_to_objects()
        self.fact.load()
        self.output = list(range(len(self.fact.objects)))
        self.succeeded = bool(self.output)

    def has_failed(self) -> bool:
        return bool(self.error)

    def is_manipulating(self) -> bool:
        operations = ["filter", "pick", "select", "produce", "slice"]
        return any(self.operation.startswith(op) for op in operations)

    def as_dict(self) -> Dict[str, Any]:
        return {
            "operation": self.operation,
            "input": self.input,
            "output": self.output,
            "error": self.error,
            "succeeded": self.succeeded
        }

    @staticmethod
    def attribute_predicate(condition: str) -> Optional[Any]:
        """
        Convert a condition string into a callable predicate function.
        For security reasons, using eval is dangerous. Consider using a safe parser.
        """
        try:
            # Replace attribute names with dictionary access
            # e.g., "width > 2" becomes "obj['width'] > 2"
            # Assuming all attributes are accessed via 'obj'
            # This is a simplistic approach and may need to be expanded
            pattern = re.compile(r'\b\w+\b')
            condition_converted = pattern.sub(lambda match: f"obj.get('{match.group(0)}', 0)", condition)
            # Compile the condition into a lambda function
            predicate = eval(f"lambda obj: {condition_converted}", {"__builtins__": {}})
            return predicate
        except Exception as e:
            print(f"Error creating attribute predicate: {e}")
            return None

    @staticmethod
    def extract_keywords(text: str) -> List[str]:
        """
        Extract lowercase letter sequences as keywords from a given text.
        """
        return re.findall(r'\b[a-z]+\b', text)

# Helper function to safely evaluate expressions
def safe_eval(expression: str, variables: Dict[str, Any]) -> Any:
    """
    Safely evaluate an expression using only the provided variables.
    This function restricts the available built-ins for security.
    """
    try:
        return eval(expression, {"__builtins__": {}}, variables)
    except Exception as e:
        raise ValueError(f"Error evaluating expression '{expression}': {str(e)}")

--------------------------------------------------------------

==> src/SpatialObject.py <==
# SpatialObject.py
# Python translation of the Swift SpatialObject class.

import math
import datetime
from typing import Any, Dict, List, Optional, TYPE_CHECKING
import logging

from .vector3 import Vector3
from .SpatialBasics import (
    NearbySchema,
    SectorSchema,
    SpatialAdjustment,
    SpatialPredicateCategories,
    ObjectConfidence,
    SpatialAtribute,
    SpatialExistence,
    ObjectCause,
    MotionState,
    ObjectShape,
    ObjectHandling,
    defaultAdjustment  # Ensure defaultAdjustment is accessible
)

from .SpatialPredicate import (
    SpatialPredicate,
    PredicateTerm,
    SpatialTerms,
    proximity,
    directionality,
    adjacency,
    orientations,
    assembly,
    topology,
    contacts,
    connectivity,
    comparability,
    similarity,
    visibility,
    geography,
    sectors
)


from .BBoxSector import BBoxSector, BBoxSectorFlags
if TYPE_CHECKING:
    from .SpatialRelation import SpatialRelation
else:
    from .SpatialRelation import SpatialRelation


class SpatialObject:
    # Class Variables
    booleanAttributes: List[str] = [
        "immobile", "moving", "focused", "visible",
        "equilateral", "thin", "long", "real",
        "virtual", "conceptual"
    ]
    numericAttributes: List[str] = [
        "width", "height", "depth", "w", "h",
        "d", "position", "x", "y", "z", "angle", "confidence"
    ]
    stringAttributes: List[str] = [
        "id", "label", "type", "supertype",
        "existence", "cause", "shape", "look"
    ]

    def __init__(
        self,
        id: str,
        position: Vector3 = Vector3(),
        width: float = 1.0,
        height: float = 1.0,
        depth: float = 1.0,
        angle: float = 0.0,
        label: str = "",
        confidence: float = 0.0
    ):
        # Non-spatial characteristics
        self.id: str = id  # unique id: UUID of source or own generated unique id
        self.existence: SpatialExistence = SpatialExistence.real
        self.cause: ObjectCause = ObjectCause.unknown
        self.label: str = label  # name or label
        self.type: str = ""  # class
        self.supertype: str = ""  # superclass
        self.look: str = ""  # textual description of appearance
        self.data: Optional[Dict[str, Any]] = None  # auxiliary data
        self.created: datetime.datetime = datetime.datetime.now()  # creation time
        self.updated: datetime.datetime = datetime.datetime.now()  # last update time

        # Spatial characteristics
        self.position: Vector3 = position  # base center point at bottom
        self.width: float = width
        self.height: float = height
        self.depth: float = depth
        self.angle: float = angle  # rotation around y axis in radians, counter-clockwise
        self.immobile: bool = False
        self.velocity: Vector3 = Vector3()  # velocity vector
        self.confidence: ObjectConfidence = ObjectConfidence()
        self.confidence.setSpatial(confidence)
        self.confidence.setValue(confidence)
        self.shape: ObjectShape = ObjectShape.unknown
        self.visible: bool = False  # in screen
        self.focused: bool = False  # in center of screen, for some time
        self.context: Optional['SpatialReasoner'] = None  # optional context

    # Derived Attributes
    @property
    def center(self) -> Vector3:
        return Vector3(
        self.position.x + self.width / 2.0,
        self.position.y + self.height / 2.0,
        self.position.z + self.depth / 2.0
    )

    @property
    def pos(self) -> Vector3:
        return self.position

    @property
    def yaw(self) -> float:
        # in degrees counter-clockwise of WCS
        return self.angle * 180.0 / math.pi

    @property
    def azimuth(self) -> float:
        # in degrees clockwise of GCS as ±360°
        if self.context is not None and self.context.north is not None:
            north_angle = math.atan2(self.context.north.y, self.context.north.x) * 180.0 / math.pi
            return -(self.yaw + north_angle - 90.0) % 360.0
        return 0.0

    @property
    def thin(self) -> bool:
        return self.thin_ratio() > 0

    @property
    def long(self) -> bool:
        return self.long_ratio() > 0

    @property
    def equilateral(self) -> bool:
        return self.long_ratio() == 0

    @property
    def real(self) -> bool:
        return self.existence == SpatialExistence.real

    @property
    def virtual(self) -> bool:
        return self.existence == SpatialExistence.virtual

    @property
    def conceptual(self) -> bool:
        return self.existence == SpatialExistence.conceptual

    @property
    def perimeter(self) -> float:
        # footprint perimeter
        return (self.depth + self.width) * 2.0

    @property
    def footprint(self) -> float:
        # base area, floor space
        return self.depth * self.width

    @property
    def frontface(self) -> float:
        # front area
        return self.height * self.width

    @property
    def sideface(self) -> float:
        # side area
        return self.height * self.depth

    @property
    def surface(self) -> float:
        # total surface of bbox
        return (self.height * self.width + self.depth * self.width + self.height * self.depth) * 2.0

    @property
    def volume(self) -> float:
        return self.depth * self.width * self.height

    @property
    def radius(self) -> float:
        # sphere radius from center comprising body volume
        return Vector3(self.width / 2.0, self.depth / 2.0, self.height / 2.0).length()

    @property
    def baseradius(self) -> float:
        # circle radius on 2D base / floor ground
        return math.hypot(self.width / 2.0, self.depth / 2.0)

    @property
    def motion(self) -> MotionState:
        if self.immobile:
            return MotionState.stationary
        if self.confidence.spatial > 0.5:
            if self.velocity.length() > self.adjustment.maxGap:
                return MotionState.moving
            return MotionState.idle
        return MotionState.unknown

    @property
    def moving(self) -> bool:
        return self.motion == MotionState.moving

    @property
    def speed(self) -> float:
        return self.velocity.length()

    @property
    def observing(self) -> bool:
        return self.cause == ObjectCause.self_tracked

    @property
    def length(self) -> float:
        alignment = self.long_ratio(1.1)
        if alignment == 1:
            return self.width
        elif alignment == 2:
            return self.height
        return self.depth

    @property
    def lifespan(self) -> float:
        now = datetime.datetime.now()
        return (now - self.created).total_seconds()

    @property
    def updateInterval(self) -> float:
        now = datetime.datetime.now()
        return (now - self.updated).total_seconds()

    @property
    def adjustment(self) -> SpatialAdjustment:
        return self.context.adjustment if self.context else defaultAdjustment
    
    @adjustment.setter
    def adjustment(self, value: SpatialAdjustment):
        if not isinstance(value, SpatialAdjustment):
            raise ValueError("adjustment must be an instance of SpatialAdjustment")
        self._adjustment = value

    # Index Method
    def index(self) -> int:
        if self.context is not None:
            try:
                return self.context.objects.index(self)
            except ValueError:
                return -1
        return -1

    # Static Methods
    @staticmethod
    def isBoolean(attribute: str) -> bool:
        return attribute in SpatialObject.booleanAttributes

    @staticmethod
    def createDetectedObject(
        id: str,
        label: str = "",
        width: float = 1.0,
        height: float = 1.0,
        depth: float = 1.0
    ) -> 'SpatialObject':
        obj = SpatialObject(
            id=id,
            position=Vector3(0.0, 0.0, 0.0),
            width=width,
            height=height,
            depth=depth
        )
        obj.label = label.lower()
        obj.type = label
        obj.cause = ObjectCause.object_detected
        obj.existence = SpatialExistence.real
        obj.confidence.setValue(0.25)
        obj.immobile = False
        obj.shape = ObjectShape.unknown
        return obj

    @staticmethod
    def createVirtualObject(
        id: str,
        width: float = 1.0,
        height: float = 1.0,
        depth: float = 1.0
    ) -> 'SpatialObject':
        obj = SpatialObject(
            id=id,
            position=Vector3(0.0, 0.0, 0.0),
            width=width,
            height=height,
            depth=depth
        )
        obj.cause = ObjectCause.user_generated
        obj.existence = SpatialExistence.virtual
        obj.confidence.setSpatial(1.0)
        obj.immobile = False
        return obj

    @staticmethod
    def createBuildingElement(
        id: str,
        type: str = "",
        from_pos: Vector3 = Vector3(),
        width: float = 1.0,
        height: float = 1.0,
        depth: float = 1.0
    ) -> 'SpatialObject':
        obj = SpatialObject(
            id=id,
            position=from_pos,
            width=width,
            height=height,
            depth=depth
        )
        obj.label = type.lower()
        obj.type = type
        obj.supertype = "Building Element"
        obj.cause = ObjectCause.plane_detected
        obj.existence = SpatialExistence.real
        obj.confidence.setValue(0.5)
        obj.immobile = True
        obj.shape = ObjectShape.cubical
        return obj

    @staticmethod
    def createBuildingElement_from_vectors(
        id: str,
        type: str = "",
        from_pos: Vector3 = Vector3(),
        to_pos: Vector3 = Vector3(),
        height: float = 1.0,
        depth: float = 0.25
    ) -> 'SpatialObject':
        mid_vector = (to_pos - from_pos) / 2.0
        mid_vector_length = mid_vector.length()
        factor = depth / mid_vector_length / 2.0
        normal = Vector3(mid_vector.x * factor, 0.0, mid_vector.z * factor).rotate(math.pi / 2.0)
        pos = from_pos + mid_vector - Vector3(normal.x, 0.0, normal.z)
        obj = SpatialObject(
            id=id,
            position=pos,
            width=mid_vector_length * 2.0,
            height=height,
            depth=depth
        )
        obj.angle = -math.atan2(mid_vector.z, mid_vector.x)
        obj.label = type.lower()
        obj.type = type
        obj.supertype = "Building Element"
        obj.cause = ObjectCause.user_captured
        obj.existence = SpatialExistence.real
        obj.confidence.setValue(0.9)
        obj.immobile = True
        obj.shape = ObjectShape.cubical
        return obj

    @staticmethod
    def createPerson(
        id: str,
        position: Vector3,
        name: str = ""
    ) -> 'SpatialObject':
        # Create with average dimensions of a person
        person = SpatialObject(
            id=id,
            position=position,
            width=0.46,
            height=1.72,
            depth=0.34
        )
        person.label = name
        person.cause = ObjectCause.self_tracked
        person.existence = SpatialExistence.real
        person.confidence.setValue(1.0)
        person.immobile = False
        person.supertype = "Creature"
        person.type = "Person"
        person.shape = ObjectShape.changing
        return person

    # Set Auxiliary Data
    def setData(self, key: str, value: Any):
        if self.data is not None:
            self.data[key] = value
        else:
            self.data = {key: value}

    def dataValue(self, key: str) -> float:
        if self.data is not None:
            value = self.data.get(key)
            if isinstance(value, float):
                return value
            if isinstance(value, (int,)):
                return float(value)
        return 0.0

    # Object Serialization
    # Full-fledged representation for fact base
    def asDict(self) -> Dict[str, Any]:
        output = {
            "id": self.id,
            "existence": self.existence.value,
            "cause": self.cause.value,
            "label": self.label,
            "type": self.type,
            "supertype": self.supertype,
            "position": [self.position.x, self.position.y, self.position.z],
            "center": [self.center.x, self.center.y, self.center.z],
            "width": self.width,
            "height": self.height,
            "depth": self.depth,
            "length": self.length,
            "direction": self.mainDirection(),
            "thin": self.thin,
            "long": self.long,
            "equilateral": self.equilateral,
            "real": self.real,
            "virtual": self.virtual,
            "conceptual": self.conceptual,
            "moving": self.moving,
            "perimeter": self.perimeter,
            "footprint": self.footprint,
            "frontface": self.frontface,
            "sideface": self.sideface,
            "surface": self.surface,
            "baseradius": self.baseradius,
            "volume": self.volume,
            "radius": self.radius,
            "angle": self.angle,
            "yaw": self.yaw,
            "azimuth": self.azimuth,
            "lifespan": self.lifespan,
            "updateInterval": self.updateInterval,
            "confidence": self.confidence.asDict(),
            "immobile": self.immobile,
            "velocity": [self.velocity.x, self.velocity.y, self.velocity.z],
            "motion": self.motion.value,
            "shape": self.shape.value,
            "look": self.look,
            "visible": self.visible,
            "focused": self.focused
        }
        if self.data is not None:
            output.update(self.data)  # keeping current
        return output

    # For export
    def toAny(self) -> Dict[str, Any]:
        output = {
            "id": self.id,
            "existence": self.existence.value,
            "cause": self.cause.value,
            "label": self.label,
            "type": self.type,
            "supertype": self.supertype,
            "position": [self.position.x, self.position.y, self.position.z],
            "width": self.width,
            "height": self.height,
            "depth": self.depth,
            "angle": self.angle,
            "immobile": self.immobile,
            "velocity": [self.velocity.x, self.velocity.y, self.velocity.z],
            "confidence": self.confidence.value,
            "shape": self.shape.value,
            "look": self.look,
            "visible": self.visible,
            "focused": self.focused
        }
        if self.data is not None:
            output.update(self.data)  # keeping current
        return output

        # Import/Update from JSON data
    def fromAny(self, input_data: Dict[str, Any]):
            # ID Handling
            id_str = input_data.get("id", "")
            if id_str:
                if self.id != id_str:
                    print("import/update from another id!")
                self.id = id_str

            # Position Handling
            pos_list = input_data.get("position", [])
            if isinstance(pos_list, list) and len(pos_list) == 3:
                pos = Vector3(float(pos_list[0]), float(pos_list[1]), float(pos_list[2]))
            else:
                x = float(input_data.get("x", self.position.x))
                y = float(input_data.get("y", self.position.y))
                z = float(input_data.get("z", self.position.z))
                pos = Vector3(x, y, z)
            self.setPosition(pos)

            # Dimensions Handling
            self.width = float(input_data.get("width", input_data.get("w", self.width)))
            self.height = float(input_data.get("height", input_data.get("h", self.height)))
            self.depth = float(input_data.get("depth", input_data.get("d", self.depth)))

            # Angle Handling
            self.angle = float(input_data.get("angle", self.angle))

            # Labels and Types Handling
            self.label = input_data.get("label", self.label)
            self.type = input_data.get("type", self.type)
            self.supertype = input_data.get("supertype", self.supertype)

            # Confidence Handling
            confidence_data = input_data.get("confidence", self.confidence.value)
                    
            # Check if confidence_data is a dictionary
            if isinstance(confidence_data, dict):
                # Safely extract each confidence component with defaults
                self.confidence.pose = float(confidence_data.get("pose", self.confidence.pose))
                self.confidence.dimension = float(confidence_data.get("dimension", self.confidence.dimension))
                self.confidence.label = float(confidence_data.get("label", self.confidence.label))
                self.confidence.look = float(confidence_data.get("look", self.confidence.look))
            else:
                # Assume confidence_data is a float or convertible to float
                try:
                    confidence_val = float(confidence_data)
                    self.confidence.setValue(confidence_val)
                except (TypeError, ValueError):
                    self.confidence.setValue(self.confidence.value)
            

            # Cause and Existence Handling
            cause_str = input_data.get("cause", self.cause.value)
            self.cause = ObjectCause.named(cause_str)
            existence_str = input_data.get("existence", self.existence.value)
            self.existence = SpatialExistence.named(existence_str)

            # Immobile Handling
            self.immobile = bool(input_data.get("immobile", self.immobile))

            # Shape Handling
            shape_str = input_data.get("shape", self.shape.value)
            self.shape = ObjectShape.named(shape_str)

            # Look Handling
            self.look = input_data.get("look", self.look)

            # Other Attributes Handling
            self.visible = bool(input_data.get("visible", self.visible))
            self.focused = bool(input_data.get("focused", self.focused))

            # Auxiliary Data Handling
            for key, value in input_data.items():
                if key not in SpatialObject.stringAttributes and \
                key not in SpatialObject.numericAttributes and \
                key not in SpatialObject.booleanAttributes:
                    self.setData(key, value)

            # Update Time
            self.updated = datetime.datetime.now()

    # Description
    def desc(self) -> str:
        parts = []
        if self.label and self.label != self.id:
            parts.append(f"{self.label}, ")
        if self.type:
            parts.append(f"{self.type}, ")
        if self.supertype:
            parts.append(f"{self.supertype}, ")
        pos_str = f"{self.position.x:.2f}/" \
                  f"{self.position.y:.2f}/" \
                  f"{self.position.z:.2f}, "
        dims_str = f"{self.width:.2f}x{self.depth:.2f}x{self.height:.2f}, "
        angle_str = f"𝜶:{self.yaw:.1f}°"
        parts.append(pos_str)
        parts.append(dims_str)
        parts.append(angle_str)
        return "".join(parts)

    # Position Setters
    def setPosition(self, pos: Vector3):
        interval = self.updateInterval
        if interval > 0.003 and not self.immobile:
            prev_pos = self.position
            self.velocity = (pos - prev_pos) / interval
        self.position = pos

    def setCenter(self, ctr: Vector3):
        new_position = Vector3(
        ctr.x - self.width / 2.0,
        ctr.y - self.height / 2.0,
        ctr.z - self.depth / 2.0
       )
        self.setPosition(new_position)

    # Rotation and Shifting
    def rotShift(self, rad: float, dx: float, dy: float = 0.0, dz: float = 0.0):
        rotsin = math.sin(rad)
        rotcos = math.cos(rad)
        rx = dx * rotcos - dz * rotsin
        rz = dx * rotsin + dz * rotcos
        vector = Vector3(rx, dy, rz)
        self.position += vector

    def setYaw(self, degrees: float):
        self.angle = degrees * math.pi / 180.0

    # Directional Methods
    def mainDirection(self) -> int:
        return self.long_ratio()

    def thin_ratio(self, ratio: float = defaultAdjustment.thinRatio) -> int:
        values = (width,height,depth) = [self.width, self.height, self.depth]
        max_val = max(values) if values else 0.0
        min_val = min(values) if values else 0.0
        if max_val >= (min_val * ratio):
            if (width == min_val) and (width > (ratio * min_val)) and (depth > (ratio * min_val)):
                return 2
            if (width == min_val )and (height > (ratio * min_val)) and (depth > (ratio * min_val)):
                return 1
            if (depth == min_val) and (width > (ratio * min_val)) and (height > (ratio * min_val)):
                return 3
        return 0

    def long_ratio(self, ratio: float = 0.5) -> int:  # Set default explicitly
        values = [self.width, self.height, self.depth]
        max_val = max(values) if values else 0.0
        min_val = min(values) if values else 0.0
        logging.debug(f"long_ratio called with ratio={ratio}, max_val={max_val}, min_val={min_val}")
        if max_val > 0.0 and max_val >= min_val * ratio:
            logging.debug("Condition max_val >= min_val * ratio met")
            if self.width < max_val:
                if self.height < max_val:
                    logging.debug("Returning 3")
                    return 3
                else:
                    logging.debug("Returning 2")
                    return 2
            else:
                logging.debug("Returning 1")
                return 1
        logging.debug("Condition max_val >= min_val * ratio not met, returning 0")
        return 0

    # Point Calculation Methods
    def lowerPoints(self, local: bool = False) -> List[Vector3]:
        p0 = Vector3(self.width / 2.0, self.depth / 2.0, 0.0)
        p1 = Vector3(-self.width / 2.0, self.depth / 2.0, 0.0)
        p2 = Vector3(-self.width / 2.0, -self.depth / 2.0, 0.0)
        p3 = Vector3(self.width / 2.0, -self.depth / 2.0, 0.0)
        vector = Vector3()

        if not local:
            p0 = p0.rotate(-self.angle)
            p1 = p1.rotate(-self.angle)
            p2 = p2.rotate(-self.angle)
            p3 = p3.rotate(-self.angle)
            vector = self.position

        return [
            Vector3(p0.x + vector.x, vector.y, p0.z + vector.z),
            Vector3(p1.x + vector.x, vector.y, p1.z + vector.z),
            Vector3(p2.x + vector.x, vector.y, p2.z + vector.z),
            Vector3(p3.x + vector.x, vector.y, p3.z + vector.z)
        ]

    def upperPoints(self, local: bool = False) -> List[Vector3]:
        p0 = Vector3(self.width / 2.0, self.depth / 2.0, self.height)
        p1 = Vector3(-self.width / 2.0, self.depth / 2.0, self.height)
        p2 = Vector3(-self.width / 2.0, -self.depth / 2.0, self.height)
        p3 = Vector3(self.width / 2.0, -self.depth / 2.0, self.height)
        vector = Vector3()

        if not local:
            p0 = p0.rotate(-self.angle)
            p1 = p1.rotate(-self.angle)
            p2 = p2.rotate(-self.angle)
            p3 = p3.rotate(-self.angle)
            vector = self.position

        return [
            Vector3(p0.x + vector.x, vector.y + self.height, p0.z + vector.z),
            Vector3(p1.x + vector.x, vector.y + self.height, p1.z + vector.z),
            Vector3(p2.x + vector.x, vector.y + self.height, p2.z + vector.z),
            Vector3(p3.x + vector.x, vector.y + self.height, p3.z + vector.z)
        ]

    def frontPoints(self, local: bool = False) -> List[Vector3]:
        p0 = Vector3(self.width / 2.0, self.depth / 2.0, 0.0)
        p1 = Vector3(-self.width / 2.0, self.depth / 2.0, 0.0)
        vector = Vector3()

        if not local:
            p0 = p0.rotate(-self.angle)
            p1 = p1.rotate(-self.angle)
            vector = self.position

        return [
            Vector3(p0.x + vector.x, vector.y, p0.z + vector.z),
            Vector3(p1.x + vector.x, vector.y, p1.z + vector.z),
            Vector3(p1.x + vector.x, vector.y + self.height, p1.z + vector.z),
            Vector3(p0.x + vector.x, vector.y + self.height, p0.z + vector.z)
        ]

    def backPoints(self, local: bool = False) -> List[Vector3]:
        p2 = Vector3(-self.width / 2.0, -self.depth / 2.0, 0.0)
        p3 = Vector3(self.width / 2.0, -self.depth / 2.0, 0.0)
        vector = Vector3()

        if not local:
            p2 = p2.rotate(-self.angle)
            p3 = p3.rotate(-self.angle)
            vector = self.position

        return [
            Vector3(p2.x + vector.x, vector.y, p2.z + vector.z),
            Vector3(p3.x + vector.x, vector.y, p3.z + vector.z),
            Vector3(p3.x + vector.x, vector.y + self.height, p3.z + vector.z),
            Vector3(p2.x + vector.x, vector.y + self.height, p2.z + vector.z)
        ]

    def rightPoints(self, local: bool = False) -> List[Vector3]:
        p1 = Vector3(-self.width / 2.0, self.depth / 2.0, 0.0)
        p2 = Vector3(-self.width / 2.0, -self.depth / 2.0, 0.0)
        vector = Vector3()

        if not local:
            p1 = p1.rotate(-self.angle)
            p2 = p2.rotate(-self.angle)
            vector = self.position

        return [
            Vector3(p1.x + vector.x, vector.y, p1.z + vector.z),
            Vector3(p2.x + vector.x, vector.y, p2.z + vector.z),
            Vector3(p2.x + vector.x, vector.y + self.height, p2.z + vector.z),
            Vector3(p1.x + vector.x, vector.y + self.height, p1.z + vector.z)
        ]

    def leftPoints(self, local: bool = False) -> List[Vector3]:
        p0 = Vector3(self.width / 2.0, self.depth / 2.0, 0.0)
        p3 = Vector3(self.width / 2.0, -self.depth / 2.0, 0.0)
        vector = Vector3()

        if not local:
            p0 = p0.rotate(-self.angle)
            p3 = p3.rotate(-self.angle)
            vector = self.position

        return [
            Vector3(p3.x + vector.x, vector.y, p3.z + vector.z),
            Vector3(p0.x + vector.x, vector.y, p0.z + vector.z),
            Vector3(p0.x + vector.x, vector.y + self.height, p0.z + vector.z),
            Vector3(p3.x + vector.x, vector.y + self.height, p3.z + vector.z)
        ]

    def points(self, local: bool = False) -> List[Vector3]:
        p0 = Vector3(self.width / 2.0, self.depth / 2.0, 0.0)
        p1 = Vector3(-self.width / 2.0, self.depth / 2.0, 0.0)
        p2 = Vector3(-self.width / 2.0, -self.depth / 2.0, 0.0)
        p3 = Vector3(self.width / 2.0, -self.depth / 2.0, 0.0)
        vector = Vector3()

        if not local:
            p0 = p0.rotate(-self.angle)
            p1 = p1.rotate(-self.angle)
            p2 = p2.rotate(-self.angle)
            p3 = p3.rotate(-self.angle)
            vector = self.position

        return [
            Vector3(p0.x + vector.x, vector.y, p0.z + vector.z),
            Vector3(p1.x + vector.x, vector.y, p1.z + vector.z),
            Vector3(p2.x + vector.x, vector.y, p2.z + vector.z),
            Vector3(p3.x + vector.x, vector.y, p3.z + vector.z),
            Vector3(p0.x + vector.x, vector.y + self.height, p0.z + vector.z),
            Vector3(p1.x + vector.x, vector.y + self.height, p1.z + vector.z),
            Vector3(p2.x + vector.x, vector.y + self.height, p2.z + vector.z),
            Vector3(p3.x + vector.x, vector.y + self.height, p3.z + vector.z)
        ]

    # Distance Methods
    def distance(self, to: Vector3) -> float:
        return (to - self.center).length()

    def baseDistance(self, to: Vector3) -> float:
        point = Vector3(to.x, self.position.y, to.z)
        return (point - self.position).length()

    # Coordinate Transformation
    def intoLocal(self, pt: Vector3) -> Vector3:
        vx = pt.x - self.position.x
        vz = pt.z - self.position.z
        rotsin = math.sin(self.angle)
        rotcos = math.cos(self.angle)
        x = vx * rotcos - vz * rotsin
        z = vx * rotsin + vz * rotcos
        return Vector3(x, pt.y - self.position.y, z)

    def intoLocal_pts(self, pts: List[Vector3]) -> List[Vector3]:
        rotsin = math.sin(self.angle)
        rotcos = math.cos(self.angle)
        result = []
        for pt in pts:
            vx = pt.x - self.position.x
            vz = pt.z - self.position.z
            x = vx * rotcos - vz * rotsin
            z = vx * rotsin + vz * rotcos
            result.append(Vector3(x, pt.y - self.position.y, z))
        return result

    def rotate_pts(self, pts: List[Vector3], by: float) -> List[Vector3]:
        rotsin = math.sin(by)
        rotcos = math.cos(by)
        result = []
        for pt in pts:
            x = pt.x * rotcos - pt.z * rotsin
            z = pt.x * rotsin + pt.z * rotcos
            result.append(Vector3(x, pt.y, z))
        return result

    # Sector Methods
    def sectorOf(self, point: Vector3, nearBy: bool = False, epsilon: float = -100.0) -> BBoxSector:
        zone = BBoxSector()
        if nearBy:
            pt = Vector3(point.x, point.y - self.height / 2.0, point.z)
            distance = pt.length()
            if distance > self.nearbyRadius():
                return zone
        if epsilon > -99.0:
            delta = epsilon
        else: 
            delta = self.adjustment.maxGap
    
        if (
            point.x <= self.width / 2.0 + delta and
            -point.x <= self.width / 2.0 + delta and
            point.z <= self.depth / 2.0 + delta and
            -point.z <= self.depth / 2.0 + delta and
            point.y <= self.height + delta and
            point.y >= -delta
        ):
            zone.insert(BBoxSectorFlags.i)
            return zone

        if point.x + delta > self.width / 2.0:
            zone.insert(BBoxSectorFlags.l)
        elif -point.x + delta > self.width / 2.0:
            zone.insert(BBoxSectorFlags.r)

        if point.z + delta > self.depth / 2.0:
            zone.insert(BBoxSectorFlags.a)
        elif -point.z + delta > self.depth / 2.0:
            zone.insert(BBoxSectorFlags.b)

        if point.y + delta > self.height:
            zone.insert(BBoxSectorFlags.o)
        elif point.y - delta < 0.0:
            zone.insert(BBoxSectorFlags.u)

        return zone

    def nearbyRadius(self) -> float:
        if self.adjustment.nearbySchema == NearbySchema.fixed:
            return self.adjustment.nearbyFactor
        elif self.adjustment.nearbySchema == NearbySchema.circle:
            return min(self.baseradius * self.adjustment.nearbyFactor, self.adjustment.nearbyLimit)
        elif self.adjustment.nearbySchema == NearbySchema.sphere:
            return min(self.radius * self.adjustment.nearbyFactor, self.adjustment.nearbyLimit)
        elif self.adjustment.nearbySchema == NearbySchema.perimeter:
            return min((self.height + self.width) * self.adjustment.nearbyFactor, self.adjustment.nearbyLimit)
        elif self.adjustment.nearbySchema == NearbySchema.area:
            return min(self.height * self.width * self.adjustment.nearbyFactor, self.adjustment.nearbyLimit)
        return 0.0

    def sector_lengths(self, sector: BBoxSector = BBoxSector(BBoxSectorFlags.i)) -> Vector3:
            """
            Calculate the sector lengths based on the provided sector.

            Args:
                sector (BBoxSector, optional): The sector to calculate lengths for. Defaults to inside sector.

            Returns:
                Vector3: The lengths in x, y, z directions.
            """
            result = Vector3(x=self.width, y=self.height, z=self.depth)
            
            if sector.contains(BBoxSectorFlags.a) or sector.contains(BBoxSectorFlags.b):
                if self.adjustment.sectorSchema == "fixed":
                    result.z = self.adjustment.sectorFactor
                elif self.adjustment.sectorSchema == "area":
                    result.z = min(self.height * self.width * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "dimension":
                    result.z = min(self.depth * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "perimeter":
                    result.z = min((self.height + self.width) * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "nearby":
                    result.z = min(self.nearby_radius(), self.adjustment.sectorLimit)
            
            if sector.contains(BBoxSectorFlags.l) or sector.contains(BBoxSectorFlags.r):
                if self.adjustment.sectorSchema == "fixed":
                    result.x = self.adjustment.sectorFactor
                elif self.adjustment.sectorSchema == "area":
                    result.x = min(self.height * self.depth * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "dimension":
                    result.x = min(self.width * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "perimeter":
                    result.x = min((self.height + self.depth) * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "nearby":
                    result.x = min(self.nearby_radius(), self.adjustment.sectorLimit)
            
            if sector.contains(BBoxSectorFlags.o) or sector.contains(BBoxSectorFlags.u):
                if self.adjustment.sectorSchema == "fixed":
                    result.y = self.adjustment.sectorFactor
                elif self.adjustment.sectorSchema == "area":
                    result.y = min(self.width * self.depth * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "dimension":
                    result.y = min(self.height * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "perimeter":
                    result.y = min((self.width + self.depth) * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "nearby":
                    result.y = min(self.nearby_radius(), self.adjustment.sectorLimit)
            
            return result

    # Topologies Method
    def topologies(self, subject: 'SpatialObject') -> List['SpatialRelation']:
        result: List['SpatialRelation'] = []
        relation: 'SpatialRelation'
        gap: float = 0.0
        minDistance: float = 0.0

        # Calculations in global world space
        center_vector = subject.center - self.center
        center_distance = center_vector.length()
        radius_sum = self.radius + subject.radius
        can_not_overlap = center_distance > radius_sum
        theta = subject.angle - self.angle
        is_disjoint = True
        is_connected = False

        # Calculations in local object space
        local_pts = self.intoLocal_pts(pts=subject.points())
        zones = [self.sectorOf(point=pt, nearBy=False, epsilon=0.00001) for pt in local_pts]
        local_center = self.intoLocal(pt=subject.center)
        center_zone = self.sectorOf(point=local_center, nearBy=False, epsilon=-self.adjustment.maxGap)

        # Nearness evaluated by center
        if center_distance < subject.nearbyRadius() + self.nearbyRadius():
            gap = center_distance
            minDistance = gap
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.near,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)
        else:
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.far,
                object=self,
                delta=center_distance,
                angle=theta
            )
            result.append(relation)

        # Basic adjacency in relation to center of object bbox
        if SpatialPredicate.l in center_zone:
            gap = float(local_center.x) - self.width / 2.0 - subject.width / 2.0
            minDistance = gap
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.left,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)
        elif SpatialPredicate.r in center_zone:
            gap = float(-local_center.x) - self.width / 2.0 - subject.width / 2.0
            minDistance = gap
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.right,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)

        if SpatialPredicate.a in center_zone:
            gap = float(local_center.z) - self.depth / 2.0 - subject.depth / 2.0
            minDistance = gap
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.ahead,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)
        elif SpatialPredicate.b in center_zone:
            gap = float(-local_center.z) - self.depth / 2.0 - subject.depth / 2.0
            minDistance = gap
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.behind,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)

        if SpatialPredicate.o in center_zone:
            gap = float(local_center.y) - subject.height / 2.0 - self.height
            minDistance = gap
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.above,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)
        elif SpatialPredicate.u in center_zone:
            gap = float(-local_center.y) - subject.height / 2.0
            minDistance = gap
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.below,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)

        # Side-related adjacency in relation to object bbox
        center_zone = self.sectorOf(point=local_center, nearBy=True, epsilon=-self.adjustment.maxGap)
        aligned = False  # orthogonal aligned
        is_beside = False

        if center_zone != SpatialPredicate.i:
            if abs(theta % (math.pi / 2.0)) < self.adjustment.maxAngleDelta:
                aligned = True

            min_val = float('inf')
            if SpatialPredicate.l in center_zone:
                for pt in local_pts:
                    min_val = min(min_val, float(pt.x) - self.width / 2.0)
                if min_val >= 0.0:
                    can_not_overlap = True
                    is_beside = True
                    minDistance = min_val
                    relation = SpatialRelation(
                        subject=subject,
                        predicate=SpatialPredicate.leftside,
                        object=self,
                        delta=min_val,
                        angle=theta
                    )
                    result.append(relation)
            elif SpatialPredicate.r in center_zone:
                for pt in local_pts:
                    min_val = min(min_val, float(-pt.x) - self.width / 2.0)
                if min_val >= 0.0:
                    can_not_overlap = True
                    is_beside = True
                    minDistance = min_val
                    relation = SpatialRelation(
                        subject=subject,
                        predicate=SpatialPredicate.rightside,
                        object=self,
                        delta=min_val,
                        angle=theta
                    )
                    result.append(relation)

            if SpatialPredicate.o in center_zone:
                for pt in local_pts:
                    min_val = min(min_val, float(pt.y) - self.height)
                if min_val >= 0.0:
                    can_not_overlap = True
                    minDistance = min_val
                    if min_val <= self.adjustment.maxGap:
                        relation = SpatialRelation(
                            subject=subject,
                            predicate=SpatialPredicate.ontop,
                            object=self,
                            delta=min_val,
                            angle=theta
                        )
                        result.append(relation)
                        if self.context and self.context.deduce.connectivity:
                            relation = SpatialRelation(
                                subject=subject,
                                predicate=SpatialPredicate.on,
                                object=self,
                                delta=min_val,
                                angle=theta
                            )
                            result.append(relation)
                    relation = SpatialRelation(
                        subject=subject,
                        predicate=SpatialPredicate.upperside,
                        object=self,
                        delta=min_val,
                        angle=theta
                    )
                    result.append(relation)
            elif SpatialPredicate.u in center_zone:
                for pt in local_pts:
                    min_val = min(min_val, float(-pt.y))
                if min_val >= 0.0:
                    can_not_overlap = True
                    minDistance = min_val
                    if min_val <= self.adjustment.maxGap:
                        relation = SpatialRelation(
                            subject=subject,
                            predicate=SpatialPredicate.beneath,
                            object=self,
                            delta=min_val,
                            angle=theta
                        )
                        result.append(relation)
                    relation = SpatialRelation(
                        subject=subject,
                        predicate=SpatialPredicate.lowerside,
                        object=self,
                        delta=min_val,
                        angle=theta
                    )
                    result.append(relation)

            if SpatialPredicate.a in center_zone:
                for pt in local_pts:
                    min_val = min(min_val, float(pt.z) - self.depth / 2.0)
                if min_val >= 0.0:
                    can_not_overlap = True
                    is_beside = True
                    minDistance = min_val
                    relation = SpatialRelation(
                        subject=subject,
                        predicate=SpatialPredicate.frontside,
                        object=self,
                        delta=min_val,
                        angle=theta
                    )
                    result.append(relation)
            elif SpatialPredicate.b in center_zone:
                for pt in local_pts:
                    min_val = min(min_val, float(-pt.z) - self.depth / 2.0)
                if min_val >= 0.0:
                    can_not_overlap = True
                    is_beside = True
                    minDistance = min_val
                    relation = SpatialRelation(
                        subject=subject,
                        predicate=SpatialPredicate.backside,
                        object=self,
                        delta=min_val,
                        angle=theta
                    )
                    result.append(relation)

            if is_beside:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.beside,
                    object=self,
                    delta=minDistance,
                    angle=theta
                )
                result.append(relation)

        # Check for assembly
        if all(zone.contains_flag(BBoxSectorFlags.i) for zone in zones):
            is_disjoint = False
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.inside,
                object=self,
                delta=center_distance,
                angle=theta
            )
            result.append(relation)
            if self.context and self.context.deduce.connectivity:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.in_,
                    object=self,
                    delta=center_distance,
                    angle=theta
                )
                result.append(relation)
        else:
            if (subject.radius - self.radius) > center_distance / 2.0 and \
               subject.width > self.width and \
               subject.height > self.height and \
               subject.depth > self.depth:
                is_disjoint = False
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.containing,
                    object=self,
                    delta=0.0,
                    angle=theta
                )
                result.append(relation)
            else:
                cnt = sum(1 for zone in zones if zone.contains_flag(BBoxSectorFlags.i))
                if cnt > 0 and not can_not_overlap:
                    is_disjoint = False
                    relation = SpatialRelation(
                        subject=subject,
                        predicate=SpatialPredicate.overlapping,
                        object=self,
                        delta=center_distance,
                        angle=theta
                    )
                    result.append(relation)

                crossings = 0
                minY = float(local_pts[0].y)
                maxY = float(local_pts[-1].y)
                minX = float('inf')
                maxX = -float('inf')
                minZ = float('inf')
                maxZ = -float('inf')

                for pt in local_pts:
                    minX = min(minX, float(pt.x))
                    maxX = max(maxX, float(pt.x))
                    minZ = min(minZ, float(pt.z))
                    maxZ = max(maxZ, float(pt.z))

                if not can_not_overlap:
                    if minX < -self.width / 2.0 and maxX > self.width / 2.0 and \
                       minZ < self.depth / 2.0 and maxZ > -self.depth / 2.0 and \
                       minY < self.height and maxY > 0:
                        crossings += 1
                    if minZ < -self.depth / 2.0 and maxZ > self.depth / 2.0 and \
                       minX < self.width / 2.0 and maxX > -self.width / 2.0 and \
                       minY < self.height and maxY > 0:
                        crossings += 1
                    if minY < 0.0 and maxY > self.height and \
                       minX < self.width / 2.0 and maxX > -self.width / 2.0 and \
                       minZ < self.depth / 2.0 and maxZ > -self.depth / 2.0:
                        crossings += 1
                    if crossings > 0:
                        is_disjoint = False
                        relation = SpatialRelation(
                            subject=subject,
                            predicate=SpatialPredicate.crossing,
                            object=self,
                            delta=center_distance,
                            angle=theta
                        )
                        result.append(relation)

                # ... [Continue translating the rest of the Swift function as needed] ...

        # Orientation Deduction
        if abs(theta) < self.adjustment.maxAngleDelta:
            gap = float(local_center.z)
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.aligned,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)

            front_gap = float(local_center.z) + subject.depth / 2.0 - self.depth / 2.0
            if abs(front_gap) < self.adjustment.maxGap:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.frontaligned,
                    object=self,
                    delta=front_gap,
                    angle=theta
                )
                result.append(relation)

            back_gap = float(local_center.z) - subject.depth / 2.0 + self.depth / 2.0
            if abs(back_gap) < self.adjustment.maxGap:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.backaligned,
                    object=self,
                    delta=back_gap,  # Corrected potential typo
                    angle=theta
                )
                result.append(relation)

            right_gap = float(local_center.x) - subject.width / 2.0 + self.width / 2.0
            if abs(right_gap) < self.adjustment.maxGap:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.rightaligned,
                    object=self,
                    delta=right_gap,  # Corrected potential typo
                    angle=theta
                )
                result.append(relation)

            left_gap = float(local_center.x) + subject.width / 2.0 - self.width / 2.0
            if abs(left_gap) < self.adjustment.maxGap:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.leftaligned,
                    object=self,
                    delta=left_gap,  # Corrected potential typo
                    angle=theta
                )
                result.append(relation)
        else:
            gap = center_distance
            if abs(theta % math.pi) < self.adjustment.maxAngleDelta:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.opposite,
                    object=self,
                    delta=gap,
                    angle=theta
                )
                result.append(relation)
            elif abs(theta % (math.pi / 2.0)) < self.adjustment.maxAngleDelta:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.orthogonal,
                    object=self,
                    delta=gap,
                    angle=theta
                )
                result.append(relation)

        # Visibility Deduction
        if self.context and self.context.deduce.visibility:
            if self.type == "Person" or (self.cause == ObjectCause.self_tracked and self.existence == SpatialExistence.real):
                rad = math.atan2(subject.center.x, subject.center.z)
                angle_deg = rad * 180.0 / math.pi
                hour_angle = 30.0  # 360.0 / 12.0
                if angle_deg < 0.0:
                    angle_deg -= hour_angle / 2.0
                else:
                    angle_deg += hour_angle / 2.0
                cnt = int(angle_deg / hour_angle)
                doit = True
                pred = SpatialPredicate.twelveoclock
                if cnt == 4:
                    pred = SpatialPredicate.eightoclock
                elif cnt == 3:
                    pred = SpatialPredicate.nineoclock
                elif cnt == 2:
                    pred = SpatialPredicate.tenoclock
                elif cnt == 1:
                    pred = SpatialPredicate.elevenoclock
                elif cnt == 0:
                    pred = SpatialPredicate.twelveoclock
                elif cnt == -1:
                    pred = SpatialPredicate.oneoclock
                elif cnt == -2:
                    pred = SpatialPredicate.twooclock
                elif cnt == -3:
                    pred = SpatialPredicate.threeoclock
                elif cnt == -4:
                    pred = SpatialPredicate.fouroclock
                else:
                    doit = False

                if doit:
                    relation = SpatialRelation(
                        subject=subject,
                        predicate=pred,
                        object=self,
                        delta=center_distance,
                        angle=rad
                    )
                    result.append(relation)
                    if center_distance <= 1.25:  # 70cm arm length plus 25cm shoulder plus 30cm leaning forward
                        relation = SpatialRelation(
                            subject=subject,
                            predicate=SpatialPredicate.tangible,
                            object=self,
                            delta=center_distance,
                            angle=rad
                        )
                        result.append(relation)

        return result

    # Similarities Method
    def similarities(self, subject: 'SpatialObject') -> List['SpatialRelation']:
        result: List['SpatialRelation'] = []
        relation: 'SpatialRelation'
        theta = subject.angle - self.angle
        val: float = 0.0
        minVal: float = 0.0
        maxVal: float = 0.0
        sameWidth: bool = False
        sameDepth: bool = False
        sameHeight: bool = False

        # Same Center
        val = (self.center - subject.center).length()
        if val < self.adjustment.maxGap:
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samecenter,
                object=self,
                delta=val,
                angle=theta
            )
            result.append(relation)

        # Same Position
        val = (self.position - subject.position).length()
        if val < self.adjustment.maxGap:
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.sameposition,
                object=self,
                delta=val,
                angle=theta
            )
            result.append(relation)

        # Same Width
        val = abs(self.width - subject.width)
        if val < self.adjustment.maxGap:
            sameWidth = True
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samewidth,
                object=self,
                delta=val,
                angle=theta
            )
            result.append(relation)

        # Same Depth
        val = abs(self.depth - subject.depth)
        if val < self.adjustment.maxGap:
            sameDepth = True
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samedepth,
                object=self,
                delta=val,
                angle=theta
            )
            result.append(relation)

        # Same Height
        val = abs(self.height - subject.height)
        if val < self.adjustment.maxGap:
            sameHeight = True
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.sameheight,
                object=self,
                delta=val,
                angle=theta
            )
            result.append(relation)

        # Same Perimeter
        val = subject.depth * subject.width
        minVal = (self.depth - self.adjustment.maxGap) + (self.width - self.adjustment.maxGap)
        maxVal = (self.depth + self.adjustment.maxGap) + (self.width + self.adjustment.maxGap)
        if minVal < val < maxVal:
            gap = self.depth * self.width - val
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.sameperimeter,
                object=self,
                delta=2.0 * gap,
                angle=theta
            )
            result.append(relation)

        # Same Cuboid
        if sameWidth and sameDepth and sameHeight:
            val = subject.volume - self.volume
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samecuboid,
                object=self,
                delta=val,
                angle=theta
            )
            result.append(relation)

        # Same Length
        val = abs(self.length - subject.length)
        if val < self.adjustment.maxGap:
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samelength,
                object=self,
                delta=val,
                angle=theta
            )
            result.append(relation)

        # Same Front
        val = subject.height * subject.width
        minVal = (self.height - self.adjustment.maxGap) * (self.width - self.adjustment.maxGap)
        maxVal = (self.height + self.adjustment.maxGap) * (self.width + self.adjustment.maxGap)
        if minVal < val < maxVal:
            gap = self.height * self.width - val
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samefront,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)

        # Same Side
        val = subject.height * subject.depth
        minVal = (self.height - self.adjustment.maxGap) * (self.depth - self.adjustment.maxGap)
        maxVal = (self.height + self.adjustment.maxGap) * (self.depth + self.adjustment.maxGap)
        if minVal < val < maxVal:
            gap = self.height * self.depth - val
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.sameside,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)

        # Same Footprint
        val = subject.width * subject.depth
        minVal = (self.width - self.adjustment.maxGap) * (self.depth - self.adjustment.maxGap)
        maxVal = (self.width + self.adjustment.maxGap) * (self.depth + self.adjustment.maxGap)
        if minVal < val < maxVal:
            gap = self.width * self.depth - val
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samefootprint,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)

        # Same Surface
        val = (subject.width ** 2) + (subject.depth ** 2) + (subject.height ** 2)
        minVal = ((self.width - self.adjustment.maxGap) ** 2) + ((self.depth - self.adjustment.maxGap) ** 2) + ((self.height - self.adjustment.maxGap) ** 2)
        maxVal = ((self.width + self.adjustment.maxGap) ** 2) + ((self.depth + self.adjustment.maxGap) ** 2) + ((self.height + self.adjustment.maxGap) ** 2)
        if minVal < val < maxVal:
            gap = ((self.width ** 2) + (self.depth ** 2) + (self.height ** 2)) - val
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samesurface,
                object=self,
                delta=2.0 * gap,
                angle=theta
            )
            result.append(relation)

        # Same Volume
        val = subject.width * subject.depth * subject.height
        minVal = (self.width - self.adjustment.maxGap) * (self.depth - self.adjustment.maxGap) * (self.height - self.adjustment.maxGap)
        maxVal = (self.width + self.adjustment.maxGap) * (self.depth + self.adjustment.maxGap) * (self.height + self.adjustment.maxGap)
        if minVal < val < maxVal:
            gap = self.width * self.depth * self.height - val
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samevolume,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)
            val_distance = (self.position - subject.position).length()
            angle_diff = abs(self.angle - subject.angle)
            if sameWidth and sameDepth and sameHeight and val_distance < self.adjustment.maxGap and angle_diff < self.adjustment.maxAngleDelta:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.congruent,
                    object=self,
                    delta=gap,
                    angle=theta
                )
                result.append(relation)

        # Same Shape
        if self.shape == subject.shape and self.shape != ObjectShape.unknown and subject.shape != ObjectShape.unknown:
            gap = self.width * self.depth * self.height - val
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.sameshape,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)

        return result

    # Comparisons Method
    def comparisons(self, subject: 'SpatialObject') -> List['SpatialRelation']:
        result: List['SpatialRelation'] = []
        relation: 'SpatialRelation'
        theta = subject.angle - self.angle
        objVal: float = 0.0
        subjVal: float = 0.0
        diff: float = 0.0
        shorterAdded: bool = False

        # Longer or Shorter Length
        objVal = self.length
        subjVal = subject.length
        diff = subjVal - objVal
        if diff > (self.adjustment.maxGap ** 3):
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.longer,
                object=self,
                delta=diff,
                angle=theta
            )
            result.append(relation)
        elif -diff > (self.adjustment.maxGap ** 3):
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.shorter,
                object=self,
                delta=diff,
                angle=theta
            )
            result.append(relation)
            shorterAdded = True

        # Taller or Shorter Height
        objVal = self.height
        subjVal = subject.height
        diff = subjVal - objVal
        if diff > self.adjustment.maxGap:
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.taller,
                object=self,
                delta=diff,
                angle=theta
            )
            result.append(relation)
        elif -diff > self.adjustment.maxGap and not shorterAdded:
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.shorter,
                object=self,
                delta=diff,
                angle=theta
            )
            result.append(relation)

        # Wider or Thinner Footprint
        if subject.mainDirection() == 2:
            objVal = self.footprint
            subjVal = subject.footprint
            diff = subjVal - objVal
            if diff > (self.adjustment.maxGap ** 2):
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.wider,
                    object=self,
                    delta=diff,
                    angle=theta
                )
                result.append(relation)
            elif -diff > (self.adjustment.maxGap ** 2):
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.thinner,
                    object=self,
                    delta=diff,
                    angle=theta
                )
                result.append(relation)

        # Same Volume
        objVal = self.volume
        subjVal = subject.volume
        diff = subjVal - objVal
        if (self.width * self.depth * self.height) - subjVal > (self.adjustment.maxGap ** 3):
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.bigger,
                object=self,
                delta=diff,
                angle=theta
            )
            result.append(relation)
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.exceeding,
                object=self,
                delta=diff,
                angle=theta
            )
            result.append(relation)
        elif -diff > (self.adjustment.maxGap ** 3):
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.smaller,
                object=self,
                delta=diff,
                angle=theta
            )
            result.append(relation)

        # Fitting
        if self.height > subject.height and self.footprint > subject.footprint:
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.fitting,
                object=self,
                delta=diff,
                angle=theta
            )
            result.append(relation)

        return result

    # Sector Relation Method
    def sector(self, subject: 'SpatialObject', nearBy: bool = False, epsilon: float = 0.0) -> 'SpatialRelation':
        center_vector = subject.center - self.center
        center_distance = center_vector.length()
        local_center = self.intoLocal(pt=subject.center)
        center_zone = self.sectorOf(point=local_center, nearBy=nearBy, epsilon=epsilon)
        theta = subject.angle - self.angle
        pred = SpatialPredicate.named(str(center_zone))
        return SpatialRelation(
            subject=subject,
            predicate=pred,
            object=self,
            delta=center_distance,
            angle=theta
        )

    # As Seen Relations Method
    def asseen(self, subject: 'SpatialObject', observer: 'SpatialObject') -> List['SpatialRelation']:
        result: List['SpatialRelation'] = []
        pos_vector = subject.position - self.position
        pos_distance = pos_vector.length()
        radius_sum = self.baseradius + subject.baseradius

        # Check for nearby
        if pos_distance < subject.nearbyRadius() + self.nearbyRadius():
            center_object = observer.intoLocal(pt=self.center)
            center_subject = observer.intoLocal(pt=subject.center)
            if center_subject.z > 0.0 and center_object.z > 0.0:  # both are ahead of observer
                # Turn both by view angle to become normal to observer
                rad = math.atan2(center_object.x, center_object.z)
                rotated = self.rotate(pts=[center_object, center_subject], by=-rad)
                center_object = rotated[0]
                center_subject = rotated[1]
                xgap = float(center_subject.x - center_object.x)
                zgap = float(center_subject.z - center_object.z)

                if abs(xgap) > min(self.width / 2.0, self.depth / 2.0) and abs(zgap) < radius_sum:
                    if xgap > 0.0:
                        relation = SpatialRelation(
                            subject=subject,
                            predicate=SpatialPredicate.seenleft,
                            object=self,
                            delta=abs(xgap),
                            angle=0.0
                        )
                        result.append(relation)
                    else:
                        relation = SpatialRelation(
                            subject=subject,
                            predicate=SpatialPredicate.seenright,
                            object=self,
                            delta=abs(xgap),
                            angle=0.0
                        )
                        result.append(relation)

                if abs(zgap) > min(self.width / 2.0, self.depth / 2.0) and abs(xgap) < radius_sum:
                    if zgap > 0.0:
                        relation = SpatialRelation(
                            subject=subject,
                            predicate=SpatialPredicate.atrear,
                            object=self,
                            delta=abs(zgap),
                            angle=0.0
                        )
                        result.append(relation)
                    else:
                        relation = SpatialRelation(
                            subject=subject,
                            predicate=SpatialPredicate.infront,
                            object=self,
                            delta=abs(zgap),
                            angle=0.0
                        )
                        result.append(relation)

        return result

    # Relate Method
    def relate(
        self,
        subject: 'SpatialObject',
        topology: bool = False,
        similarity: bool = False,
        comparison: bool = False
    ) -> List['SpatialRelation']:
        result: List['SpatialRelation'] = []
        if topology or (self.context and self.context.deduce.topology) or (self.context and self.context.deduce.connectivity):
            result.extend(self.topologies(subject=subject))
        if similarity or (self.context and self.context.deduce.similarity):
            result.extend(self.similarities(subject=subject))
        if comparison or (self.context and self.context.deduce.comparability):
            result.extend(self.comparisons(subject=subject))
        if self.context and self.context.observer and self.context.deduce.visibility:
            result.extend(self.asseen(subject=subject, observer=self.context.observer))
        return result

    # Relation Value Method
    def relationValue(self, relval: str, pre: List[int]) -> float:
        list_split = [part.strip() for part in relval.split(".")]
        if len(list_split) != 2 and self.context is None:
            return 0.0
        predicate = list_split[0]
        attribute = list_split[1]
        result_val: float = 0.0
        for i in pre:
            if self.context:
                rels = self.context.relationsWith(i, predicate=predicate)
                for rel in rels:
                    if rel.subject == self:
                        if attribute == "angle":
                            result_val = rel.angle
                        else:
                            result_val = rel.delta
        return result_val
    
    def rotate(self, pts: List[Vector3], by: float) -> List[Vector3]:
        """
        Rotates a list of Vector3 points around the Y-axis by the specified angle.

        Args:
            pts (List[Vector3]): The list of points to rotate.
            by_angle (float): The rotation angle in radians.

        Returns:
            List[Vector3]: A new list of rotated points.
        """
        result = []
        rotsin = math.sin(by)
        rotcos = math.cos(by)

        for pt in pts:
            new_x = pt.x * rotcos - pt.z * rotsin
            new_z = pt.x * rotsin + pt.z * rotcos
            # Y remains unchanged during Y-axis rotation
            rotated_pt = Vector3(x=new_x, y=pt.y, z=new_z)
            result.append(rotated_pt)

        return result

    # Visualization Functions
    """
    def bboxCube(self, color: Any) -> 'SCNNode':
        name = self.id if not self.label else self.label
        group = SCNNode()
        group.name = self.id
        box = SCNBox(width=self.width, height=self.height, length=self.depth, chamferRadius=0.0)
        box.firstMaterial.diffuse.contents = color
        box.firstMaterial.transparency = 1.0 - color.alpha
        boxNode = SCNNode(geometry=box)
        group.addChildNode(boxNode)

        # Set name at front
        text = SCNText(string=name, extrusionDepth=0.0)
        text.firstMaterial.diffuse.contents = color
        text.firstMaterial.lightingModel = .constant
        textNode = SCNNode(geometry=text)
        fontSize = 0.005
        min_bound, max_bound = textNode.boundingBox
        textNode.position.x = -((max_bound.x - min_bound.x) / 2.0 * fontSize)
        textNode.position.y = -self.height * 0.48
        textNode.position.z = self.depth / 2.0 + 0.2
        textNode.renderingOrder = 1
        textNode.eulerAngles.x = -math.pi / 2.0
        textNode.scale = Vector3(fontSize, fontSize, fontSize)
        group.addChildNode(textNode)

        group.eulerAngles.y = self.angle
        group.position = self.center
        return group

    def nearbySphere(self) -> 'SCNNode':
        r = self.nearbyRadius()
        sphere = SCNSphere(radius=r)
        sphere.firstMaterial.diffuse.contents = (0.1, 0.1, 0.1, 0.5)  # CGColor(gray: 0.1, alpha: 0.5)
        sphere.firstMaterial.transparency = 0.5
        node = SCNNode(geometry=sphere)
        node.name = f"Nearby sphere of {self.label if self.label else self.id}"
        node.position = self.center
        return node

    def sectorCube(self, sector: BBoxSector = BBoxSector.i, withLabel: bool = False) -> 'SCNNode':
        dims = self.sectorLenghts(sector)
        box = SCNBox(width=dims.x, height=dims.y, length=dims.z, chamferRadius=0.0)
        box.firstMaterial.diffuse.contents = (0.1, 0.1, 0.1, 0.5)  # CGColor(gray: 0.1, alpha: 0.5)
        box.firstMaterial.transparency = 0.5
        node = SCNNode(geometry=box)
        node.name = f"{sector.description} sector"

        shift = Vector3()
        if SpatialTerms.o in sector:
            shift.y = (self.height + dims.y) / 2.0
        elif SpatialTerms.u in sector:
            shift.y = (-self.height - dims.y) / 2.0

        if SpatialTerms.r in sector:
            shift.x = (-self.width - dims.x) / 2.0
        elif SpatialTerms.l in sector:
            shift.x = (self.width + dims.x) / 2.0

        if SpatialTerms.a in sector:
            shift.z = (self.depth + dims.z) / 2.0
        elif SpatialTerms.b in sector:
            shift.z = (-self.depth - dims.z) / 2.0

        node.position = self.center + shift

        if withLabel:
            text = SCNText(string=str(sector), extrusionDepth=0.0)
            text.firstMaterial.diffuse.contents = (1.0, 1.0, 0.0, 0.0)  # CGColor(red: 1.0, green: 1.0, blue: 0.0, alpha: 0.0)
            text.firstMaterial.lightingModel = .constant
            textNode = SCNNode(geometry=text)
            fontSize = 0.01
            min_bound, max_bound = textNode.boundingBox
            textNode.position.x = -((max_bound.x - min_bound.x) / 2.0 * fontSize)
            textNode.position.y = -0.2  # Adjust as needed
            textNode.position.z = 0.0
            textNode.renderingOrder = 1
            textNode.scale = Vector3(fontSize, fontSize, fontSize)
            node.addChildNode(textNode)

        return node

    def pointNodes(self, pts: Optional[List[Vector3]] = None) -> 'SCNNode':
        points = self.points() if not pts else pts
        group = SCNNode()
        group.name = f"BBox corners of {self.label if self.label else self.id}"
        for point in points:
            geometry = SCNSphere(radius=0.01)
            geometry.firstMaterial.diffuse.contents = (0.0, 1.0, 0.0, 0.0)  # CGColor(red: 0.0, green: 1.0, blue: 0.0, alpha: 0.0)
            node = SCNNode(geometry=geometry)
            node.position = point
            group.addChildNode(node)
        return group

    @staticmethod
    def export3D(to_url: str, nodes: List['SCNNode']):
        scene = SCNScene()
        for node in nodes:
            scene.rootNode.addChildNode(node)
        scene.write(to=to_url, options={}, delegate=None, progressHandler=None)

    # ... [End of the SpatialObject class]
    """
    
--------------------------------------------------------------

==> src/SpatialPredicate.py <==
# src/spatial_predicate.py

from enum import Enum
from dataclasses import dataclass
from typing import List


class SpatialPredicate(Enum):
    undefined = "undefined"
    # TOPOLOGY
    # proximity: near by
    near = "near"                # A is near to B, is close
    far = "far"                  # not near
    # directionality: in relation to position and orientation of object comparing center
    left = "left"
    right = "right"
    above = "above"
    below = "below"
    ahead = "ahead"
    behind = "behind"
    # adjacency: near by and at one side
    ontop = "on top"             # A is on top of B, very close contact
    beneath = "beneath"          # A is beneath of B, very close contact
    upperside = "at upper side"  # A is at upper side of B
    lowerside = "at lower side"  # A is at lower side of B
    leftside = "at left side"    # A is left side from B
    rightside = "at right side"  # A is right side from B
    frontside = "at front side"  # A is at front side of B, ahead
    backside = "at back side"    # A is at back side of B, behind
    # orientations
    orthogonal = "orthogonal"    # A is orthogonal to B, perpendicular to
    opposite = "opposite"        # opposite alignment
    aligned = "aligned"          # equally aligned orientation, parallel with
    frontaligned = "front aligned"  # same orientation and in same front plane
    backaligned = "back aligned"    # same orientation and in same back plane
    leftaligned = "left aligned"    # same orientation and in same left plane
    rightaligned = "right aligned"  # same orientation and in same right plane
    # assembly
    disjoint = "disjoint"            # no space in common
    inside = "inside"                # A is inside B
    containing = "containing"        # A is containing/contains B
    overlapping = "overlapping"      # (partially) overlapping, intersecting
    crossing = "crossing"            # intersecting by going through object
    # dividing = "dividing"          # crossing and dividing into parts (commented out in Swift)
    touching = "touching"            # touching edge-to-edge or edge-to-side = at edge
    meeting = "meeting"              # meeting side-by-side
    beside = "beside"                # near but not above or below
    fitting = "fitting"              # is fitting into
    exceeding = "exceeding"          # not fitting into
    # COMPARABILITY
    # comparisons
    smaller = "smaller"              # volume
    bigger = "bigger"                # syn: larger
    shorter = "shorter"              # length, height
    longer = "longer"                # length
    taller = "taller"                # height
    thinner = "thinner"              # width, depth --> footprint, syn: narrower
    wider = "wider"                  # syn: thicker
    # SIMILARITY
    # fuzzy comparison considering max deviation
    samewidth = "same width"
    sameheight = "same height"
    samedepth = "same depth"
    samelength = "same length"       # same length of main direction
    samefront = "same front face"
    sameside = "same side face"
    samefootprint = "same footprint"
    samevolume = "same volume"
    samecenter = "same center"
    sameposition = "same position"  # on base
    samecuboid = "same cuboid"
    congruent = "congruent"          # A is congruent to B, similar w,h,d, center and orientation, identical
    sameshape = "same shape"
    samesurface = "samesurface"
    # samecause is commented out
    # VISIBILITY
    # perspectives: seen from user / observer
    seenleft = "seen left"           # A is seen left of B by P
    seenright = "seen right"
    infront = "in front"             # (partially) covering
    atrear = "at rear"               # at back
    tangible = "tangible"             # within arm reach by user
    eightoclock = "eight o'clock"   # at 8 o'clock
    nineoclock = "nine o'clock"
    tenoclock = "ten o'clock"
    elevenoclock = "eleven o'clock"
    twelveoclock = "twelve o'clock"
    oneoclock = "one o'clock"
    twooclock = "two o'clock"
    threeoclock = "three o'clock"
    fouroclock = "four o'clock"
    # multistage relations
    secondleft = "second left"
    secondright = "second right"
    mostleft = "most left"
    mostright = "most right"
    # CONNECTIVITY
    # contacts
    on = "on"                        # on top of, unilateral
    at = "at"                        # attached and aligned with, unilateral
    by = "by"                        # connected, bilateral
    in_ = "in"                       # within, unilateral (note: 'in' is a reserved keyword in Python)
    # SECTORIALITY
    # center within bbox sector
    i = "i"
    a = "a"
    b = "b"
    l = "l"
    r = "r"
    o = "o"
    u = "u"
    al = "al"
    ar = "ar"
    bl = "bl"
    br = "br"
    ao = "ao"
    au = "au"
    bo = "bo"
    bu = "bu"
    lo = "lo"
    lu = "lu"
    ro = "ro"
    ru = "ru"
    alo = "alo"
    aro = "aro"
    blo = "blo"
    bro = "bro"
    alu = "alu"
    aru = "aru"
    blu = "blu"
    bru = "bru"
    # GEOGRAPHY
    # geographic direction
    north = "north"
    south = "south"
    east = "east"
    west = "west"
    northwest = "northwest"
    northeast = "northeast"
    southwest = "southwest"
    southeast = "southeast"

    @staticmethod
    def named(name: str) -> 'SpatialPredicate':
        for member in SpatialPredicate:
            if member.value == name:
                return member
        return SpatialPredicate.undefined


@dataclass
class PredicateTerm:
    code: SpatialPredicate
    predicate: str  # subject - predicate - object
    preposition: str
    synonym: str = ""
    reverse: str = ""  # object - predicate - subject
    antonym: str = ""  # if not predicate then antonym
    verb: str = "is"


class SpatialTerms:
    # List of PredicateTerm instances
    list: List[PredicateTerm] = [
        # TOPOLOGY
        # proximity in WCS and OCS
        PredicateTerm(code=SpatialPredicate.near, predicate="near", preposition="to", synonym="close", reverse="near", antonym="far", verb="is"),
        PredicateTerm(code=SpatialPredicate.far, predicate="far", preposition="from", synonym="close", reverse="far", antonym="near", verb="is"),
        # directionality in OCS
        PredicateTerm(code=SpatialPredicate.left, predicate="left", preposition="of", synonym="to the left"),
        PredicateTerm(code=SpatialPredicate.right, predicate="right", preposition="of", synonym="to the right"),
        PredicateTerm(code=SpatialPredicate.ahead, predicate="ahead", preposition="of", synonym="before"),
        PredicateTerm(code=SpatialPredicate.behind, predicate="behind", preposition="", synonym="after"),
        PredicateTerm(code=SpatialPredicate.above, predicate="above", preposition="", synonym="over", reverse="below"),
        PredicateTerm(code=SpatialPredicate.below, predicate="below", preposition="", synonym="under", reverse="above"),
        
        PredicateTerm(code=SpatialPredicate.l, predicate="left", preposition="of", synonym="to the left"),
        PredicateTerm(code=SpatialPredicate.r, predicate="right", preposition="of", synonym="to the right"),
        PredicateTerm(code=SpatialPredicate.a, predicate="ahead", preposition="of", synonym="before"),
        PredicateTerm(code=SpatialPredicate.b, predicate="behind", preposition="", synonym="after"),
        PredicateTerm(code=SpatialPredicate.o, predicate="above", preposition="", synonym="over", reverse="below"),
        PredicateTerm(code=SpatialPredicate.u, predicate="below", preposition="", synonym="under", reverse="above"),
        # adjacency in OCS
        PredicateTerm(code=SpatialPredicate.ontop, predicate="on top", preposition="of", synonym="at the top", reverse="beneath"),
        PredicateTerm(code=SpatialPredicate.beneath, predicate="beneath", preposition="", synonym="underneath", reverse="on top"),
        PredicateTerm(code=SpatialPredicate.upperside, predicate="at upper side", preposition="of", reverse="at lower side"),
        PredicateTerm(code=SpatialPredicate.lowerside, predicate="at lower side", preposition="of", reverse="at upper side"),
        PredicateTerm(code=SpatialPredicate.leftside, predicate="at left side", preposition="of", synonym="at left-hand side"),
        PredicateTerm(code=SpatialPredicate.rightside, predicate="at right side", preposition="of", synonym="at right-hand side"),
        PredicateTerm(code=SpatialPredicate.frontside, predicate="at front side", preposition="of", synonym="at forefront"),
        PredicateTerm(code=SpatialPredicate.backside, predicate="at back side", preposition="of", synonym="at rear side"),
        # orientations
        PredicateTerm(code=SpatialPredicate.aligned, predicate="aligned", preposition="with", synonym="parallel", reverse="aligned"),
        PredicateTerm(code=SpatialPredicate.orthogonal, predicate="orthogonal", preposition="to", synonym="perpendicular", reverse="orthogonal"),
        PredicateTerm(code=SpatialPredicate.opposite, predicate="opposite", preposition="", synonym="vis-a-vis", reverse="opposite"),
        # topology
        PredicateTerm(code=SpatialPredicate.inside, predicate="inside", preposition="", synonym="within", reverse="containing"),
        PredicateTerm(code=SpatialPredicate.containing, predicate="containing", preposition="", synonym="contains", reverse="inside"),
        PredicateTerm(code=SpatialPredicate.crossing, predicate="crossing", preposition=""),
        PredicateTerm(code=SpatialPredicate.overlapping, predicate="overlapping", preposition="", synonym="intersecting", reverse="overlapping", antonym="disjoint"),
        PredicateTerm(code=SpatialPredicate.disjoint, predicate="disjoint", preposition="to", reverse="disjoint", antonym="overlapping"),
        PredicateTerm(code=SpatialPredicate.touching, predicate="touching", preposition="with", reverse="touching"),
        PredicateTerm(code=SpatialPredicate.frontaligned, predicate="front aligned", preposition="with", reverse="front aligned"),
        PredicateTerm(code=SpatialPredicate.meeting, predicate="meeting", preposition="", reverse="meeting"),
        PredicateTerm(code=SpatialPredicate.beside, predicate="beside", preposition="", reverse="beside"),
        PredicateTerm(code=SpatialPredicate.fitting, predicate="fitting", preposition="into", reverse="exceeding"),
        PredicateTerm(code=SpatialPredicate.exceeding, predicate="exceeding", preposition="into", reverse="fitting"),
        # connectivity
        PredicateTerm(code=SpatialPredicate.on, predicate="on", preposition="", reverse="beneath"),
        PredicateTerm(code=SpatialPredicate.at, predicate="at", preposition="", reverse="meeting"),
        PredicateTerm(code=SpatialPredicate.by, predicate="by", preposition="", reverse="by"),
        PredicateTerm(code=SpatialPredicate.in_, predicate="in", preposition="", reverse="containing"),
        # similarity
        PredicateTerm(code=SpatialPredicate.samewidth, predicate="same width", preposition="as", synonym="similar width", reverse="same width", verb="has"),
        PredicateTerm(code=SpatialPredicate.sameheight, predicate="same height", preposition="as", synonym="similar height", reverse="same height", verb="has"),
        PredicateTerm(code=SpatialPredicate.samedepth, predicate="same depth", preposition="as", synonym="similar depth", reverse="same depth", verb="has"),
        PredicateTerm(code=SpatialPredicate.samelength, predicate="same length", preposition="as", synonym="similar length", reverse="same length", verb="has"),
        PredicateTerm(code=SpatialPredicate.samefootprint, predicate="same footprint", preposition="as", synonym="similar base area", reverse="same footprint", verb="has"),
        PredicateTerm(code=SpatialPredicate.samefront, predicate="same front face", preposition="as", synonym="similar front face", reverse="same front face", verb="has"),
        PredicateTerm(code=SpatialPredicate.sameside, predicate="same side face", preposition="as", synonym="similar side face", reverse="same side face", verb="has"),
        PredicateTerm(code=SpatialPredicate.samevolume, predicate="same volume", preposition="as", synonym="similar volume", reverse="same volume", verb="has"),
        PredicateTerm(code=SpatialPredicate.samecuboid, predicate="same cuboid", preposition="as", synonym="similar cuboid", reverse="same cuboid", verb="has"),
        PredicateTerm(code=SpatialPredicate.samecenter, predicate="same center", preposition="as", synonym="similar center", reverse="same center", verb="has"),
        PredicateTerm(code=SpatialPredicate.sameshape, predicate="same shape", preposition="as", synonym="similar shape", reverse="same shape", verb="has"),
        PredicateTerm(code=SpatialPredicate.congruent, predicate="congruent", preposition="as", reverse="congruent"),
        # comparisons
        PredicateTerm(code=SpatialPredicate.smaller, predicate="smaller", preposition="than", synonym="tinier", reverse="bigger"),
        PredicateTerm(code=SpatialPredicate.bigger, predicate="bigger", preposition="than", synonym="larger", reverse="smaller"),
        PredicateTerm(code=SpatialPredicate.shorter, predicate="shorter", preposition="than", reverse="longer"),
        PredicateTerm(code=SpatialPredicate.longer, predicate="longer", preposition="than", reverse="shorter"),
        PredicateTerm(code=SpatialPredicate.taller, predicate="taller", preposition="than", reverse="shorter"),
        PredicateTerm(code=SpatialPredicate.thinner, predicate="thinner", preposition="than", synonym="narrower", reverse="wider"),
        PredicateTerm(code=SpatialPredicate.wider, predicate="wider", preposition="than", synonym="thicker", reverse="thinner"),
    ]

    @staticmethod
    def predicate(name: str) -> SpatialPredicate:
        pred = SpatialPredicate.named(name)
        if pred != SpatialPredicate.undefined:
            return pred
        for term in SpatialTerms.list:
            if term.predicate == name:
                return term.code
            if term.synonym == name:
                return term.code
        return SpatialPredicate.undefined

    @staticmethod
    def term(code: SpatialPredicate) -> str:
        for term in SpatialTerms.list:
            if term.code == code:
                return term.predicate
        if code != SpatialPredicate.undefined:
            return code.value
        return "undefined"

    @staticmethod
    def termWithPreposition(code: SpatialPredicate) -> str:
        for term in SpatialTerms.list:
            if term.code == code:
                if term.preposition:
                    return f"{term.predicate} {term.preposition}"
                return term.predicate
        return "undefined"

    @staticmethod
    def termWithVerbAndPreposition(code: SpatialPredicate) -> str:
        for term in SpatialTerms.list:
            if term.code == code:
                if term.preposition:
                    return f"{term.verb} {term.predicate} {term.preposition}"
                return f"{term.verb} {term.predicate}"
        return "undefined"

    @staticmethod
    def symmetric(code: SpatialPredicate) -> bool:
        for term in SpatialTerms.list:
            if term.code == code:
                return term.predicate == term.reverse
        return False

    @staticmethod
    def inverse(predicate: str) -> SpatialPredicate:
        for term in SpatialTerms.list:
            if term.predicate == predicate and term.reverse:
                # Handle 'in' differently due to Python keyword
                if term.reverse == "in":
                    return SpatialPredicate.in_
                try:
                    return SpatialPredicate(term.reverse)
                except ValueError:
                    return SpatialPredicate.undefined
        return SpatialPredicate.undefined

    @staticmethod
    def negation(predicate: str) -> SpatialPredicate:
        for term in SpatialTerms.list:
            if term.predicate == predicate and term.antonym:
                try:
                    return SpatialPredicate(term.antonym)
                except ValueError:
                    return SpatialPredicate.undefined
        return SpatialPredicate.undefined


# Global lists combining SpatialPredicate enums
proximity: List[SpatialPredicate] = [SpatialPredicate.near, SpatialPredicate.far]
directionality: List[SpatialPredicate] = [SpatialPredicate.left, SpatialPredicate.right, SpatialPredicate.above, SpatialPredicate.below, SpatialPredicate.ahead, SpatialPredicate.behind]
adjacency: List[SpatialPredicate] = [
    SpatialPredicate.leftside, SpatialPredicate.rightside, SpatialPredicate.ontop, SpatialPredicate.beneath,
    SpatialPredicate.upperside, SpatialPredicate.lowerside, SpatialPredicate.frontside, SpatialPredicate.backside
]
orientations: List[SpatialPredicate] = [
    SpatialPredicate.orthogonal, SpatialPredicate.opposite, SpatialPredicate.aligned,
    SpatialPredicate.frontaligned, SpatialPredicate.backaligned, SpatialPredicate.rightaligned,
    SpatialPredicate.leftaligned
]
assembly: List[SpatialPredicate] = [
    SpatialPredicate.disjoint, SpatialPredicate.inside, SpatialPredicate.containing,
    SpatialPredicate.overlapping, SpatialPredicate.crossing, SpatialPredicate.touching,
    SpatialPredicate.meeting, SpatialPredicate.beside
]
topology: List[SpatialPredicate] = proximity + directionality + adjacency + orientations + assembly
contacts: List[SpatialPredicate] = [SpatialPredicate.on, SpatialPredicate.at, SpatialPredicate.by, SpatialPredicate.in_]
connectivity: List[SpatialPredicate] = contacts.copy()
comparability: List[SpatialPredicate] = [
    SpatialPredicate.smaller, SpatialPredicate.bigger, SpatialPredicate.shorter, SpatialPredicate.longer,
    SpatialPredicate.taller, SpatialPredicate.thinner, SpatialPredicate.wider, SpatialPredicate.fitting,
    SpatialPredicate.exceeding
]
similarity: List[SpatialPredicate] = [
    SpatialPredicate.sameheight, SpatialPredicate.samewidth, SpatialPredicate.samedepth,
    SpatialPredicate.samelength, SpatialPredicate.samefront, SpatialPredicate.sameside,
    SpatialPredicate.samefootprint, SpatialPredicate.samevolume, SpatialPredicate.samecenter,
    SpatialPredicate.samecuboid, SpatialPredicate.congruent, SpatialPredicate.sameshape
]
visibility: List[SpatialPredicate] = [
    SpatialPredicate.seenleft, SpatialPredicate.seenright, SpatialPredicate.infront,
    SpatialPredicate.atrear, SpatialPredicate.tangible, SpatialPredicate.eightoclock,
    SpatialPredicate.nineoclock, SpatialPredicate.tenoclock, SpatialPredicate.elevenoclock,
    SpatialPredicate.twelveoclock, SpatialPredicate.oneoclock, SpatialPredicate.twooclock,
    SpatialPredicate.threeoclock, SpatialPredicate.fouroclock
]
geography: List[SpatialPredicate] = [
    SpatialPredicate.north, SpatialPredicate.south, SpatialPredicate.east, SpatialPredicate.west,
    SpatialPredicate.northwest, SpatialPredicate.northeast, SpatialPredicate.southwest, SpatialPredicate.southeast
]
sectors: List[SpatialPredicate] = [
    SpatialPredicate.i, SpatialPredicate.a, SpatialPredicate.b, SpatialPredicate.o, SpatialPredicate.u,
    SpatialPredicate.l, SpatialPredicate.r, SpatialPredicate.al, SpatialPredicate.ar, SpatialPredicate.bl,
    SpatialPredicate.br, SpatialPredicate.ao, SpatialPredicate.au, SpatialPredicate.bo, SpatialPredicate.bu,
    SpatialPredicate.lo, SpatialPredicate.lu, SpatialPredicate.ro, SpatialPredicate.ru, SpatialPredicate.alo,
    SpatialPredicate.aro, SpatialPredicate.blo, SpatialPredicate.bro, SpatialPredicate.alu, SpatialPredicate.aru,
    SpatialPredicate.blu, SpatialPredicate.bru
]

--------------------------------------------------------------

==> src/SpatialReasoner.py <==
import datetime
from typing import List, Dict, Optional, Any
from pathlib import Path
import json

# Import the SpatialObject and dependencies
from src.vector3 import Vector3
from src.SpatialBasics import (
    NearbySchema,
    SectorSchema,
    SpatialAdjustment,
    SpatialPredicateCategories,
    ObjectConfidence,
    SpatialAtribute,
    SpatialExistence,
    ObjectCause,
    MotionState,
    ObjectShape,
    ObjectHandling,
    defaultAdjustment
)
from src.SpatialPredicate import (
    SpatialPredicate,
    PredicateTerm,
    SpatialTerms,
    proximity,
    directionality,
    adjacency,
    orientations,
    assembly,
    topology,
    contacts,
    connectivity,
    comparability,
    similarity,
    visibility,
    geography,
    sectors,
)
from .SpatialObject import SpatialObject
from .SpatialRelation import SpatialRelation
from .SpatialInference import SpatialInference


class SpatialReasoner:
    def __init__(self):
        # === Settings ===
        self.adjustment = SpatialAdjustment()
        self.deduce = SpatialPredicateCategories()
        self.north = Vector2(dx=0.0, dy=-1.0)  # North direction, e.g., defined by ARKit

        # === Data ===
        self.objects: List[SpatialObject] = []
        self.observer: Optional[SpatialObject] = None
        self.relMap: Dict[int, List[SpatialRelation]] = {}  # index: [SpatialRelation]
        self.chain: List[SpatialInference] = []
        self.base: Dict[str, Any] = {}  # Fact base for read/write access of expression evaluation
        self.snapTime: datetime.datetime = datetime.datetime.now()  # Load or update time of fact base

        # === Logging ===
        self.pipeline: str = ""  # Last used inference pipeline
        self.name: str = ""  # Used as title for log
        self.description: str = ""  # Used in log output
        self.logCnt: int = 0
        self.logFolder: Optional[Path] = None  # If None, Downloads folder will be used

    # === Loading Methods ===

    def load(self, objs: Optional[List[SpatialObject]] = None):
        """
        Load SpatialObjects into the reasoner.
        """
        if objs is not None:
            self.objects = objs
        self.observer = None
        self.relMap = {}
        self.base["objects"] = []

        if self.objects:
            objList = []
            for obj in self.objects:
                obj.context = self
                objList.append(obj.as_dict())
                if obj.observing:
                    self.observer = obj
            self.base["objects"] = objList

        self.snapTime = datetime.datetime.now()
        self.base["snaptime"] = self.snapTime.isoformat()

    def object_with_id(self, id: str) -> Optional[SpatialObject]:
        """
        Retrieve a SpatialObject by its ID.
        """
        for obj in self.objects:
            if obj.id == id:
                return obj
        return None

    def index_of_id(self, id: str) -> Optional[int]:
        """
        Retrieve the index of a SpatialObject by its ID.
        """
        for idx, obj in enumerate(self.objects):
            if obj.id == id:
                return idx
        return None

    def set_data(self, key: str, value: Any):
        """
        Set additional arbitrary data in the fact base.
        """
        dict_data = self.base.get("data", {})
        dict_data[key] = value
        self.base["data"] = dict_data

    def sync_to_objects(self):
        """
        Synchronize the fact base to SpatialObjects.
        """
        self.objects = []
        self.observer = None
        self.relMap = {}
        obj_dicts = self.base.get("objects", [])

        for obj_dict in obj_dicts:
            obj = SpatialObject(id=obj_dict["id"])
            obj.from_any(obj_dict)
            self.objects.append(obj)
            if obj.observing:
                self.observer = obj

    def load_from_dicts(self, objs: List[Dict[str, Any]]):
        """
        Load SpatialObjects from a list of dictionaries.
        """
        self.base["objects"] = objs
        self.sync_to_objects()
        self.base["snaptime"] = self.snapTime.isoformat()
        self.snapTime = datetime.datetime.now()

    def load_from_json(self, json_str: str):
        """
        Load SpatialObjects from a JSON string.
        """
        try:
            data = json.loads(json_str)
            if isinstance(data, list):
                self.load_from_dicts(data)
        except json.JSONDecodeError as e:
            print(f"JSON decode error: {e}")

    def take_snapshot(self) -> Dict[str, Any]:
        """
        Take a snapshot of the current fact base.
        """
        return self.base.copy()

    def load_snapshot(self, snapshot: Dict[str, Any]):
        """
        Load a snapshot into the fact base.
        """
        self.base = snapshot.copy()
        self.sync_to_objects()

    # === Recording and Backtracing ===

    def record(self, inference: SpatialInference):
        """
        Record a SpatialInference in the chain and fact base.
        """
        self.chain.append(inference)
        chain_list = self.base.get("chain", [])
        chain_list.append(inference.as_dict())
        self.base["chain"] = chain_list

    def backtrace(self) -> List[int]:
        """
        Backtrace to find the input indices of the last manipulating inference.
        """
        for inference in reversed(self.chain):
            if inference.is_manipulating():
                return inference.input
        return []

    # === Running the Inference Pipeline ===

    def run(self, pipeline: str) -> bool:
        """
        Run the spatial reasoning pipeline.
        """
        self.pipeline = pipeline
        self.logCnt = 0
        self.chain = []
        self.base["chain"] = []

        operations = [op.strip() for op in pipeline.split("|")]
        indices = list(range(len(self.objects)))

        for op in operations:
            if op.startswith("log(") and op.endswith(")"):
                content = op[4:-1].strip()
                self.log(content)
            elif op.startswith("adjust(") and op.endswith(")"):
                content = op[7:-1].strip()
                ok = self.adjust(content)
                if not ok:
                    self.log_error()
                    break
            elif op.startswith("deduce(") and op.endswith(")"):
                content = op[7:-1].strip()
                self.deduce_categories(content)
            else:
                input_chain = self.chain[-1].output if self.chain else indices
                inference = SpatialInference(input=input_chain, operation=op, reasoner=self)
                self.record(inference)
                if inference.has_failed():
                    self.log_error()
                    break

        self.sync_to_objects()

        if self.chain:
            return self.chain[-1].succeeded
        elif "log(" in pipeline:
            return True
        return False

    # === Retrieving Results ===

    def result(self) -> List[SpatialObject]:
        """
        Retrieve the resulting SpatialObjects after running the pipeline.
        """
        if self.chain:
            return [self.objects[idx] for idx in self.chain[-1].output]
        return []

    # === Logging Methods ===

    def log_error(self):
        """
        Log the last error from the inference chain.
        """
        if self.chain:
            print(self.chain[-1].error)

    @staticmethod
    def print_relations(relations: List[SpatialRelation]):
        """
        Print a list of SpatialRelations in a readable format.
        """
        for relation in relations:
            print(f"{relation.subject.id} {relation.predicate} {relation.object.id} | Δ:{relation.delta:.2f}  α:{relation.yaw:.1f}°")

    def relations_of(self, idx: int) -> List[SpatialRelation]:
        """
        Retrieve all SpatialRelations for the object at the given index.
        """
        if idx in self.relMap:
            return self.relMap[idx]
        relations = []
        for subject in self.objects:
            if subject != self.objects[idx]:
                relations.extend(self.objects[idx].relate(subject=subject))
        self.relMap[idx] = relations
        return relations

    def relations_with(self, obj_idx: int, predicate: str) -> List[SpatialRelation]:
        """
        Retrieve SpatialRelations with a specific predicate for the object at obj_idx.
        """
        rels = []
        if obj_idx >= 0:
            for relation in self.relations_of(obj_idx):
                if relation.predicate.value == predicate:
                    rels.append(relation)
        return rels

    def does(self, subject: SpatialObject, have: str, with_obj_idx: int) -> bool:
        """
        Check if the subject has a specific predicate relation with the object at with_obj_idx.
        """
        for relation in self.relations_of(with_obj_idx):
            if relation.subject == subject and relation.predicate.value == have:
                return True
        return False

    # === Adjustment and Deduction ===

    def adjust(self, settings: str) -> bool:
        """
        Adjust the reasoning engine's settings based on a settings string.
        """
        error = ""
        settings_list = [s.strip() for s in settings.split(";")]

        for setting in settings_list:
            parts = setting.split()
            first = parts[0] if len(parts) > 0 else ""
            second = parts[1] if len(parts) > 1 else ""
            number = parts[2] if len(parts) > 2 else ""

            if first == "max":
                if second == "gap":
                    if number:
                        try:
                            val = float(number)
                            self.adjustment.maxGap = val
                        except ValueError:
                            error = f"Invalid max gap value: {number}"
                elif second in ["angle", "delta"]:
                    if number:
                        try:
                            val = float(number)
                            self.adjustment.maxAngleDelta = val
                        except ValueError:
                            error = f"Invalid max angle value: {number}"
                else:
                    error = f"Unknown max setting: {second}"

            elif first == "sector":
                set_factor = True
                if second == "fixed":
                    self.adjustment.sectorSchema = "fixed"
                elif second == "dimension":
                    self.adjustment.sectorSchema = "dimension"
                elif second == "perimeter":
                    self.adjustment.sectorSchema = "perimeter"
                elif second == "area":
                    self.adjustment.sectorSchema = "area"
                elif second == "nearby":
                    self.adjustment.sectorSchema = "nearby"
                elif second == "factor":
                    set_factor = True
                elif second == "limit":
                    set_factor = False
                    if number:
                        try:
                            val = float(number)
                            self.adjustment.sectorLimit = val
                        except ValueError:
                            error = f"Invalid sector limit value: {number}"
                else:
                    error = f"Unknown sector setting: {second}"

                if set_factor and number:
                    try:
                        val = float(number)
                        self.adjustment.sectorLimit = val
                    except ValueError:
                        error = f"Invalid sector limit value: {number}"

            elif first == "nearby":
                set_factor = True
                if second == "fixed":
                    self.adjustment.nearbySchema = "fixed"
                elif second == "circle":
                    self.adjustment.nearbySchema = "circle"
                elif second == "sphere":
                    self.adjustment.nearbySchema = "sphere"
                elif second == "perimeter":
                    self.adjustment.nearbySchema = "perimeter"
                elif second == "area":
                    self.adjustment.nearbySchema = "area"
                elif second == "factor":
                    set_factor = True
                elif second == "limit":
                    set_factor = False
                    if number:
                        try:
                            val = float(number)
                            self.adjustment.nearbyLimit = val
                        except ValueError:
                            error = f"Invalid nearby limit value: {number}"
                else:
                    error = f"Unknown nearby setting: {second}"

                if set_factor and number:
                    try:
                        val = float(number)
                        self.adjustment.nearbyFactor = val
                    except ValueError:
                        error = f"Invalid nearby factor value: {number}"

            elif first == "long":
                if second == "ratio":
                    if number:
                        try:
                            val = float(number)
                            self.adjustment.longRatio = val
                        except ValueError:
                            error = f"Invalid long ratio value: {number}"

            elif first == "thin":
                if second == "ratio":
                    if number:
                        try:
                            val = float(number)
                            self.adjustment.thinRatio = val
                        except ValueError:
                            error = f"Invalid thin ratio value: {number}"

            else:
                error = f"Unknown adjust setting: {first}"

        if error:
            print(f"Error: {error}")
            error_state = SpatialInference(input=[], operation=f"adjust({settings})", reasoner=self)
            error_state.error = error
            return False
        return True

    def deduce_categories(self, categories: str):
        """
        Deduce which spatial predicate categories to enable based on input string.
        """
        self.deduce.topology = "topo" in categories
        self.deduce.connectivity = "connect" in categories
        self.deduce.comparability = "compar" in categories
        self.deduce.similarity = "simil" in categories
        self.deduce.sectoriality = "sector" in categories
        self.deduce.visibility = "visib" in categories
        self.deduce.geography = "geo" in categories

    # === Logging Implementation ===

    def log(self, predicates: str):
        """
        Log the specified predicates. Excludes visualization-related logging.
        """
        # Initialize log folder if not set
        if self.logFolder is None:
            try:
                self.logFolder = Path.home() / "Downloads"
                if not self.logFolder.exists():
                    self.logFolder = Path.home()
            except Exception as e:
                self.logFolder = Path.home()

        self.logCnt += 1
        all_indices = list(range(len(self.objects)))
        indices = self.chain[-1].output if self.chain else all_indices
        predicates_list = [p.strip() for p in predicates.split(" ")]

        if "base" in predicates_list:
            predicates_list.remove("base")
            self.log_base()
        if "3D" in predicates_list:
            predicates_list.remove("3D")
            # Visualization code for 3D logging is omitted as per instruction

        # Build Markdown content
        md = f"# {self.name if self.name else 'Spatial Reasoning Log'}\n"
        md += f"{self.description if self.description else ''}\n\n"
        md += "## Inference Pipeline\n\n```\n" + self.pipeline + "\n```\n\n"
        md += "## Inference Chain\n\n```\n"
        for idx, inference in enumerate(self.chain):
            if idx > 0:
                md += "| "
            md += f"{inference.operation}  ->  {inference.output}\n"
        md += "```\n\n"

        md += "## Spatial Objects\n\n### Fact Base\n\n"
        for i in all_indices:
            obj = self.objects[i]
            md += f"{i}.  __{obj.id}__: {obj.desc()}\n"

        md += "\n### Resulting Objects (Output)\n\n"
        mmd_objs = ""
        mmd_rels = ""
        mmd_contacts = ""
        rels = ""
        for i in indices:
            obj = self.objects[i]
            mmd_objs += f"    {obj.id}\n"
            md += f"{i}.  __{obj.id}__: {obj.desc()}\n"

            for relation in self.relations_of(i):
                do_add = False
                if predicates_list:
                    if relation.predicate.value in predicates_list:
                        do_add = True
                else:
                    do_add = True

                if do_add:
                    left_link = " -- "
                    if relation.predicate.is_symmetric():
                        left_link = " <-- "
                        search_by = f"{relation.object.id}{left_link}{relation.predicate.value} --> {relation.subject.id}"
                        if search_by in mmd_rels:
                            do_add = False
                    if do_add:
                        mmd_rels += f"    {relation.subject.id}{left_link}{relation.predicate.value} --> {relation.object.id}\n"

                if relation.predicate in SpatialPredicateCategories.contacts:
                    do_add_contact = True
                    left_link = " -- "
                    if relation.predicate == SpatialPredicate.by:
                        left_link = " <-- "
                        search_by = f"{relation.object.id}{left_link}{relation.predicate.value} --> {relation.subject.id}"
                        if search_by in mmd_contacts:
                            do_add_contact = False
                    if do_add_contact:
                        mmd_contacts += f"    {relation.subject.id}{left_link}{relation.predicate.value} --> {relation.object.id}\n"

                if relation.predicate in SpatialPredicateCategories.contacts:
                    rels += f"* {relation.desc()}\n"

        # Append Spatial Relations Graph
        if mmd_rels:
            md += "\n## Spatial Relations Graph\n\n```mermaid\ngraph LR;\n" + mmd_objs + mmd_rels + "```\n"

        # Append Connectivity Graph
        if mmd_contacts:
            md += "\n## Connectivity Graph\n\n```mermaid\ngraph TD;\n" + mmd_contacts + "```\n"

        # Append Spatial Relations List
        md += "\n## Spatial Relations\n\n" + rels + "\n"

        # Determine log file name
        multiple_logs = pipeline.count("log(") > 2
        counter_str = str(self.logCnt) if multiple_logs else ""
        log_filename = f"log{counter_str}.md"
        log_path = self.logFolder / log_filename

        # Write Markdown to file
        try:
            with open(log_path, "w", encoding="utf-16") as f:
                f.write(md)
        except Exception as e:
            print(f"Error writing log file: {e}")

    def log_base(self):
        """
        Log the fact base to a JSON file.
        """
        try:
            log_base_path = self.logFolder / "logBase.json"
            with open(log_base_path, "w", encoding="utf-8") as f:
                json.dump(self.base, f, indent=4)
        except Exception as e:
            print(f"Error writing log base: {e}")

    # === Visualization Methods ===
    # All visualization-related methods (e.g., log3D) are omitted as per instruction.

    # === Additional Methods ===

    @staticmethod
    def print_relations(relations: List[SpatialRelation]):
        """
        Print a list of SpatialRelations in a readable format.
        """
        for relation in relations:
            print(f"{relation.subject.id} {relation.predicate} {relation.object.id} | Δ:{relation.delta:.2f}  α:{relation.yaw:.1f}°")
--------------------------------------------------------------

==> src/SpatialRelation.py <==
# SpatialRelation.py

from typing import Any
from typing import TYPE_CHECKING
import math

if TYPE_CHECKING:
    from .SpatialObject import SpatialObject  # Prevents circular import at runtime

from .SpatialPredicate import SpatialPredicate, SpatialTerms


class SpatialRelation:
    """
    Represents a spatial relation as a triple: subject - predicate - object.
    """

    def __init__(
        self,
        subject: 'SpatialObject',
        predicate: SpatialPredicate,
        object: 'SpatialObject',
        delta: float = 0.0,
        angle: float = 0.0
    ):
        """
        Initializes a SpatialRelation instance.

        Args:
            subject (SpatialObject): The target subject.
            predicate (SpatialPredicate): The spatial predicate matching spatial condition and max deviation.
            object (SpatialObject): The reference object.
            delta (float, optional): Difference of predicate value between subject and object, e.g., distance. Defaults to 0.0.
            angle (float, optional): Angle deviation of object direction in radians. Defaults to 0.0.
        """
        self.subject: 'SpatialObject' = subject
        self.predicate: SpatialPredicate = predicate
        self.object: 'SpatialObject' = object
        self.delta: float = delta
        self.angle: float = angle

    @property
    def yaw(self) -> float:
        """
        Calculates the angle deviation in degrees.

        Returns:
            float: Angle deviation in degrees.
        """
        return self.angle * 180.0 / math.pi

    @property
    def subject_id(self) -> str:
        """
        Retrieves the ID of the subject.

        Returns:
            str: The subject's ID.
        """
        return self.subject.id

    @property
    def object_id(self) -> str:
        """
        Retrieves the ID of the object.

        Returns:
            str: The object's ID.
        """
        return self.object.id

    def desc(self) -> str:
        """
        Generates a descriptive string for the spatial relation.

        The format is:
        "<subject> <predicate> <object> (<predicate_raw_value> Δ:<delta> 𝜶:<yaw>°)"

        Returns:
            str: The descriptive string of the spatial relation.
        """
        # Determine subject representation
        if self.subject.label:
            subject_str = self.subject.label
        elif self.subject.type:
            subject_str = self.subject.type
        else:
            subject_str = self.subject.id

        # Get predicate as verb + preposition using SpatialTerms
        predicate_str = SpatialTerms.term_with_verb_and_preposition(self.predicate)

        # Determine object representation
        if self.object.label:
            object_str = self.object.label
        elif self.object.type:
            object_str = self.object.type
        else:
            object_str = self.object.id

        # Format the description string
        description = (
            f"{subject_str} {predicate_str} {object_str} "
            f"({self.predicate.value} Δ:{self.delta:.2f} 𝜶:{self.yaw:.1f}°)"
        )
        return description

    def __repr__(self) -> str:
        """
        Returns the official string representation of the SpatialRelation.

        Returns:
            str: Official string representation.
        """
        return (
            f"SpatialRelation(subject={self.subject}, "
            f"predicate={self.predicate}, object={self.object}, "
            f"delta={self.delta}, angle={self.angle})"
        )
--------------------------------------------------------------

==> src/Vector2.py <==
import numpy as np
from typing import List, Optional

class Vector2:
    def __init__(self, x: float = 0.0, y: float = 0.0):
        """
        Initialize a 2D vector.
        
        Args:
            x (float): The x-component of the vector. Defaults to 0.0.
            y (float): The y-component of the vector. Defaults to 0.0.
        """
        self.array = np.array([x, y], dtype=float)
        self.dx = x
        self.dy = y
    
    @property
    def x(self) -> float:
        """Get the x-component of the vector."""
        return self.array[0]
    
    @property
    def y(self) -> float:
        """Get the y-component of the vector."""
        return self.array[1]
    
    def __add__(self, other: 'Vector2') -> 'Vector2':
        """
        Add two vectors.
        
        Args:
            other (Vector2): The vector to add.
        
        Returns:
            Vector2: The resulting vector.
        """
        if not isinstance(other, Vector2):
            raise TypeError("Addition is supported between Vector2 instances only.")
        return Vector2(*(self.array + other.array))
    
    def __sub__(self, other: 'Vector2') -> 'Vector2':
        """
        Subtract one vector from another.
        
        Args:
            other (Vector2): The vector to subtract.
        
        Returns:
            Vector2: The resulting vector.
        """
        if not isinstance(other, Vector2):
            raise TypeError("Subtraction is supported between Vector2 instances only.")
        return Vector2(*(self.array - other.array))
    
    def dot(self, other: 'Vector2') -> float:
        """
        Compute the dot product of two vectors.
        
        Args:
            other (Vector2): The other vector.
        
        Returns:
            float: The dot product.
        """
        if not isinstance(other, Vector2):
            raise TypeError("Dot product is supported between Vector2 instances only.")
        return np.dot(self.array, other.array)
    
    def magnitude(self) -> float:
        """
        Compute the magnitude (length) of the vector.
        
        Returns:
            float: The magnitude.
        """
        return np.linalg.norm(self.array)
    
    def length(self) -> float:
        """
        Alias for magnitude.
        
        Returns:
            float: The magnitude.
        """
        return self.magnitude()
    
    def normalize(self) -> 'Vector2':
        """
        Normalize the vector (make it unit length).
        
        Returns:
            Vector2: The normalized vector.
        """
        norm = self.magnitude()
        if norm == 0:
            return Vector2()
        return Vector2(*(self.array / norm))
    
    def rotate(self, radians: float) -> 'Vector2':
        """
        Rotate the vector by a given angle in radians.
        
        Args:
            radians (float): The angle to rotate the vector.
        
        Returns:
            Vector2: The rotated vector.
        """
        rotation_matrix = np.array([
            [np.cos(radians), -np.sin(radians)],
            [np.sin(radians),  np.cos(radians)]
        ])
        rotated = rotation_matrix.dot(self.array)
        return Vector2(*rotated)
    
    def distance_to(self, other: 'Vector2') -> float:
        """
        Compute the distance to another vector.
        
        Args:
            other (Vector2): The other vector.
        
        Returns:
            float: The distance.
        """
        if not isinstance(other, Vector2):
            raise TypeError("Distance can only be computed between Vector2 instances.")
        return np.linalg.norm(self.array - other.array)
    
    def nearest(self, points: List['Vector2']) -> List['Vector2']:
        """
        Find the nearest point(s) to this vector from a list of points.
        
        Args:
            points (List[Vector2]): The list of points to search.
        
        Returns:
            List[Vector2]: A list of the nearest point(s).
        """
        if not points:
            return []
        distances = [self.distance_to(p) for p in points]
        min_distance = min(distances)
        nearest_points = [p for p, d in zip(points, distances) if np.isclose(d, min_distance)]
        return nearest_points
    
    def __eq__(self, other: Any) -> bool:
        """
        Check if two vectors are equal within a tolerance.
        
        Args:
            other (Any): The object to compare.
        
        Returns:
            bool: True if vectors are equal, False otherwise.
        """
        if not isinstance(other, Vector2):
            return False
        return np.allclose(self.array, other.array, atol=1e-8)
    
    def __repr__(self) -> str:
        """
        Return the string representation of the vector.
        
        Returns:
            str: The string representation.
        """
        return f"Vector2(x={self.x}, y={self.y})"

--------------------------------------------------------------

==> src/__init__.py <==
from .BBoxSector import BBoxSector, BBoxSectorFlags

from .SpatialBasics import (
    NearbySchema,
    SectorSchema,
    SpatialAdjustment,
    SpatialPredicateCategories,
    ObjectConfidence,
    SpatialAtribute,
    SpatialExistence,
    ObjectCause,
    MotionState,
    ObjectShape,
    ObjectHandling
)

from .SpatialPredicate import (
    SpatialPredicate,
    PredicateTerm,
    SpatialTerms,
    proximity,
    directionality,
    adjacency,
    orientations,
    assembly,
    topology,
    contacts,
    connectivity,
    comparability,
    similarity,
    visibility,
    geography,
    sectors
)

from .SpatialObject import ( SpatialObject )
from .SpatialRelation import SpatialRelation 
--------------------------------------------------------------

==> src/__pycache__/BBoxSector.cpython-312.pyc <==
==> src/__pycache__/SpatialBasics.cpython-312.pyc <==
==> src/__pycache__/SpatialInference.cpython-312.pyc <==
==> src/__pycache__/SpatialObject.cpython-312.pyc <==
==> src/__pycache__/SpatialPredicate.cpython-312.pyc <==
==> src/__pycache__/SpatialReasoner.cpython-312.pyc <==
==> src/__pycache__/SpatialRelation.cpython-312.pyc <==
==> src/__pycache__/__init__.cpython-312.pyc <==
==> src/__pycache__/vector3.cpython-312.pyc <==
==> src/vector3.py <==
# src/vector3.py
import numpy as np

class Vector3:
    def __init__(self, x=0.0, y=0.0, z=0.0):
        self.array = np.array([x, y, z], dtype=float)
    
    @property
    def x(self):
        return self.array[0]
    
    @property
    def y(self):
        return self.array[1]
    
    @property
    def z(self):
        return self.array[2]
    
    def __add__(self, other):
        return Vector3(*(self.array + other.array))
    
    def __sub__(self, other):
        #if other is not Vector3 but number
        if not isinstance(other, Vector3):
            return Vector3(*(self.array - other))
        return Vector3(*(self.array - other.array))
    def __truediv__(self, other):
        return Vector3(*(self.array / other))

    
    def dot(self, other):
        return np.dot(self.array, other.array)
    
    def cross(self, other):
        return Vector3(*np.cross(self.array, other.array))
    
    def magnitude(self):
        return np.linalg.norm(self.array)
    
    def length(self):
        return self.magnitude()
    
    def normalize(self):
        norm = self.magnitude()
        if norm == 0:
            return Vector3()
        return Vector3(*(self.array / norm))
    
    def rotate(self, radians):
        rotation_matrix = np.array([
            [np.cos(radians), 0, np.sin(radians)],
            [0, 1, 0],
            [-np.sin(radians), 0, np.cos(radians)]
        ])
        rotated = rotation_matrix.dot(self.array)
        return Vector3(*rotated)
    
    def __eq__(self, other):
        if not isinstance(other, Vector3):
            return False
        return np.allclose(self.array, other.array, atol=1e-8)
    
    def __repr__(self):
        return f"Vector3(x={self.x}, y={self.y}, z={self.z})"

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/COMMIT_EDITMSG <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/FETCH_HEAD <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/HEAD <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/config <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/description <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/hooks/applypatch-msg.sample <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/hooks/commit-msg.sample <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/hooks/fsmonitor-watchman.sample <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/hooks/post-update.sample <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/hooks/pre-applypatch.sample <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/hooks/pre-commit.sample <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/hooks/pre-merge-commit.sample <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/hooks/pre-push.sample <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/hooks/pre-rebase.sample <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/hooks/pre-receive.sample <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/hooks/prepare-commit-msg.sample <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/hooks/push-to-checkout.sample <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/hooks/update.sample <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/index <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/info/exclude <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/logs/HEAD <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/logs/refs/heads/main <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/logs/refs/remotes/origin/HEAD <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/logs/refs/remotes/origin/main <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/01/09166f41d0f580e55775fe2ba5bbf26ec3cd31 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/01/7e61f25fcda7bac2e403d5b0424fbbf203c94b <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/04/db3e0c72b25b7e77ed01fabe03d42a9ff6ffc7 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/04/fe1fe1332b64e975bdfd7418f411b490b2d646 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/06/c6f92b4f83b3233c2bd80fa4c09c8baeac05b7 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/09/73dc26f057a0b7b86a82dd4070ee0f2d8cbca1 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/0c/4d307009cf260f24ded92f108b165425851d57 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/2f/e15049ba75df003de45bf30d2e50eebe38b022 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/31/d36c7b74c14b6c71446cf4aa07382549ae4ef7 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/39/4429f284c5f7a516b6bef68638e8e9e832cc33 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/3b/314e1a99e075c58d2c5ce1d13d7723011f4809 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/4e/40dc7b50fe4c2eb6e39b0ec85613b93b5c21c2 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/61/4ec8cd25d4fbd144210423a7188146031091ed <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/66/19c7767bf7ea4422526df20bf02bf8c395d2cf <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/73/ad15fc09304f5af12d82f64f3d38237c825fa0 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/76/53aa623d87986263013f3d35e20202a6f19fc1 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/7b/4c4e91cfa5ca21cbc2c69fe2c90e11d0650c73 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/7b/9ed1282622ffe06c0b203974b5c9c790fe31b8 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/7c/bfc7f9c136c0d1c55200af0ea061954fda3c74 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/82/f0d2bc019fc729e7b2cb13468621def58ecd78 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/84/f32af1e76022db2a0e675ec526ce1fd55ee45f <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/8c/afb82a1ec510f59c5106ed82fefc5766b3c46a <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/8c/ecf3a9fa8e66f1810821286bbddb32e0711d0e <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/92/4baa36d8a08693b7d403b1aa92ce6193628e13 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/93/4f0dbde23e27523adfe9de0bac7219209aa47a <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/a1/39f629a8ec45c3d5627e1476fd745acdd8bf5b <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/a2/d1b51f7aeffd414b512e2899271abade29e5f8 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/aa/da3386c667a21b5f28dc45d805009624ed254c <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/ac/21eea1e91a472d794a63f159cc9cf0a72743de <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/b1/556559d6f9d93aa121f7c206b3c575ce205fb6 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/b5/a1c2f513e25fc378dfb3a06da6b6d23c9c7f5d <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/c8/7653f91ed8c505919932391c1de935f68107ba <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/c9/5dc7c04548a4c2820fa0b1df4bc71a979a5531 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/cb/9d178475c98b8b47e4d88072979b739df8917c <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/cc/31372aee1af140a703add77d66ef63afa7efbb <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/d2/94bb52fc800724097beb52d5dcc064c1552939 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/d3/7d8a9422578f73be2c5ad62ad85148d36da0d6 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/d5/6f37fc22cbfe2bdd5fafa367cb20937d827c92 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/d7/9030621663392cb9c0b74f53463f45b8e2303f <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/e1/4cdceacf8ae6c671ee9f618e380d14312f20ce <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/e2/75c3712f717e8fd1b49ad6151d919d7070df88 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/ec/ea99084d393baebd02cb588370ae938faf2bb1 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/f6/1845db08e98f7c88935a7e7390c1147deecb84 <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/f6/751f06f3f3463c53f5dcbd3b938ed19d5788dc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/pack/pack-09d9562c0d355ff9cb2f962b7ad4db1c1966daf9.idx <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/objects/pack/pack-09d9562c0d355ff9cb2f962b7ad4db1c1966daf9.pack <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/packed-refs <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/refs/heads/main <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/refs/remotes/origin/HEAD <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.git/refs/remotes/origin/main <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.gitignore <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.nosync <==

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/.txt <==
.
├── .gitignore
├── .nosync
├── .txt
├── LICENSE
├── README.md
├── all_files_output.txt
├── src
│   ├── BBoxSector.py
│   ├── SpatialBasics.py
│   ├── SpatialInference.py
│   ├── SpatialObject.py
│   ├── SpatialPredicate.py
│   ├── SpatialReasoner.py
│   ├── SpatialRelation.py
│   ├── Vector2.py
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── BBoxSector.cpython-312.pyc
│   │   ├── SpatialBasics.cpython-312.pyc
│   │   ├── SpatialInference.cpython-312.pyc
│   │   ├── SpatialObject.cpython-312.pyc
│   │   ├── SpatialPredicate.cpython-312.pyc
│   │   ├── SpatialReasoner.cpython-312.pyc
│   │   ├── SpatialRelation.cpython-312.pyc
│   │   ├── __init__.cpython-312.pyc
│   │   └── vector3.cpython-312.pyc
│   └── vector3.py
├── tests
│   ├── BBoxSector_test.py
│   ├── Sector_test.py
│   ├── SpatialBasics_test.py
│   ├── SpatialObject_test.py
│   ├── SpatialPredicate_test.py
│   ├── SpatialRelation_test.py
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── BBoxSector_test.cpython-312.pyc
│   │   ├── Sector_test.cpython-312.pyc
│   │   ├── SpatialBasics_test.cpython-312.pyc
│   │   ├── SpatialObject_test.cpython-312.pyc
│   │   ├── SpatialPredicate_test.cpython-312.pyc
│   │   ├── SpatialRelation_test.cpython-312.pyc
│   │   └── __init__.cpython-312.pyc
│   └── test.py
└── to_text.sh

5 directories, 41 files

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/LICENSE <==
Creative Commons Legal Code

CC0 1.0 Universal

    CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
    LEGAL SERVICES. DISTRIBUTION OF THIS DOCUMENT DOES NOT CREATE AN
    ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
    INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
    REGARDING THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS
    PROVIDED HEREUNDER, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM
    THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS PROVIDED
    HEREUNDER.

Statement of Purpose

The laws of most jurisdictions throughout the world automatically confer
exclusive Copyright and Related Rights (defined below) upon the creator
and subsequent owner(s) (each and all, an "owner") of an original work of
authorship and/or a database (each, a "Work").

Certain owners wish to permanently relinquish those rights to a Work for
the purpose of contributing to a commons of creative, cultural and
scientific works ("Commons") that the public can reliably and without fear
of later claims of infringement build upon, modify, incorporate in other
works, reuse and redistribute as freely as possible in any form whatsoever
and for any purposes, including without limitation commercial purposes.
These owners may contribute to the Commons to promote the ideal of a free
culture and the further production of creative, cultural and scientific
works, or to gain reputation or greater distribution for their Work in
part through the use and efforts of others.

For these and/or other purposes and motivations, and without any
expectation of additional consideration or compensation, the person
associating CC0 with a Work (the "Affirmer"), to the extent that he or she
is an owner of Copyright and Related Rights in the Work, voluntarily
elects to apply CC0 to the Work and publicly distribute the Work under its
terms, with knowledge of his or her Copyright and Related Rights in the
Work and the meaning and intended legal effect of CC0 on those rights.

1. Copyright and Related Rights. A Work made available under CC0 may be
protected by copyright and related or neighboring rights ("Copyright and
Related Rights"). Copyright and Related Rights include, but are not
limited to, the following:

  i. the right to reproduce, adapt, distribute, perform, display,
     communicate, and translate a Work;
 ii. moral rights retained by the original author(s) and/or performer(s);
iii. publicity and privacy rights pertaining to a person's image or
     likeness depicted in a Work;
 iv. rights protecting against unfair competition in regards to a Work,
     subject to the limitations in paragraph 4(a), below;
  v. rights protecting the extraction, dissemination, use and reuse of data
     in a Work;
 vi. database rights (such as those arising under Directive 96/9/EC of the
     European Parliament and of the Council of 11 March 1996 on the legal
     protection of databases, and under any national implementation
     thereof, including any amended or successor version of such
     directive); and
vii. other similar, equivalent or corresponding rights throughout the
     world based on applicable law or treaty, and any national
     implementations thereof.

2. Waiver. To the greatest extent permitted by, but not in contravention
of, applicable law, Affirmer hereby overtly, fully, permanently,
irrevocably and unconditionally waives, abandons, and surrenders all of
Affirmer's Copyright and Related Rights and associated claims and causes
of action, whether now known or unknown (including existing as well as
future claims and causes of action), in the Work (i) in all territories
worldwide, (ii) for the maximum duration provided by applicable law or
treaty (including future time extensions), (iii) in any current or future
medium and for any number of copies, and (iv) for any purpose whatsoever,
including without limitation commercial, advertising or promotional
purposes (the "Waiver"). Affirmer makes the Waiver for the benefit of each
member of the public at large and to the detriment of Affirmer's heirs and
successors, fully intending that such Waiver shall not be subject to
revocation, rescission, cancellation, termination, or any other legal or
equitable action to disrupt the quiet enjoyment of the Work by the public
as contemplated by Affirmer's express Statement of Purpose.

3. Public License Fallback. Should any part of the Waiver for any reason
be judged legally invalid or ineffective under applicable law, then the
Waiver shall be preserved to the maximum extent permitted taking into
account Affirmer's express Statement of Purpose. In addition, to the
extent the Waiver is so judged Affirmer hereby grants to each affected
person a royalty-free, non transferable, non sublicensable, non exclusive,
irrevocable and unconditional license to exercise Affirmer's Copyright and
Related Rights in the Work (i) in all territories worldwide, (ii) for the
maximum duration provided by applicable law or treaty (including future
time extensions), (iii) in any current or future medium and for any number
of copies, and (iv) for any purpose whatsoever, including without
limitation commercial, advertising or promotional purposes (the
"License"). The License shall be deemed effective as of the date CC0 was
applied by Affirmer to the Work. Should any part of the License for any
reason be judged legally invalid or ineffective under applicable law, such
partial invalidity or ineffectiveness shall not invalidate the remainder
of the License, and in such case Affirmer hereby affirms that he or she
will not (i) exercise any of his or her remaining Copyright and Related
Rights in the Work or (ii) assert any associated claims and causes of
action with respect to the Work, in either case contrary to Affirmer's
express Statement of Purpose.

4. Limitations and Disclaimers.

 a. No trademark or patent rights held by Affirmer are waived, abandoned,
    surrendered, licensed or otherwise affected by this document.
 b. Affirmer offers the Work as-is and makes no representations or
    warranties of any kind concerning the Work, express, implied,
    statutory or otherwise, including without limitation warranties of
    title, merchantability, fitness for a particular purpose, non
    infringement, or the absence of latent or other defects, accuracy, or
    the present or absence of errors, whether or not discoverable, all to
    the greatest extent permissible under applicable law.
 c. Affirmer disclaims responsibility for clearing rights of other persons
    that may apply to the Work or any use thereof, including without
    limitation any person's Copyright and Related Rights in the Work.
    Further, Affirmer disclaims responsibility for obtaining any necessary
    consents, permissions or other rights required for any use of the
    Work.
 d. Affirmer understands and acknowledges that Creative Commons is not a
    party to this document and has no duty or obligation with respect to
    this CC0 or use of the Work.

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/README.md <==
# SRpy: Spatial Reasoner in Python

> _A flexible 3D Spatial Reasoning library in Python_

## Getting Started

### Documentation

See [__Docu on SpatialReasoner__](https://github.com/metason/SpatialReasoner) in separate repository.

### Building and Integrating

Package manager

## Tests

Tests and Visualizations

## License

See [LICENSE](LICENSE) file.


--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/all_files_output.txt <==
Failed to display file: /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/all_files_output.txt

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/BBoxSector.py <==
# src/BBoxSector.py

from enum import IntFlag
from typing import Any
from src.SpatialPredicate import SpatialPredicate


class BBoxSectorFlags(IntFlag):
    none = 0  # no sector specified
    i = 1 << 0  # i : inside, inner
    a = 1 << 1  # a : ahead
    b = 1 << 2  # b : behind
    l = 1 << 3  # l : left
    r = 1 << 4  # r : right
    o = 1 << 5  # o : over
    u = 1 << 6  # u : under

    # Composite sectors
    al = a | l
    ar = a | r
    bl = b | l
    br = b | r
    ao = a | o
    au = a | u
    bo = b | o
    bu = b | u
    lo = l | o
    lu = l | u
    ro = r | o
    ru = r | u
    alo = a | l | o
    aro = a | r | o
    blo = b | l | o
    bro = b | r | o
    alu = a | l | u
    aru = a | r | u
    blu = b | l | u
    bru = b | r | u


class BBoxSector:
    """
    A mutable class that represents spatial sectors using bitmask flags.
    Mimics Swift's OptionSet behavior.
    """

    # Predefined descriptions for composite and individual sectors
    debug_descriptions = {
        BBoxSectorFlags.i: "i",
        BBoxSectorFlags.a: "a",
        BBoxSectorFlags.b: "b",
        BBoxSectorFlags.l: "l",
        BBoxSectorFlags.r: "r",
        BBoxSectorFlags.o: "o",
        BBoxSectorFlags.u: "u",
        BBoxSectorFlags.al: "al",
        BBoxSectorFlags.ar: "ar",
        BBoxSectorFlags.bl: "bl",
        BBoxSectorFlags.br: "br",
        BBoxSectorFlags.ao: "ao",
        BBoxSectorFlags.au: "au",
        BBoxSectorFlags.bo: "bo",
        BBoxSectorFlags.bu: "bu",
        BBoxSectorFlags.lo: "lo",
        BBoxSectorFlags.lu: "lu",
        BBoxSectorFlags.ro: "ro",
        BBoxSectorFlags.ru: "ru",
        BBoxSectorFlags.alo: "alo",
        BBoxSectorFlags.aro: "aro",
        BBoxSectorFlags.blo: "blo",
        BBoxSectorFlags.bro: "bro",
        BBoxSectorFlags.alu: "alu",
        BBoxSectorFlags.aru: "aru",
        BBoxSectorFlags.blu: "blu",
        BBoxSectorFlags.bru: "bru",
    }

    # Define base flags (individual flags only)
    base_flags = {
        BBoxSectorFlags.i,
        BBoxSectorFlags.a,
        BBoxSectorFlags.b,
        BBoxSectorFlags.l,
        BBoxSectorFlags.r,
        BBoxSectorFlags.o,
        BBoxSectorFlags.u
    }

    def __init__(self, flags=BBoxSectorFlags.none):
        """
        Initialize a BBoxSector instance.

        Args:
            flags (BBoxSectorFlags, optional): Initial sector flags. Defaults to BBoxSectorFlags.none.
        """
        self.flags = flags

    def insert(self, flag: BBoxSectorFlags):
        """
        Insert a sector flag.

        Args:
            flag (BBoxSectorFlags): The flag to insert.
        """
        self.flags |= flag

    def remove(self, flag: BBoxSectorFlags):
        """
        Remove a sector flag.

        Args:
            flag (BBoxSectorFlags): The flag to remove.
        """
        self.flags &= ~flag

    def contains_flag(self, flag: BBoxSectorFlags) -> bool:
        """
        Check if a sector flag is present.

        Args:
            flag (BBoxSectorFlags): The flag to check.

        Returns:
            bool: True if the flag is present, False otherwise.
        """
        return (self.flags & flag) == flag

    def contains(self, flag: BBoxSectorFlags) -> bool:
        """
        Alias for contains_flag to maintain backward compatibility.

        Args:
            flag (BBoxSectorFlags): The flag to check.

        Returns:
            bool: True if the flag is present, False otherwise.
        """
        return self.contains_flag(flag)

    def divergencies(self) -> int:
        """
        Calculate the amount of divergency from the inner zone in all 3 directions.

        Returns:
            int: 0 if the sector includes 'i' (inside), otherwise the number of set bits.
        """
        if self.contains_flag(BBoxSectorFlags.i):
            return 0
        return bin(self.flags.value).count('1')

    def list_base_flags(self):
        """
        List only the base flags present in the sector.
        """
        return [name for name, member in BBoxSectorFlags.__members__.items()
                if member in self.flags and name != 'none' and member in BBoxSector.base_flags]

    def __str__(self) -> str:
        """
        Provide a string representation for the sector.

        Returns:
            str: The descriptive string of the sector.
        """
        # Always list base flags to match test expectations
        flags = self.list_base_flags()
        if flags:
            return ''.join(flags)
        elif self.flags == BBoxSectorFlags.none:
            return "no sector"
        else:
            # If no base flags are set, but some composite flags are, list them
            # This can happen if only composite flags are set without their base flags
            composite_flags = [name for name, member in BBoxSectorFlags.__members__.items()
                               if member in self.flags and name != 'none' and member not in BBoxSector.base_flags]
            if composite_flags:
                return ''.join(composite_flags)
            return "no sector"

    def __eq__(self, other: Any) -> bool:
        """
        Check equality with another BBoxSector instance.

        Args:
            other (Any): The object to compare.

        Returns:
            bool: True if equal, False otherwise.
        """
        if isinstance(other, BBoxSector):
            return self.flags == other.flags
        return False

    def __repr__(self) -> str:
        """
        Return the official string representation of the sector.

        Returns:
            str: The string representation.
        """
        return f"BBoxSector(flags={self.flags})"

    def __or__(self, other: Any) -> 'BBoxSector':
        """
        Define the behavior of the | operator.

        Args:
            other (BBoxSector or BBoxSectorFlags): The other sector or flag to combine.

        Returns:
            BBoxSector: A new BBoxSector instance with combined flags.
        """
        if isinstance(other, BBoxSector):
            return BBoxSector(self.flags | other.flags)
        elif isinstance(other, BBoxSectorFlags):
            return BBoxSector(self.flags | other)
        else:
            return NotImplemented

    def __ior__(self, other: Any) -> 'BBoxSector':
        """
        Define the behavior of the |= operator.

        Args:
            other (BBoxSector or BBoxSectorFlags): The other sector or flag to combine.

        Returns:
            BBoxSector: The updated BBoxSector instance.
        """
        if isinstance(other, BBoxSector):
            self.flags |= other.flags
            return self
        elif isinstance(other, BBoxSectorFlags):
            self.flags |= other
            return self
        else:
            return NotImplemented

    def __contains__(self, item: Any) -> bool:
        """
        Enable the 'in' operator to check for SpatialPredicate or BBoxSectorFlags.

        Args:
            item (Any): SpatialPredicate or BBoxSectorFlags to check.

        Returns:
            bool: True if the item is present, False otherwise.
        """
        if isinstance(item, SpatialPredicate):
            # Map SpatialPredicate to BBoxSectorFlags
            flag_map = {
                SpatialPredicate.l: BBoxSectorFlags.l,
                SpatialPredicate.r: BBoxSectorFlags.r,
                SpatialPredicate.a: BBoxSectorFlags.a,
                SpatialPredicate.b: BBoxSectorFlags.b,
                SpatialPredicate.o: BBoxSectorFlags.o,
                SpatialPredicate.u: BBoxSectorFlags.u,
                SpatialPredicate.i: BBoxSectorFlags.i,
                SpatialPredicate.al: BBoxSectorFlags.al,
                SpatialPredicate.ar: BBoxSectorFlags.ar,
                SpatialPredicate.bl: BBoxSectorFlags.bl,
                SpatialPredicate.br: BBoxSectorFlags.br,
                SpatialPredicate.ao: BBoxSectorFlags.ao,
                SpatialPredicate.au: BBoxSectorFlags.au,
                SpatialPredicate.bo: BBoxSectorFlags.bo,
                SpatialPredicate.bu: BBoxSectorFlags.bu,
                SpatialPredicate.lo: BBoxSectorFlags.lo,
                SpatialPredicate.lu: BBoxSectorFlags.lu,
                SpatialPredicate.ro: BBoxSectorFlags.ro,
                SpatialPredicate.ru: BBoxSectorFlags.ru,
                SpatialPredicate.alo: BBoxSectorFlags.alo,
                SpatialPredicate.aro: BBoxSectorFlags.aro,
                SpatialPredicate.blo: BBoxSectorFlags.blo,
                SpatialPredicate.bro: BBoxSectorFlags.bro,
                SpatialPredicate.alu: BBoxSectorFlags.alu,
                SpatialPredicate.aru: BBoxSectorFlags.aru,
                SpatialPredicate.blu: BBoxSectorFlags.blu,
                SpatialPredicate.bru: BBoxSectorFlags.bru,
                # Add more mappings as needed
            }
            flag = flag_map.get(item, None)
            if flag is not None:
                return self.contains_flag(flag)
        elif isinstance(item, BBoxSectorFlags):
            return self.contains_flag(item)
        return False


# Example Usage

if __name__ == "__main__":
    # Initialize with a predefined composite sector
    sector = BBoxSector(BBoxSectorFlags.alo)
    print(f"Sector: {sector}")  # Output: Sector: a+l+o
    print(f"Divergencies: {sector.divergencies()}")  # Output: Divergencies: 3

    # Create an empty sector and insert flags
    combined_sector = BBoxSector()
    combined_sector.insert(BBoxSectorFlags.a)
    combined_sector.insert(BBoxSectorFlags.l)
    combined_sector.insert(BBoxSectorFlags.o)
    print(f"Combined Sector: {combined_sector}")  # Output: Combined Sector: a+l+o
    print(f"Divergencies: {combined_sector.divergencies()}")  # Output: Divergencies: 3

    # Initialize with the 'inside' sector
    inner_sector = BBoxSector(BBoxSectorFlags.i)
    print(f"Inner Sector: {inner_sector}")  # Output: Inner Sector: i
    print(f"Divergencies: {inner_sector.divergencies()}")  # Output: Divergencies: 0

    # Initialize with no sector
    no_sector = BBoxSector()
    print(f"No Sector: {no_sector}")  # Output: No Sector: no sector
    print(f"Divergencies: {no_sector.divergencies()}")  # Output: Divergencies: 0

    # Undefined composite sector example
    undefined_sector = BBoxSector()
    undefined_sector.insert(BBoxSectorFlags.a)
    undefined_sector.insert(BBoxSectorFlags.b)
    undefined_sector.insert(BBoxSectorFlags.l)
    undefined_sector.insert(BBoxSectorFlags.r)
    print(f"Undefined Combined Sector: {undefined_sector}")  # Output: Undefined Combined Sector: a+b+l+r
    print(f"Divergencies: {undefined_sector.divergencies()}")  # Output: Divergencies: 4

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/SpatialBasics.py <==
from enum import Enum
import math
from typing import Dict


# Calculation schema to determine nearby radius
class NearbySchema(Enum):
    fixed = "fixed"      # use nearbyFactor as fix nearby radius
    circle = "circle"    # use base circle radius of bbox multiplied with nearbyFactor
    sphere = "sphere"    # use sphere radius of bbox multiplied with nearbyFactor
    perimeter = "perimeter"  # use base perimeter multiplied with nearbyFactor
    area = "area"        # use area multiplied with nearbyFactor

    @staticmethod
    def named(name: str):
        return NearbySchema(name) if name in NearbySchema.__members__ else None


# Calculation schema to determine sector size for extruding bbox area
class SectorSchema(Enum):
    fixed = "fixed"      # use sectorFactor as fix sector length for extruding area
    dimension = "dimension"  # use same dimension as object bbox multiplied with sectorFactor
    perimeter = "perimeter"  # use base perimeter multiplied with sectorFactor
    area = "area"        # use area multiplied with sectorFactor
    nearby = "nearby"    # use nearby settings of spatial adjustment for extruding

    @staticmethod
    def named(name: str):
        return SectorSchema(name) if name in SectorSchema.__members__ else None


# Set adjustment parameters before executing pipeline or calling relate() method.
# SpatialReasoner has its own local adjustment that should be set upfront.
class SpatialAdjustment:
    def __init__(
        self,
        maxGap: float = 0.02,
        angle: float = 0.05 * math.pi,
        sector_schema: SectorSchema = SectorSchema.nearby,
        sector_factor: float = 1.0,
        sector_limit: float = 2.5,
        nearby_schema: NearbySchema = NearbySchema.circle,
        nearby_factor: float = 2.0,
        nearby_limit: float = 2.5
    ):
        # Max deviations
        self.maxGap: float = maxGap  # max distance of deviation in all directions in meters
        self.maxAngleDelta: float = angle  # max angle delta in both directions in radians

        # Sector size
        self.sectorSchema: SectorSchema = sector_schema
        self.sectorFactor: float = sector_factor  # multiplying result of calculation schema
        self.sectorLimit: float = sector_limit  # maximal length

        # Vicinity
        self.nearbySchema: NearbySchema = nearby_schema
        self.nearbyFactor: float = nearby_factor  # multiplying radius sum of object and subject (relative to size) as max distance
        self.nearbyLimit: float = nearby_limit  # maximal absolute distance

        # Proportions
        self.longRatio: float = 4.0  # one dimension is factor larger than both others
        self.thinRatio: float = 10.0  # one dimension is 1/factor smaller than both others

    @property
    def yaw(self) -> float:
        """Get max delta of orientation in degrees."""
        return self.maxAngleDelta * 180.0 / math.pi

    def setYaw(self, degrees: float):
        """Set max delta of orientation in degrees."""
        self.maxAngleDelta = degrees * math.pi / 180.0


# Default adjustment only used when no SpatialReasoner builds context
defaultAdjustment = SpatialAdjustment()
tightAdjustment = SpatialAdjustment(maxGap=0.002, angle=0.01 * math.pi, sector_factor=0.5)


class SpatialPredicateCategories:
    def __init__(self):
        self.topology: bool = True
        self.connectivity: bool = True
        self.comparability: bool = False
        self.similarity: bool = False
        self.sectoriality: bool = False
        self.visibility: bool = False
        self.geography: bool = False


class ObjectConfidence:
    """Plausibility values between 0.0 and 1.0"""

    def __init__(self):
        self.pose: float = 0.0  # plausibility of position and orientation of (partially) detected part
        self.dimension: float = 0.0  # plausibility of size of spatial object
        self.label: float = 0.0  # plausibility of classification: label, type, supertype
        self.look: float = 0.0  # plausibility of look and shape

    @property
    def value(self) -> float:
        return (self.pose + self.dimension + self.label) / 3.0

    def setValue(self, value: float):
        self.pose = value
        self.dimension = value
        self.label = value

    @property
    def spatial(self) -> float:
        return (self.pose + self.dimension) / 2.0

    def setSpatial(self, value: float):
        self.pose = value
        self.dimension = value

    def asDict(self) -> Dict[str, float]:
        return {
            "pose": self.pose,
            "dimension": self.dimension,
            "label": self.label,
            "look": self.look
        }


# Searchable, metric, spatio-temporal attributes
class SpatialAtribute(Enum):
    none = "none"
    width = "width"
    height = "height"
    depth = "depth"
    length = "length"
    angle = "angle"
    yaw = "yaw"
    azimuth = "azimuth"  # deviation from north direction
    footprint = "footprint"  # base surface
    frontface = "frontface"  # front surface
    sideface = "sideface"  # side surface
    surface = "surface"  # total bbox surface
    volume = "volume"
    perimeter = "perimeter"
    baseradius = "baseradius"  # radius of 2D floorground circle
    radius = "radius"  # radius of sphere including 3D bbox around center
    speed = "speed"
    confidence = "confidence"
    lifespan = "lifespan"


class SpatialExistence(Enum):
    undefined = "undefined"
    real = "real"  # visual, detected, real object
    virtual = "virtual"  # visual, created, virtual object
    conceptual = "conceptual"  # non-visual, conceptual area, e.g., corner, zone, sensing area, region of interest, interaction field
    aggregational = "aggregational"  # non-visual part-of group, container

    @staticmethod
    def named(name: str):
        return SpatialExistence(name) if name in SpatialExistence.__members__ else SpatialExistence.undefined


class ObjectCause(Enum):
    unknown = "unknown"
    plane_detected = "plane_detected"  # on-device plane detection
    object_detected = "object_detected"  # on-device object detection
    self_tracked = "self_tracked"  # device of user registered and tracked in space
    user_captured = "user_captured"  # captured by user
    user_generated = "user_generated"  # generated by user
    rule_produced = "rule_produced"  # produced by rule or by program logic
    remote_created = "remote_created"  # created by remote service

    @staticmethod
    def named(name: str):
        return ObjectCause(name) if name in ObjectCause.__members__ else ObjectCause.unknown


class MotionState(Enum):
    unknown = "unknown"
    stationary = "stationary"  # immobile
    idle = "idle"  # idle
    moving = "moving"  # moving


class ObjectShape(Enum):
    unknown = "unknown"
    planar = "planar"  # plane, thin box
    cubical = "cubical"  # box
    spherical = "spherical"
    cylindrical = "cylindrical"  # along longest dimension when long
    conical = "conical"
    irregular = "irregular"  # complex shape
    changing = "changing"  # changing shape, e.g., of creature

    @staticmethod
    def named(name: str):
        return ObjectShape(name) if name in ObjectShape.__members__ else ObjectShape.unknown


# TODO: operable?
class ObjectHandling(Enum):
    none = "none"
    movable = "movable"
    slidable = "slidable"
    liftable = "liftable"
    portable = "portable"
    rotatable = "rotatable"
    openable = "openable"
    # tangible = "tangible"  # ?? user-dep.


# Example Usage
if __name__ == "__main__":
    # SpatialAdjustment example
    adjustment = SpatialAdjustment()
    print(f"Default Adjustment Max Gap: {adjustment.maxGap}")  # Output: 0.02
    print(f"Default Adjustment Yaw: {adjustment.yaw} degrees")  # Output: ~2.864788975654116 degrees

    adjustment.setYaw(10.0)
    print(f"Updated Adjustment Max Angle Delta: {adjustment.maxAngleDelta} radians")  # Output: ~0.17453292519943295 radians

    # ObjectConfidence example
    confidence = ObjectConfidence()
    confidence.pose = 0.8
    confidence.dimension = 0.7
    confidence.label = 0.9
    confidence.look = 0.6
    print(f"Object Confidence Value: {confidence.value}")  # Output: (0.8 + 0.7 + 0.9) / 3 = 0.8
    print(f"Object Confidence Spatial: {confidence.spatial}")  # Output: (0.8 + 0.7) / 2 = 0.75
    print(f"Object Confidence as Dictionary: {confidence.asDict()}")  # Output: {'pose': 0.8, 'dimension': 0.7, 'label': 0.9, 'look': 0.6}

    # Enum usage example
    schema = NearbySchema.circle
    print(f"Nearby Schema: {schema.value}")  # Output: "circle"

    existence = SpatialExistence.named("virtual")
    print(f"Spatial Existence: {existence.value}")  # Output: "virtual"

    cause = ObjectCause.named("user_generated")
    print(f"Object Cause: {cause.value}")  # Output: "user_generated"

    shape = ObjectShape.named("spherical")
    print(f"Object Shape: {shape.value}")  # Output: "spherical"

    handling = ObjectHandling.movable
    print(f"Object Handling: {handling.value}")  # Output: "movable"

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/SpatialInference.py <==
import datetime
from typing import List, Dict, Optional, Any
import re

# Placeholder imports for dependencies.
# Ensure that these classes are properly defined in your Python project.
# from spatial_adjustment import SpatialAdjustment
# from spatial_predicate_categories import SpatialPredicateCategories
# from spatial_object import SpatialObject
# from spatial_relation import SpatialRelation
# from spatial_reasoner import SpatialReasoner

class SpatialInference:
    def __init__(self, input_indices: List[int], operation: str, fact: 'SpatialReasoner'):
        self.input: List[int] = input_indices  # Indices to fact.base["objects"]
        self.output: List[int] = []            # Indices to fact.base["objects"]
        self.operation: str = operation
        self.succeeded: bool = False
        self.error: str = ""
        self.fact: 'SpatialReasoner' = fact

        # Parse and execute the operation
        try:
            if self.operation.startswith("filter(") and self.operation.endswith(")"):
                condition = self.operation[7:-1].strip()
                self.filter(condition)
            elif self.operation.startswith("pick(") and self.operation.endswith(")"):
                relations = self.operation[5:-1].strip()
                self.pick(relations)
            elif self.operation.startswith("select(") and self.operation.endswith(")"):
                terms = self.operation[7:-1].strip()
                self.select(terms)
            elif self.operation.startswith("sort(") and self.operation.endswith(")"):
                attribute = self.operation[5:-1].strip()
                self.sort(attribute)
            elif self.operation.startswith("slice(") and self.operation.endswith(")"):
                range_str = self.operation[6:-1].strip()
                self.slice(range_str)
            elif self.operation.startswith("produce(") and self.operation.endswith(")"):
                terms = self.operation[8:-1].strip()
                self.produce(terms)
            elif self.operation.startswith("calc(") and self.operation.endswith(")"):
                assignments = self.operation[5:-1].strip()
                self.calc(assignments)
            elif self.operation.startswith("map(") and self.operation.endswith(")"):
                assignments = self.operation[4:-1].strip()
                self.map(assignments)
            elif self.operation.startswith("reload(") and self.operation.endswith(")"):
                self.reload()
            else:
                self.error = f"Unknown inference operation: {self.operation}"
        except Exception as e:
            self.error = f"Exception during operation '{self.operation}': {str(e)}"

    def add(self, index: int):
        if index not in self.output:
            self.output.append(index)

    def filter(self, condition: str):
        predicate = SpatialInference.attribute_predicate(condition)
        if predicate is None:
            self.error = f"Invalid filter condition: {condition}"
            return

        base_objects = self.fact.base.get("objects", [])
        for i in self.input:
            obj = base_objects[i]
            try:
                result = predicate(obj)
                if result:
                    self.add(i)
            except Exception as e:
                self.error = f"Filter evaluation error for object {i}: {str(e)}"
                return
        self.succeeded = True

    def pick(self, relations: str):
        predicates = SpatialInference.extract_keywords(relations)
        for i in self.input:
            for j, subject in enumerate(self.fact.objects):
                if i != j:
                    cond = relations
                    for predicate in predicates:
                        if self.fact.does(subject=self.fact.objects[j], have=predicate, with_obj_idx=i):
                            cond = cond.replace(predicate, "True")
                        else:
                            cond = cond.replace(predicate, "False")
                    try:
                        result = eval(cond)
                        if result:
                            self.add(j)
                    except Exception as e:
                        self.error = f"Pick evaluation error for relation '{relations}' between {i} and {j}: {str(e)}"
                        return
        self.succeeded = bool(self.output)

    def select(self, terms: str):
        parts = [part.strip() for part in terms.split("?")]
        if len(parts) == 1:
            relations = parts[0]
            conditions = ""
        elif len(parts) == 2:
            relations, conditions = parts
        else:
            self.error = "Invalid select query format."
            return

        predicates = SpatialInference.extract_keywords(relations)
        base_objects = self.fact.base.get("objects", [])
        for i in self.input:
            for j, subject in enumerate(self.fact.objects):
                if i != j:
                    cond = relations
                    for predicate in predicates:
                        if self.fact.does(subject=self.fact.objects[j], have=predicate, with_obj_idx=i):
                            cond = cond.replace(predicate, "True")
                        else:
                            cond = cond.replace(predicate, "False")
                    try:
                        result = eval(cond)
                        if result:
                            if conditions:
                                attr_predicate = SpatialInference.attribute_predicate(conditions)
                                if attr_predicate and attr_predicate(base_objects[j]):
                                    self.add(i)
                            else:
                                self.add(i)
                    except Exception as e:
                        self.error = f"Select evaluation error for object {i}: {str(e)}"
                        return
        self.succeeded = bool(self.output)

    def map(self, assignments: str):
        self.assign(assignments, self.input)
        self.fact.load()  # Reload the fact base after mapping
        self.output = self.input.copy()
        self.succeeded = bool(self.output)

    def assign(self, assignments: str, indices: List[int]):
        assignment_list = [assignment.strip() for assignment in assignments.split(";")]
        base_objects = self.fact.base.get("objects", [])

        for i in indices:
            obj_dict = dict(base_objects[i])  # Create a copy to modify
            data_dict = self.fact.base.get("data", {}).copy()
            obj_dict.update(data_dict)

            for assignment in assignment_list:
                if "=" in assignment:
                    key, expr = [part.strip() for part in assignment.split("=", 1)]
                    try:
                        # Prepare the local variables for eval
                        local_vars = obj_dict.copy()
                        value = eval(expr, {"__builtins__": {}}, local_vars)
                        if value is not None:
                            obj_dict[key] = value
                    except Exception as e:
                        self.error = f"Assign evaluation error for object {i}, assignment '{assignment}': {str(e)}"
                        return

            # Update the SpatialObject with the new dictionary
            self.fact.objects[i].from_any(obj_dict)
            # Also update the fact base
            self.fact.base["objects"][i] = obj_dict

    def calc(self, assignments: str):
        assignment_list = [assignment.strip() for assignment in assignments.split(";")]
        for assignment in assignment_list:
            if "=" in assignment:
                key, expr = [part.strip() for part in assignment.split("=", 1)]
                try:
                    # Prepare the local variables for eval
                    local_vars = self.fact.base.copy()
                    value = eval(expr, {"__builtins__": {}}, local_vars)
                    if value is not None:
                        self.fact.set_data(key, value)
                except Exception as e:
                    self.error = f"Calc evaluation error for assignment '{assignment}': {str(e)}"
                    return
        self.output = self.input.copy()
        self.succeeded = bool(self.output)

    def slice(self, range_str: str):
        # Replace ".." with "." to handle inclusive ranges
        range_str = range_str.replace("..", ".")
        parts = [part.strip() for part in range_str.split(".")]
        lower = 0
        upper = 0

        if len(parts) >= 1 and parts[0]:
            lower = int(parts[0])
            if lower >= len(self.input):
                lower = len(self.input)
            if lower < 0:
                lower = len(self.input) + lower
            else:
                lower = lower - 1

        if len(parts) >= 2 and parts[1]:
            upper = int(parts[1])
            if upper >= len(self.input):
                upper = len(self.input)
            if upper < 0:
                upper = len(self.input) + upper
            else:
                upper = upper - 1
        else:
            upper = lower

        if lower > upper:
            lower, upper = upper, lower

        # Clamp the range within valid indices
        lower = max(0, lower)
        upper = min(len(self.input) - 1, upper)

        idx_range = range(lower, upper + 1)
        self.output = [self.input[i] for i in idx_range]
        self.succeeded = bool(self.output)

    def sort(self, attribute: str):
        ascending = False
        sorted_objects = []
        input_objects = [self.fact.objects[i] for i in self.input]
        sorted_objects = input_objects.copy()

        # Check for ascending order if specified
        match = re.match(r"(\w+)\s*([<>])", attribute)
        if match:
            attr_name, order = match.groups()
            if order == "<":
                ascending = True
            else:
                ascending = False
            attr_name = attr_name.strip()
        else:
            attr_name = attribute.strip()

        # Determine the sorting key
        def sort_key(obj: 'SpatialObject'):
            if "." in attr_name:
                # Sort by relation value
                return obj.relation_value(attr_name, pre=self.fact.backtrace())
            else:
                # Sort by attribute value
                return obj.get_attribute_value(attr_name)

        try:
            sorted_objects.sort(key=sort_key, reverse=not ascending)
        except Exception as e:
            self.error = f"Sort evaluation error for attribute '{attribute}': {str(e)}"
            return

        # Update the output indices based on sorted order
        self.output = []
        for obj in sorted_objects:
            idx = self.fact.objects.index(obj)
            self.add(idx)
        self.succeeded = bool(self.output)

    def sort_by_relation(self, attribute: str):
        ascending = False
        sorted_objects = []
        pre_indices = self.fact.backtrace()
        input_objects = [self.fact.objects[i] for i in self.input]
        sorted_objects = input_objects.copy()

        # Check for ascending order if specified
        match = re.match(r"(\w+)\s*([<>])", attribute)
        if match:
            attr_name, order = match.groups()
            if order == "<":
                ascending = True
            else:
                ascending = False
            attr_name = attr_name.strip()
        else:
            attr_name = attribute.strip()

        # Determine the sorting key
        def sort_key(obj: 'SpatialObject'):
            try:
                return obj.relation_value(attr_name, pre=pre_indices)
            except Exception:
                return 0  # Default value if relation_value fails

        try:
            sorted_objects.sort(key=sort_key, reverse=not ascending)
        except Exception as e:
            self.error = f"Sort by relation error for attribute '{attribute}': {str(e)}"
            return

        # Update the output indices based on sorted order
        self.output = []
        for obj in sorted_objects:
            idx = self.fact.objects.index(obj)
            self.add(idx)
        self.succeeded = bool(self.output)

    def produce(self, terms: str):
        print(terms)  # Debug print, can be removed or replaced with logging
        parts = [part.strip() for part in terms.split(":")]
        if not parts:
            self.error = "Invalid produce terms."
            return

        rule = parts[0]
        assignments = parts[1] if len(parts) > 1 else ""
        indices: List[int] = []
        new_objects: List[Dict[str, Any]] = []

        if rule in ["group", "aggregate"]:
            if self.input:
                input_objects = [self.fact.objects[i] for i in self.input]
                sorted_objects = sorted(input_objects, key=lambda o: o.volume, reverse=True)
                largest_object = sorted_objects[0] if sorted_objects else None

                if largest_object:
                    min_y = 0.0
                    max_y = largest_object.height
                    min_x = -largest_object.width / 2.0
                    max_x = largest_object.width / 2.0
                    min_z = -largest_object.depth / 2.0
                    max_z = largest_object.depth / 2.0
                    group_id = f"group:{largest_object.id}"

                    for obj in sorted_objects[1:]:
                        local_pts = largest_object.into_local(obj.points(local=False))
                        for pt in local_pts:
                            min_x = min(min_x, float(pt.x))
                            max_x = max(max_x, float(pt.x))
                            min_y = min(min_y, float(pt.y))
                            max_y = max(max_y, float(pt.y))
                            min_z = min(min_z, float(pt.z))
                            max_z = max(max_z, float(pt.z))
                        group_id += f"+{obj.id}"

                    w = max_x - min_x
                    h = max_y - min_y
                    d = max_z - min_z
                    dx = min_x + w / 2.0
                    dy = min_y + h / 2.0
                    dz = min_z + d / 2.0

                    obj_idx = self.fact.index_of_id(group_id) or -1
                    group = self.fact.objects[obj_idx] if obj_idx >= 0 else SpatialObject(id=group_id)
                    group.set_position(largest_object.pos)
                    group.rot_shift(-largest_object.angle, dx, dy, dz)
                    group.angle = largest_object.angle
                    group.width = w
                    group.height = h
                    group.depth = d
                    group.cause = "rule_produced"

                    if obj_idx < 0:
                        new_objects.append(group.as_dict())
                        indices.append(len(self.fact.objects))
                        self.fact.objects.append(group)

        elif rule in ["copy", "duplicate"]:
            for i in self.input:
                copy_id = f"copy:{self.fact.objects[i].id}"
                idx = self.fact.index_of_id(copy_id)
                if idx is None:
                    copy_obj = SpatialObject(id=copy_id)
                    copy_obj.from_any(self.fact.objects[i].to_any())
                    copy_obj.cause = "rule_produced"
                    copy_obj.set_position(self.fact.objects[i].pos)
                    copy_obj.angle = self.fact.objects[i].angle
                    new_objects.append(copy_obj.as_dict())
                    indices.append(len(self.fact.objects))
                    self.fact.objects.append(copy_obj)
                else:
                    indices.append(idx)

        elif rule == "by":
            processed_bys = set()
            for i in self.input:
                rels = self.fact.relations_with(i, predicate="by")
                for rel in rels:
                    subject_idx = self.fact.index_of_id(rel.subject.id)
                    if subject_idx is not None and subject_idx in self.input:
                        key = f"{self.fact.objects[i].id}-{rel.subject.id}"
                        if key not in processed_bys:
                            nearest_pts = self.fact.objects[i].pos.nearest(rel.subject.points())
                            by_id = f"by:{self.fact.objects[i].id}-{rel.subject.id}"
                            obj_idx = self.fact.index_of_id(by_id) or -1
                            obj = self.fact.objects[obj_idx] if obj_idx >= 0 else SpatialObject(id=by_id)
                            obj.cause = "rule_produced"
                            if nearest_pts:
                                obj.set_position(nearest_pts[0])
                                obj.angle = self.fact.objects[i].angle
                                obj.width = max(rel.delta, self.fact.adjustment.maxGap)
                                obj.depth = max(rel.delta, self.fact.adjustment.maxGap)
                                obj.height = rel.subject.height
                                new_objects.append(obj.as_dict())
                                indices.append(len(self.fact.objects))
                                self.fact.objects.append(obj)
                            processed_bys.add(key)

        else:
            self.error = f"Unknown rule '{rule}' in produce()"
            return

        if indices:
            self.fact.base["objects"].extend(new_objects)
            if assignments:
                self.assign(assignments, indices)
            self.output = self.input.copy()
            for idx in indices:
                if idx not in self.output:
                    self.output.append(idx)
        else:
            self.output = self.input.copy()

        self.fact.load()
        self.succeeded = not self.error

    def reload(self):
        self.fact.sync_to_objects()
        self.fact.load()
        self.output = list(range(len(self.fact.objects)))
        self.succeeded = bool(self.output)

    def has_failed(self) -> bool:
        return bool(self.error)

    def is_manipulating(self) -> bool:
        operations = ["filter", "pick", "select", "produce", "slice"]
        return any(self.operation.startswith(op) for op in operations)

    def as_dict(self) -> Dict[str, Any]:
        return {
            "operation": self.operation,
            "input": self.input,
            "output": self.output,
            "error": self.error,
            "succeeded": self.succeeded
        }

    @staticmethod
    def attribute_predicate(condition: str) -> Optional[Any]:
        """
        Convert a condition string into a callable predicate function.
        For security reasons, using eval is dangerous. Consider using a safe parser.
        """
        try:
            # Replace attribute names with dictionary access
            # e.g., "width > 2" becomes "obj['width'] > 2"
            # Assuming all attributes are accessed via 'obj'
            # This is a simplistic approach and may need to be expanded
            pattern = re.compile(r'\b\w+\b')
            condition_converted = pattern.sub(lambda match: f"obj.get('{match.group(0)}', 0)", condition)
            # Compile the condition into a lambda function
            predicate = eval(f"lambda obj: {condition_converted}", {"__builtins__": {}})
            return predicate
        except Exception as e:
            print(f"Error creating attribute predicate: {e}")
            return None

    @staticmethod
    def extract_keywords(text: str) -> List[str]:
        """
        Extract lowercase letter sequences as keywords from a given text.
        """
        return re.findall(r'\b[a-z]+\b', text)

# Helper function to safely evaluate expressions
def safe_eval(expression: str, variables: Dict[str, Any]) -> Any:
    """
    Safely evaluate an expression using only the provided variables.
    This function restricts the available built-ins for security.
    """
    try:
        return eval(expression, {"__builtins__": {}}, variables)
    except Exception as e:
        raise ValueError(f"Error evaluating expression '{expression}': {str(e)}")

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/SpatialObject.py <==
# SpatialObject.py
# Python translation of the Swift SpatialObject class.

import math
import datetime
from typing import Any, Dict, List, Optional, TYPE_CHECKING
import logging

from .vector3 import Vector3
from .SpatialBasics import (
    NearbySchema,
    SectorSchema,
    SpatialAdjustment,
    SpatialPredicateCategories,
    ObjectConfidence,
    SpatialAtribute,
    SpatialExistence,
    ObjectCause,
    MotionState,
    ObjectShape,
    ObjectHandling,
    defaultAdjustment  # Ensure defaultAdjustment is accessible
)

from .SpatialPredicate import (
    SpatialPredicate,
    PredicateTerm,
    SpatialTerms,
    proximity,
    directionality,
    adjacency,
    orientations,
    assembly,
    topology,
    contacts,
    connectivity,
    comparability,
    similarity,
    visibility,
    geography,
    sectors
)


from .BBoxSector import BBoxSector, BBoxSectorFlags
if TYPE_CHECKING:
    from .SpatialRelation import SpatialRelation
else:
    from .SpatialRelation import SpatialRelation


class SpatialObject:
    # Class Variables
    booleanAttributes: List[str] = [
        "immobile", "moving", "focused", "visible",
        "equilateral", "thin", "long", "real",
        "virtual", "conceptual"
    ]
    numericAttributes: List[str] = [
        "width", "height", "depth", "w", "h",
        "d", "position", "x", "y", "z", "angle", "confidence"
    ]
    stringAttributes: List[str] = [
        "id", "label", "type", "supertype",
        "existence", "cause", "shape", "look"
    ]

    def __init__(
        self,
        id: str,
        position: Vector3 = Vector3(),
        width: float = 1.0,
        height: float = 1.0,
        depth: float = 1.0,
        angle: float = 0.0,
        label: str = "",
        confidence: float = 0.0
    ):
        # Non-spatial characteristics
        self.id: str = id  # unique id: UUID of source or own generated unique id
        self.existence: SpatialExistence = SpatialExistence.real
        self.cause: ObjectCause = ObjectCause.unknown
        self.label: str = label  # name or label
        self.type: str = ""  # class
        self.supertype: str = ""  # superclass
        self.look: str = ""  # textual description of appearance
        self.data: Optional[Dict[str, Any]] = None  # auxiliary data
        self.created: datetime.datetime = datetime.datetime.now()  # creation time
        self.updated: datetime.datetime = datetime.datetime.now()  # last update time

        # Spatial characteristics
        self.position: Vector3 = position  # base center point at bottom
        self.width: float = width
        self.height: float = height
        self.depth: float = depth
        self.angle: float = angle  # rotation around y axis in radians, counter-clockwise
        self.immobile: bool = False
        self.velocity: Vector3 = Vector3()  # velocity vector
        self.confidence: ObjectConfidence = ObjectConfidence()
        self.confidence.setSpatial(confidence)
        self.confidence.setValue(confidence)
        self.shape: ObjectShape = ObjectShape.unknown
        self.visible: bool = False  # in screen
        self.focused: bool = False  # in center of screen, for some time
        self.context: Optional['SpatialReasoner'] = None  # optional context

    # Derived Attributes
    @property
    def center(self) -> Vector3:
        return Vector3(
        self.position.x + self.width / 2.0,
        self.position.y + self.height / 2.0,
        self.position.z + self.depth / 2.0
    )

    @property
    def pos(self) -> Vector3:
        return self.position

    @property
    def yaw(self) -> float:
        # in degrees counter-clockwise of WCS
        return self.angle * 180.0 / math.pi

    @property
    def azimuth(self) -> float:
        # in degrees clockwise of GCS as ±360°
        if self.context is not None and self.context.north is not None:
            north_angle = math.atan2(self.context.north.y, self.context.north.x) * 180.0 / math.pi
            return -(self.yaw + north_angle - 90.0) % 360.0
        return 0.0

    @property
    def thin(self) -> bool:
        return self.thin_ratio() > 0

    @property
    def long(self) -> bool:
        return self.long_ratio() > 0

    @property
    def equilateral(self) -> bool:
        return self.long_ratio() == 0

    @property
    def real(self) -> bool:
        return self.existence == SpatialExistence.real

    @property
    def virtual(self) -> bool:
        return self.existence == SpatialExistence.virtual

    @property
    def conceptual(self) -> bool:
        return self.existence == SpatialExistence.conceptual

    @property
    def perimeter(self) -> float:
        # footprint perimeter
        return (self.depth + self.width) * 2.0

    @property
    def footprint(self) -> float:
        # base area, floor space
        return self.depth * self.width

    @property
    def frontface(self) -> float:
        # front area
        return self.height * self.width

    @property
    def sideface(self) -> float:
        # side area
        return self.height * self.depth

    @property
    def surface(self) -> float:
        # total surface of bbox
        return (self.height * self.width + self.depth * self.width + self.height * self.depth) * 2.0

    @property
    def volume(self) -> float:
        return self.depth * self.width * self.height

    @property
    def radius(self) -> float:
        # sphere radius from center comprising body volume
        return Vector3(self.width / 2.0, self.depth / 2.0, self.height / 2.0).length()

    @property
    def baseradius(self) -> float:
        # circle radius on 2D base / floor ground
        return math.hypot(self.width / 2.0, self.depth / 2.0)

    @property
    def motion(self) -> MotionState:
        if self.immobile:
            return MotionState.stationary
        if self.confidence.spatial > 0.5:
            if self.velocity.length() > self.adjustment.maxGap:
                return MotionState.moving
            return MotionState.idle
        return MotionState.unknown

    @property
    def moving(self) -> bool:
        return self.motion == MotionState.moving

    @property
    def speed(self) -> float:
        return self.velocity.length()

    @property
    def observing(self) -> bool:
        return self.cause == ObjectCause.self_tracked

    @property
    def length(self) -> float:
        alignment = self.long_ratio(1.1)
        if alignment == 1:
            return self.width
        elif alignment == 2:
            return self.height
        return self.depth

    @property
    def lifespan(self) -> float:
        now = datetime.datetime.now()
        return (now - self.created).total_seconds()

    @property
    def updateInterval(self) -> float:
        now = datetime.datetime.now()
        return (now - self.updated).total_seconds()

    @property
    def adjustment(self) -> SpatialAdjustment:
        return self.context.adjustment if self.context else defaultAdjustment
    
    @adjustment.setter
    def adjustment(self, value: SpatialAdjustment):
        if not isinstance(value, SpatialAdjustment):
            raise ValueError("adjustment must be an instance of SpatialAdjustment")
        self._adjustment = value

    # Index Method
    def index(self) -> int:
        if self.context is not None:
            try:
                return self.context.objects.index(self)
            except ValueError:
                return -1
        return -1

    # Static Methods
    @staticmethod
    def isBoolean(attribute: str) -> bool:
        return attribute in SpatialObject.booleanAttributes

    @staticmethod
    def createDetectedObject(
        id: str,
        label: str = "",
        width: float = 1.0,
        height: float = 1.0,
        depth: float = 1.0
    ) -> 'SpatialObject':
        obj = SpatialObject(
            id=id,
            position=Vector3(0.0, 0.0, 0.0),
            width=width,
            height=height,
            depth=depth
        )
        obj.label = label.lower()
        obj.type = label
        obj.cause = ObjectCause.object_detected
        obj.existence = SpatialExistence.real
        obj.confidence.setValue(0.25)
        obj.immobile = False
        obj.shape = ObjectShape.unknown
        return obj

    @staticmethod
    def createVirtualObject(
        id: str,
        width: float = 1.0,
        height: float = 1.0,
        depth: float = 1.0
    ) -> 'SpatialObject':
        obj = SpatialObject(
            id=id,
            position=Vector3(0.0, 0.0, 0.0),
            width=width,
            height=height,
            depth=depth
        )
        obj.cause = ObjectCause.user_generated
        obj.existence = SpatialExistence.virtual
        obj.confidence.setSpatial(1.0)
        obj.immobile = False
        return obj

    @staticmethod
    def createBuildingElement(
        id: str,
        type: str = "",
        from_pos: Vector3 = Vector3(),
        width: float = 1.0,
        height: float = 1.0,
        depth: float = 1.0
    ) -> 'SpatialObject':
        obj = SpatialObject(
            id=id,
            position=from_pos,
            width=width,
            height=height,
            depth=depth
        )
        obj.label = type.lower()
        obj.type = type
        obj.supertype = "Building Element"
        obj.cause = ObjectCause.plane_detected
        obj.existence = SpatialExistence.real
        obj.confidence.setValue(0.5)
        obj.immobile = True
        obj.shape = ObjectShape.cubical
        return obj

    @staticmethod
    def createBuildingElement_from_vectors(
        id: str,
        type: str = "",
        from_pos: Vector3 = Vector3(),
        to_pos: Vector3 = Vector3(),
        height: float = 1.0,
        depth: float = 0.25
    ) -> 'SpatialObject':
        mid_vector = (to_pos - from_pos) / 2.0
        mid_vector_length = mid_vector.length()
        factor = depth / mid_vector_length / 2.0
        normal = Vector3(mid_vector.x * factor, 0.0, mid_vector.z * factor).rotate(math.pi / 2.0)
        pos = from_pos + mid_vector - Vector3(normal.x, 0.0, normal.z)
        obj = SpatialObject(
            id=id,
            position=pos,
            width=mid_vector_length * 2.0,
            height=height,
            depth=depth
        )
        obj.angle = -math.atan2(mid_vector.z, mid_vector.x)
        obj.label = type.lower()
        obj.type = type
        obj.supertype = "Building Element"
        obj.cause = ObjectCause.user_captured
        obj.existence = SpatialExistence.real
        obj.confidence.setValue(0.9)
        obj.immobile = True
        obj.shape = ObjectShape.cubical
        return obj

    @staticmethod
    def createPerson(
        id: str,
        position: Vector3,
        name: str = ""
    ) -> 'SpatialObject':
        # Create with average dimensions of a person
        person = SpatialObject(
            id=id,
            position=position,
            width=0.46,
            height=1.72,
            depth=0.34
        )
        person.label = name
        person.cause = ObjectCause.self_tracked
        person.existence = SpatialExistence.real
        person.confidence.setValue(1.0)
        person.immobile = False
        person.supertype = "Creature"
        person.type = "Person"
        person.shape = ObjectShape.changing
        return person

    # Set Auxiliary Data
    def setData(self, key: str, value: Any):
        if self.data is not None:
            self.data[key] = value
        else:
            self.data = {key: value}

    def dataValue(self, key: str) -> float:
        if self.data is not None:
            value = self.data.get(key)
            if isinstance(value, float):
                return value
            if isinstance(value, (int,)):
                return float(value)
        return 0.0

    # Object Serialization
    # Full-fledged representation for fact base
    def asDict(self) -> Dict[str, Any]:
        output = {
            "id": self.id,
            "existence": self.existence.value,
            "cause": self.cause.value,
            "label": self.label,
            "type": self.type,
            "supertype": self.supertype,
            "position": [self.position.x, self.position.y, self.position.z],
            "center": [self.center.x, self.center.y, self.center.z],
            "width": self.width,
            "height": self.height,
            "depth": self.depth,
            "length": self.length,
            "direction": self.mainDirection(),
            "thin": self.thin,
            "long": self.long,
            "equilateral": self.equilateral,
            "real": self.real,
            "virtual": self.virtual,
            "conceptual": self.conceptual,
            "moving": self.moving,
            "perimeter": self.perimeter,
            "footprint": self.footprint,
            "frontface": self.frontface,
            "sideface": self.sideface,
            "surface": self.surface,
            "baseradius": self.baseradius,
            "volume": self.volume,
            "radius": self.radius,
            "angle": self.angle,
            "yaw": self.yaw,
            "azimuth": self.azimuth,
            "lifespan": self.lifespan,
            "updateInterval": self.updateInterval,
            "confidence": self.confidence.asDict(),
            "immobile": self.immobile,
            "velocity": [self.velocity.x, self.velocity.y, self.velocity.z],
            "motion": self.motion.value,
            "shape": self.shape.value,
            "look": self.look,
            "visible": self.visible,
            "focused": self.focused
        }
        if self.data is not None:
            output.update(self.data)  # keeping current
        return output

    # For export
    def toAny(self) -> Dict[str, Any]:
        output = {
            "id": self.id,
            "existence": self.existence.value,
            "cause": self.cause.value,
            "label": self.label,
            "type": self.type,
            "supertype": self.supertype,
            "position": [self.position.x, self.position.y, self.position.z],
            "width": self.width,
            "height": self.height,
            "depth": self.depth,
            "angle": self.angle,
            "immobile": self.immobile,
            "velocity": [self.velocity.x, self.velocity.y, self.velocity.z],
            "confidence": self.confidence.value,
            "shape": self.shape.value,
            "look": self.look,
            "visible": self.visible,
            "focused": self.focused
        }
        if self.data is not None:
            output.update(self.data)  # keeping current
        return output

        # Import/Update from JSON data
    def fromAny(self, input_data: Dict[str, Any]):
            # ID Handling
            id_str = input_data.get("id", "")
            if id_str:
                if self.id != id_str:
                    print("import/update from another id!")
                self.id = id_str

            # Position Handling
            pos_list = input_data.get("position", [])
            if isinstance(pos_list, list) and len(pos_list) == 3:
                pos = Vector3(float(pos_list[0]), float(pos_list[1]), float(pos_list[2]))
            else:
                x = float(input_data.get("x", self.position.x))
                y = float(input_data.get("y", self.position.y))
                z = float(input_data.get("z", self.position.z))
                pos = Vector3(x, y, z)
            self.setPosition(pos)

            # Dimensions Handling
            self.width = float(input_data.get("width", input_data.get("w", self.width)))
            self.height = float(input_data.get("height", input_data.get("h", self.height)))
            self.depth = float(input_data.get("depth", input_data.get("d", self.depth)))

            # Angle Handling
            self.angle = float(input_data.get("angle", self.angle))

            # Labels and Types Handling
            self.label = input_data.get("label", self.label)
            self.type = input_data.get("type", self.type)
            self.supertype = input_data.get("supertype", self.supertype)

            # Confidence Handling
            confidence_data = input_data.get("confidence", self.confidence.value)
                    
            # Check if confidence_data is a dictionary
            if isinstance(confidence_data, dict):
                # Safely extract each confidence component with defaults
                self.confidence.pose = float(confidence_data.get("pose", self.confidence.pose))
                self.confidence.dimension = float(confidence_data.get("dimension", self.confidence.dimension))
                self.confidence.label = float(confidence_data.get("label", self.confidence.label))
                self.confidence.look = float(confidence_data.get("look", self.confidence.look))
            else:
                # Assume confidence_data is a float or convertible to float
                try:
                    confidence_val = float(confidence_data)
                    self.confidence.setValue(confidence_val)
                except (TypeError, ValueError):
                    self.confidence.setValue(self.confidence.value)
            

            # Cause and Existence Handling
            cause_str = input_data.get("cause", self.cause.value)
            self.cause = ObjectCause.named(cause_str)
            existence_str = input_data.get("existence", self.existence.value)
            self.existence = SpatialExistence.named(existence_str)

            # Immobile Handling
            self.immobile = bool(input_data.get("immobile", self.immobile))

            # Shape Handling
            shape_str = input_data.get("shape", self.shape.value)
            self.shape = ObjectShape.named(shape_str)

            # Look Handling
            self.look = input_data.get("look", self.look)

            # Other Attributes Handling
            self.visible = bool(input_data.get("visible", self.visible))
            self.focused = bool(input_data.get("focused", self.focused))

            # Auxiliary Data Handling
            for key, value in input_data.items():
                if key not in SpatialObject.stringAttributes and \
                key not in SpatialObject.numericAttributes and \
                key not in SpatialObject.booleanAttributes:
                    self.setData(key, value)

            # Update Time
            self.updated = datetime.datetime.now()

    # Description
    def desc(self) -> str:
        parts = []
        if self.label and self.label != self.id:
            parts.append(f"{self.label}, ")
        if self.type:
            parts.append(f"{self.type}, ")
        if self.supertype:
            parts.append(f"{self.supertype}, ")
        pos_str = f"{self.position.x:.2f}/" \
                  f"{self.position.y:.2f}/" \
                  f"{self.position.z:.2f}, "
        dims_str = f"{self.width:.2f}x{self.depth:.2f}x{self.height:.2f}, "
        angle_str = f"𝜶:{self.yaw:.1f}°"
        parts.append(pos_str)
        parts.append(dims_str)
        parts.append(angle_str)
        return "".join(parts)

    # Position Setters
    def setPosition(self, pos: Vector3):
        interval = self.updateInterval
        if interval > 0.003 and not self.immobile:
            prev_pos = self.position
            self.velocity = (pos - prev_pos) / interval
        self.position = pos

    def setCenter(self, ctr: Vector3):
        new_position = Vector3(
        ctr.x - self.width / 2.0,
        ctr.y - self.height / 2.0,
        ctr.z - self.depth / 2.0
       )
        self.setPosition(new_position)

    # Rotation and Shifting
    def rotShift(self, rad: float, dx: float, dy: float = 0.0, dz: float = 0.0):
        rotsin = math.sin(rad)
        rotcos = math.cos(rad)
        rx = dx * rotcos - dz * rotsin
        rz = dx * rotsin + dz * rotcos
        vector = Vector3(rx, dy, rz)
        self.position += vector

    def setYaw(self, degrees: float):
        self.angle = degrees * math.pi / 180.0

    # Directional Methods
    def mainDirection(self) -> int:
        return self.long_ratio()

    def thin_ratio(self, ratio: float = defaultAdjustment.thinRatio) -> int:
        values = (width,height,depth) = [self.width, self.height, self.depth]
        max_val = max(values) if values else 0.0
        min_val = min(values) if values else 0.0
        if max_val >= (min_val * ratio):
            if (width == min_val) and (width > (ratio * min_val)) and (depth > (ratio * min_val)):
                return 2
            if (width == min_val )and (height > (ratio * min_val)) and (depth > (ratio * min_val)):
                return 1
            if (depth == min_val) and (width > (ratio * min_val)) and (height > (ratio * min_val)):
                return 3
        return 0

    def long_ratio(self, ratio: float = 0.5) -> int:  # Set default explicitly
        values = [self.width, self.height, self.depth]
        max_val = max(values) if values else 0.0
        min_val = min(values) if values else 0.0
        logging.debug(f"long_ratio called with ratio={ratio}, max_val={max_val}, min_val={min_val}")
        if max_val > 0.0 and max_val >= min_val * ratio:
            logging.debug("Condition max_val >= min_val * ratio met")
            if self.width < max_val:
                if self.height < max_val:
                    logging.debug("Returning 3")
                    return 3
                else:
                    logging.debug("Returning 2")
                    return 2
            else:
                logging.debug("Returning 1")
                return 1
        logging.debug("Condition max_val >= min_val * ratio not met, returning 0")
        return 0

    # Point Calculation Methods
    def lowerPoints(self, local: bool = False) -> List[Vector3]:
        p0 = Vector3(self.width / 2.0, self.depth / 2.0, 0.0)
        p1 = Vector3(-self.width / 2.0, self.depth / 2.0, 0.0)
        p2 = Vector3(-self.width / 2.0, -self.depth / 2.0, 0.0)
        p3 = Vector3(self.width / 2.0, -self.depth / 2.0, 0.0)
        vector = Vector3()

        if not local:
            p0 = p0.rotate(-self.angle)
            p1 = p1.rotate(-self.angle)
            p2 = p2.rotate(-self.angle)
            p3 = p3.rotate(-self.angle)
            vector = self.position

        return [
            Vector3(p0.x + vector.x, vector.y, p0.z + vector.z),
            Vector3(p1.x + vector.x, vector.y, p1.z + vector.z),
            Vector3(p2.x + vector.x, vector.y, p2.z + vector.z),
            Vector3(p3.x + vector.x, vector.y, p3.z + vector.z)
        ]

    def upperPoints(self, local: bool = False) -> List[Vector3]:
        p0 = Vector3(self.width / 2.0, self.depth / 2.0, self.height)
        p1 = Vector3(-self.width / 2.0, self.depth / 2.0, self.height)
        p2 = Vector3(-self.width / 2.0, -self.depth / 2.0, self.height)
        p3 = Vector3(self.width / 2.0, -self.depth / 2.0, self.height)
        vector = Vector3()

        if not local:
            p0 = p0.rotate(-self.angle)
            p1 = p1.rotate(-self.angle)
            p2 = p2.rotate(-self.angle)
            p3 = p3.rotate(-self.angle)
            vector = self.position

        return [
            Vector3(p0.x + vector.x, vector.y + self.height, p0.z + vector.z),
            Vector3(p1.x + vector.x, vector.y + self.height, p1.z + vector.z),
            Vector3(p2.x + vector.x, vector.y + self.height, p2.z + vector.z),
            Vector3(p3.x + vector.x, vector.y + self.height, p3.z + vector.z)
        ]

    def frontPoints(self, local: bool = False) -> List[Vector3]:
        p0 = Vector3(self.width / 2.0, self.depth / 2.0, 0.0)
        p1 = Vector3(-self.width / 2.0, self.depth / 2.0, 0.0)
        vector = Vector3()

        if not local:
            p0 = p0.rotate(-self.angle)
            p1 = p1.rotate(-self.angle)
            vector = self.position

        return [
            Vector3(p0.x + vector.x, vector.y, p0.z + vector.z),
            Vector3(p1.x + vector.x, vector.y, p1.z + vector.z),
            Vector3(p1.x + vector.x, vector.y + self.height, p1.z + vector.z),
            Vector3(p0.x + vector.x, vector.y + self.height, p0.z + vector.z)
        ]

    def backPoints(self, local: bool = False) -> List[Vector3]:
        p2 = Vector3(-self.width / 2.0, -self.depth / 2.0, 0.0)
        p3 = Vector3(self.width / 2.0, -self.depth / 2.0, 0.0)
        vector = Vector3()

        if not local:
            p2 = p2.rotate(-self.angle)
            p3 = p3.rotate(-self.angle)
            vector = self.position

        return [
            Vector3(p2.x + vector.x, vector.y, p2.z + vector.z),
            Vector3(p3.x + vector.x, vector.y, p3.z + vector.z),
            Vector3(p3.x + vector.x, vector.y + self.height, p3.z + vector.z),
            Vector3(p2.x + vector.x, vector.y + self.height, p2.z + vector.z)
        ]

    def rightPoints(self, local: bool = False) -> List[Vector3]:
        p1 = Vector3(-self.width / 2.0, self.depth / 2.0, 0.0)
        p2 = Vector3(-self.width / 2.0, -self.depth / 2.0, 0.0)
        vector = Vector3()

        if not local:
            p1 = p1.rotate(-self.angle)
            p2 = p2.rotate(-self.angle)
            vector = self.position

        return [
            Vector3(p1.x + vector.x, vector.y, p1.z + vector.z),
            Vector3(p2.x + vector.x, vector.y, p2.z + vector.z),
            Vector3(p2.x + vector.x, vector.y + self.height, p2.z + vector.z),
            Vector3(p1.x + vector.x, vector.y + self.height, p1.z + vector.z)
        ]

    def leftPoints(self, local: bool = False) -> List[Vector3]:
        p0 = Vector3(self.width / 2.0, self.depth / 2.0, 0.0)
        p3 = Vector3(self.width / 2.0, -self.depth / 2.0, 0.0)
        vector = Vector3()

        if not local:
            p0 = p0.rotate(-self.angle)
            p3 = p3.rotate(-self.angle)
            vector = self.position

        return [
            Vector3(p3.x + vector.x, vector.y, p3.z + vector.z),
            Vector3(p0.x + vector.x, vector.y, p0.z + vector.z),
            Vector3(p0.x + vector.x, vector.y + self.height, p0.z + vector.z),
            Vector3(p3.x + vector.x, vector.y + self.height, p3.z + vector.z)
        ]

    def points(self, local: bool = False) -> List[Vector3]:
        p0 = Vector3(self.width / 2.0, self.depth / 2.0, 0.0)
        p1 = Vector3(-self.width / 2.0, self.depth / 2.0, 0.0)
        p2 = Vector3(-self.width / 2.0, -self.depth / 2.0, 0.0)
        p3 = Vector3(self.width / 2.0, -self.depth / 2.0, 0.0)
        vector = Vector3()

        if not local:
            p0 = p0.rotate(-self.angle)
            p1 = p1.rotate(-self.angle)
            p2 = p2.rotate(-self.angle)
            p3 = p3.rotate(-self.angle)
            vector = self.position

        return [
            Vector3(p0.x + vector.x, vector.y, p0.z + vector.z),
            Vector3(p1.x + vector.x, vector.y, p1.z + vector.z),
            Vector3(p2.x + vector.x, vector.y, p2.z + vector.z),
            Vector3(p3.x + vector.x, vector.y, p3.z + vector.z),
            Vector3(p0.x + vector.x, vector.y + self.height, p0.z + vector.z),
            Vector3(p1.x + vector.x, vector.y + self.height, p1.z + vector.z),
            Vector3(p2.x + vector.x, vector.y + self.height, p2.z + vector.z),
            Vector3(p3.x + vector.x, vector.y + self.height, p3.z + vector.z)
        ]

    # Distance Methods
    def distance(self, to: Vector3) -> float:
        return (to - self.center).length()

    def baseDistance(self, to: Vector3) -> float:
        point = Vector3(to.x, self.position.y, to.z)
        return (point - self.position).length()

    # Coordinate Transformation
    def intoLocal(self, pt: Vector3) -> Vector3:
        vx = pt.x - self.position.x
        vz = pt.z - self.position.z
        rotsin = math.sin(self.angle)
        rotcos = math.cos(self.angle)
        x = vx * rotcos - vz * rotsin
        z = vx * rotsin + vz * rotcos
        return Vector3(x, pt.y - self.position.y, z)

    def intoLocal_pts(self, pts: List[Vector3]) -> List[Vector3]:
        rotsin = math.sin(self.angle)
        rotcos = math.cos(self.angle)
        result = []
        for pt in pts:
            vx = pt.x - self.position.x
            vz = pt.z - self.position.z
            x = vx * rotcos - vz * rotsin
            z = vx * rotsin + vz * rotcos
            result.append(Vector3(x, pt.y - self.position.y, z))
        return result

    def rotate_pts(self, pts: List[Vector3], by: float) -> List[Vector3]:
        rotsin = math.sin(by)
        rotcos = math.cos(by)
        result = []
        for pt in pts:
            x = pt.x * rotcos - pt.z * rotsin
            z = pt.x * rotsin + pt.z * rotcos
            result.append(Vector3(x, pt.y, z))
        return result

    # Sector Methods
    def sectorOf(self, point: Vector3, nearBy: bool = False, epsilon: float = -100.0) -> BBoxSector:
        zone = BBoxSector()
        if nearBy:
            pt = Vector3(point.x, point.y - self.height / 2.0, point.z)
            distance = pt.length()
            if distance > self.nearbyRadius():
                return zone
        if epsilon > -99.0:
            delta = epsilon
        else: 
            delta = self.adjustment.maxGap
    
        if (
            point.x <= self.width / 2.0 + delta and
            -point.x <= self.width / 2.0 + delta and
            point.z <= self.depth / 2.0 + delta and
            -point.z <= self.depth / 2.0 + delta and
            point.y <= self.height + delta and
            point.y >= -delta
        ):
            zone.insert(BBoxSectorFlags.i)
            return zone

        if point.x + delta > self.width / 2.0:
            zone.insert(BBoxSectorFlags.l)
        elif -point.x + delta > self.width / 2.0:
            zone.insert(BBoxSectorFlags.r)

        if point.z + delta > self.depth / 2.0:
            zone.insert(BBoxSectorFlags.a)
        elif -point.z + delta > self.depth / 2.0:
            zone.insert(BBoxSectorFlags.b)

        if point.y + delta > self.height:
            zone.insert(BBoxSectorFlags.o)
        elif point.y - delta < 0.0:
            zone.insert(BBoxSectorFlags.u)

        return zone

    def nearbyRadius(self) -> float:
        if self.adjustment.nearbySchema == NearbySchema.fixed:
            return self.adjustment.nearbyFactor
        elif self.adjustment.nearbySchema == NearbySchema.circle:
            return min(self.baseradius * self.adjustment.nearbyFactor, self.adjustment.nearbyLimit)
        elif self.adjustment.nearbySchema == NearbySchema.sphere:
            return min(self.radius * self.adjustment.nearbyFactor, self.adjustment.nearbyLimit)
        elif self.adjustment.nearbySchema == NearbySchema.perimeter:
            return min((self.height + self.width) * self.adjustment.nearbyFactor, self.adjustment.nearbyLimit)
        elif self.adjustment.nearbySchema == NearbySchema.area:
            return min(self.height * self.width * self.adjustment.nearbyFactor, self.adjustment.nearbyLimit)
        return 0.0

    def sector_lengths(self, sector: BBoxSector = BBoxSector(BBoxSectorFlags.i)) -> Vector3:
            """
            Calculate the sector lengths based on the provided sector.

            Args:
                sector (BBoxSector, optional): The sector to calculate lengths for. Defaults to inside sector.

            Returns:
                Vector3: The lengths in x, y, z directions.
            """
            result = Vector3(x=self.width, y=self.height, z=self.depth)
            
            if sector.contains(BBoxSectorFlags.a) or sector.contains(BBoxSectorFlags.b):
                if self.adjustment.sectorSchema == "fixed":
                    result.z = self.adjustment.sectorFactor
                elif self.adjustment.sectorSchema == "area":
                    result.z = min(self.height * self.width * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "dimension":
                    result.z = min(self.depth * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "perimeter":
                    result.z = min((self.height + self.width) * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "nearby":
                    result.z = min(self.nearby_radius(), self.adjustment.sectorLimit)
            
            if sector.contains(BBoxSectorFlags.l) or sector.contains(BBoxSectorFlags.r):
                if self.adjustment.sectorSchema == "fixed":
                    result.x = self.adjustment.sectorFactor
                elif self.adjustment.sectorSchema == "area":
                    result.x = min(self.height * self.depth * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "dimension":
                    result.x = min(self.width * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "perimeter":
                    result.x = min((self.height + self.depth) * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "nearby":
                    result.x = min(self.nearby_radius(), self.adjustment.sectorLimit)
            
            if sector.contains(BBoxSectorFlags.o) or sector.contains(BBoxSectorFlags.u):
                if self.adjustment.sectorSchema == "fixed":
                    result.y = self.adjustment.sectorFactor
                elif self.adjustment.sectorSchema == "area":
                    result.y = min(self.width * self.depth * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "dimension":
                    result.y = min(self.height * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "perimeter":
                    result.y = min((self.width + self.depth) * self.adjustment.sectorFactor, self.adjustment.sectorLimit)
                elif self.adjustment.sectorSchema == "nearby":
                    result.y = min(self.nearby_radius(), self.adjustment.sectorLimit)
            
            return result

    # Topologies Method
    def topologies(self, subject: 'SpatialObject') -> List['SpatialRelation']:
        result: List['SpatialRelation'] = []
        relation: 'SpatialRelation'
        gap: float = 0.0
        minDistance: float = 0.0

        # Calculations in global world space
        center_vector = subject.center - self.center
        center_distance = center_vector.length()
        radius_sum = self.radius + subject.radius
        can_not_overlap = center_distance > radius_sum
        theta = subject.angle - self.angle
        is_disjoint = True
        is_connected = False

        # Calculations in local object space
        local_pts = self.intoLocal_pts(pts=subject.points())
        zones = [self.sectorOf(point=pt, nearBy=False, epsilon=0.00001) for pt in local_pts]
        local_center = self.intoLocal(pt=subject.center)
        center_zone = self.sectorOf(point=local_center, nearBy=False, epsilon=-self.adjustment.maxGap)

        # Nearness evaluated by center
        if center_distance < subject.nearbyRadius() + self.nearbyRadius():
            gap = center_distance
            minDistance = gap
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.near,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)
        else:
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.far,
                object=self,
                delta=center_distance,
                angle=theta
            )
            result.append(relation)

        # Basic adjacency in relation to center of object bbox
        if SpatialPredicate.l in center_zone:
            gap = float(local_center.x) - self.width / 2.0 - subject.width / 2.0
            minDistance = gap
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.left,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)
        elif SpatialPredicate.r in center_zone:
            gap = float(-local_center.x) - self.width / 2.0 - subject.width / 2.0
            minDistance = gap
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.right,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)

        if SpatialPredicate.a in center_zone:
            gap = float(local_center.z) - self.depth / 2.0 - subject.depth / 2.0
            minDistance = gap
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.ahead,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)
        elif SpatialPredicate.b in center_zone:
            gap = float(-local_center.z) - self.depth / 2.0 - subject.depth / 2.0
            minDistance = gap
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.behind,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)

        if SpatialPredicate.o in center_zone:
            gap = float(local_center.y) - subject.height / 2.0 - self.height
            minDistance = gap
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.above,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)
        elif SpatialPredicate.u in center_zone:
            gap = float(-local_center.y) - subject.height / 2.0
            minDistance = gap
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.below,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)

        # Side-related adjacency in relation to object bbox
        center_zone = self.sectorOf(point=local_center, nearBy=True, epsilon=-self.adjustment.maxGap)
        aligned = False  # orthogonal aligned
        is_beside = False

        if center_zone != SpatialPredicate.i:
            if abs(theta % (math.pi / 2.0)) < self.adjustment.maxAngleDelta:
                aligned = True

            min_val = float('inf')
            if SpatialPredicate.l in center_zone:
                for pt in local_pts:
                    min_val = min(min_val, float(pt.x) - self.width / 2.0)
                if min_val >= 0.0:
                    can_not_overlap = True
                    is_beside = True
                    minDistance = min_val
                    relation = SpatialRelation(
                        subject=subject,
                        predicate=SpatialPredicate.leftside,
                        object=self,
                        delta=min_val,
                        angle=theta
                    )
                    result.append(relation)
            elif SpatialPredicate.r in center_zone:
                for pt in local_pts:
                    min_val = min(min_val, float(-pt.x) - self.width / 2.0)
                if min_val >= 0.0:
                    can_not_overlap = True
                    is_beside = True
                    minDistance = min_val
                    relation = SpatialRelation(
                        subject=subject,
                        predicate=SpatialPredicate.rightside,
                        object=self,
                        delta=min_val,
                        angle=theta
                    )
                    result.append(relation)

            if SpatialPredicate.o in center_zone:
                for pt in local_pts:
                    min_val = min(min_val, float(pt.y) - self.height)
                if min_val >= 0.0:
                    can_not_overlap = True
                    minDistance = min_val
                    if min_val <= self.adjustment.maxGap:
                        relation = SpatialRelation(
                            subject=subject,
                            predicate=SpatialPredicate.ontop,
                            object=self,
                            delta=min_val,
                            angle=theta
                        )
                        result.append(relation)
                        if self.context and self.context.deduce.connectivity:
                            relation = SpatialRelation(
                                subject=subject,
                                predicate=SpatialPredicate.on,
                                object=self,
                                delta=min_val,
                                angle=theta
                            )
                            result.append(relation)
                    relation = SpatialRelation(
                        subject=subject,
                        predicate=SpatialPredicate.upperside,
                        object=self,
                        delta=min_val,
                        angle=theta
                    )
                    result.append(relation)
            elif SpatialPredicate.u in center_zone:
                for pt in local_pts:
                    min_val = min(min_val, float(-pt.y))
                if min_val >= 0.0:
                    can_not_overlap = True
                    minDistance = min_val
                    if min_val <= self.adjustment.maxGap:
                        relation = SpatialRelation(
                            subject=subject,
                            predicate=SpatialPredicate.beneath,
                            object=self,
                            delta=min_val,
                            angle=theta
                        )
                        result.append(relation)
                    relation = SpatialRelation(
                        subject=subject,
                        predicate=SpatialPredicate.lowerside,
                        object=self,
                        delta=min_val,
                        angle=theta
                    )
                    result.append(relation)

            if SpatialPredicate.a in center_zone:
                for pt in local_pts:
                    min_val = min(min_val, float(pt.z) - self.depth / 2.0)
                if min_val >= 0.0:
                    can_not_overlap = True
                    is_beside = True
                    minDistance = min_val
                    relation = SpatialRelation(
                        subject=subject,
                        predicate=SpatialPredicate.frontside,
                        object=self,
                        delta=min_val,
                        angle=theta
                    )
                    result.append(relation)
            elif SpatialPredicate.b in center_zone:
                for pt in local_pts:
                    min_val = min(min_val, float(-pt.z) - self.depth / 2.0)
                if min_val >= 0.0:
                    can_not_overlap = True
                    is_beside = True
                    minDistance = min_val
                    relation = SpatialRelation(
                        subject=subject,
                        predicate=SpatialPredicate.backside,
                        object=self,
                        delta=min_val,
                        angle=theta
                    )
                    result.append(relation)

            if is_beside:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.beside,
                    object=self,
                    delta=minDistance,
                    angle=theta
                )
                result.append(relation)

        # Check for assembly
        if all(zone.contains_flag(BBoxSectorFlags.i) for zone in zones):
            is_disjoint = False
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.inside,
                object=self,
                delta=center_distance,
                angle=theta
            )
            result.append(relation)
            if self.context and self.context.deduce.connectivity:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.in_,
                    object=self,
                    delta=center_distance,
                    angle=theta
                )
                result.append(relation)
        else:
            if (subject.radius - self.radius) > center_distance / 2.0 and \
               subject.width > self.width and \
               subject.height > self.height and \
               subject.depth > self.depth:
                is_disjoint = False
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.containing,
                    object=self,
                    delta=0.0,
                    angle=theta
                )
                result.append(relation)
            else:
                cnt = sum(1 for zone in zones if zone.contains_flag(BBoxSectorFlags.i))
                if cnt > 0 and not can_not_overlap:
                    is_disjoint = False
                    relation = SpatialRelation(
                        subject=subject,
                        predicate=SpatialPredicate.overlapping,
                        object=self,
                        delta=center_distance,
                        angle=theta
                    )
                    result.append(relation)

                crossings = 0
                minY = float(local_pts[0].y)
                maxY = float(local_pts[-1].y)
                minX = float('inf')
                maxX = -float('inf')
                minZ = float('inf')
                maxZ = -float('inf')

                for pt in local_pts:
                    minX = min(minX, float(pt.x))
                    maxX = max(maxX, float(pt.x))
                    minZ = min(minZ, float(pt.z))
                    maxZ = max(maxZ, float(pt.z))

                if not can_not_overlap:
                    if minX < -self.width / 2.0 and maxX > self.width / 2.0 and \
                       minZ < self.depth / 2.0 and maxZ > -self.depth / 2.0 and \
                       minY < self.height and maxY > 0:
                        crossings += 1
                    if minZ < -self.depth / 2.0 and maxZ > self.depth / 2.0 and \
                       minX < self.width / 2.0 and maxX > -self.width / 2.0 and \
                       minY < self.height and maxY > 0:
                        crossings += 1
                    if minY < 0.0 and maxY > self.height and \
                       minX < self.width / 2.0 and maxX > -self.width / 2.0 and \
                       minZ < self.depth / 2.0 and maxZ > -self.depth / 2.0:
                        crossings += 1
                    if crossings > 0:
                        is_disjoint = False
                        relation = SpatialRelation(
                            subject=subject,
                            predicate=SpatialPredicate.crossing,
                            object=self,
                            delta=center_distance,
                            angle=theta
                        )
                        result.append(relation)

                # ... [Continue translating the rest of the Swift function as needed] ...

        # Orientation Deduction
        if abs(theta) < self.adjustment.maxAngleDelta:
            gap = float(local_center.z)
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.aligned,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)

            front_gap = float(local_center.z) + subject.depth / 2.0 - self.depth / 2.0
            if abs(front_gap) < self.adjustment.maxGap:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.frontaligned,
                    object=self,
                    delta=front_gap,
                    angle=theta
                )
                result.append(relation)

            back_gap = float(local_center.z) - subject.depth / 2.0 + self.depth / 2.0
            if abs(back_gap) < self.adjustment.maxGap:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.backaligned,
                    object=self,
                    delta=back_gap,  # Corrected potential typo
                    angle=theta
                )
                result.append(relation)

            right_gap = float(local_center.x) - subject.width / 2.0 + self.width / 2.0
            if abs(right_gap) < self.adjustment.maxGap:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.rightaligned,
                    object=self,
                    delta=right_gap,  # Corrected potential typo
                    angle=theta
                )
                result.append(relation)

            left_gap = float(local_center.x) + subject.width / 2.0 - self.width / 2.0
            if abs(left_gap) < self.adjustment.maxGap:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.leftaligned,
                    object=self,
                    delta=left_gap,  # Corrected potential typo
                    angle=theta
                )
                result.append(relation)
        else:
            gap = center_distance
            if abs(theta % math.pi) < self.adjustment.maxAngleDelta:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.opposite,
                    object=self,
                    delta=gap,
                    angle=theta
                )
                result.append(relation)
            elif abs(theta % (math.pi / 2.0)) < self.adjustment.maxAngleDelta:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.orthogonal,
                    object=self,
                    delta=gap,
                    angle=theta
                )
                result.append(relation)

        # Visibility Deduction
        if self.context and self.context.deduce.visibility:
            if self.type == "Person" or (self.cause == ObjectCause.self_tracked and self.existence == SpatialExistence.real):
                rad = math.atan2(subject.center.x, subject.center.z)
                angle_deg = rad * 180.0 / math.pi
                hour_angle = 30.0  # 360.0 / 12.0
                if angle_deg < 0.0:
                    angle_deg -= hour_angle / 2.0
                else:
                    angle_deg += hour_angle / 2.0
                cnt = int(angle_deg / hour_angle)
                doit = True
                pred = SpatialPredicate.twelveoclock
                if cnt == 4:
                    pred = SpatialPredicate.eightoclock
                elif cnt == 3:
                    pred = SpatialPredicate.nineoclock
                elif cnt == 2:
                    pred = SpatialPredicate.tenoclock
                elif cnt == 1:
                    pred = SpatialPredicate.elevenoclock
                elif cnt == 0:
                    pred = SpatialPredicate.twelveoclock
                elif cnt == -1:
                    pred = SpatialPredicate.oneoclock
                elif cnt == -2:
                    pred = SpatialPredicate.twooclock
                elif cnt == -3:
                    pred = SpatialPredicate.threeoclock
                elif cnt == -4:
                    pred = SpatialPredicate.fouroclock
                else:
                    doit = False

                if doit:
                    relation = SpatialRelation(
                        subject=subject,
                        predicate=pred,
                        object=self,
                        delta=center_distance,
                        angle=rad
                    )
                    result.append(relation)
                    if center_distance <= 1.25:  # 70cm arm length plus 25cm shoulder plus 30cm leaning forward
                        relation = SpatialRelation(
                            subject=subject,
                            predicate=SpatialPredicate.tangible,
                            object=self,
                            delta=center_distance,
                            angle=rad
                        )
                        result.append(relation)

        return result

    # Similarities Method
    def similarities(self, subject: 'SpatialObject') -> List['SpatialRelation']:
        result: List['SpatialRelation'] = []
        relation: 'SpatialRelation'
        theta = subject.angle - self.angle
        val: float = 0.0
        minVal: float = 0.0
        maxVal: float = 0.0
        sameWidth: bool = False
        sameDepth: bool = False
        sameHeight: bool = False

        # Same Center
        val = (self.center - subject.center).length()
        if val < self.adjustment.maxGap:
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samecenter,
                object=self,
                delta=val,
                angle=theta
            )
            result.append(relation)

        # Same Position
        val = (self.position - subject.position).length()
        if val < self.adjustment.maxGap:
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.sameposition,
                object=self,
                delta=val,
                angle=theta
            )
            result.append(relation)

        # Same Width
        val = abs(self.width - subject.width)
        if val < self.adjustment.maxGap:
            sameWidth = True
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samewidth,
                object=self,
                delta=val,
                angle=theta
            )
            result.append(relation)

        # Same Depth
        val = abs(self.depth - subject.depth)
        if val < self.adjustment.maxGap:
            sameDepth = True
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samedepth,
                object=self,
                delta=val,
                angle=theta
            )
            result.append(relation)

        # Same Height
        val = abs(self.height - subject.height)
        if val < self.adjustment.maxGap:
            sameHeight = True
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.sameheight,
                object=self,
                delta=val,
                angle=theta
            )
            result.append(relation)

        # Same Perimeter
        val = subject.depth * subject.width
        minVal = (self.depth - self.adjustment.maxGap) + (self.width - self.adjustment.maxGap)
        maxVal = (self.depth + self.adjustment.maxGap) + (self.width + self.adjustment.maxGap)
        if minVal < val < maxVal:
            gap = self.depth * self.width - val
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.sameperimeter,
                object=self,
                delta=2.0 * gap,
                angle=theta
            )
            result.append(relation)

        # Same Cuboid
        if sameWidth and sameDepth and sameHeight:
            val = subject.volume - self.volume
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samecuboid,
                object=self,
                delta=val,
                angle=theta
            )
            result.append(relation)

        # Same Length
        val = abs(self.length - subject.length)
        if val < self.adjustment.maxGap:
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samelength,
                object=self,
                delta=val,
                angle=theta
            )
            result.append(relation)

        # Same Front
        val = subject.height * subject.width
        minVal = (self.height - self.adjustment.maxGap) * (self.width - self.adjustment.maxGap)
        maxVal = (self.height + self.adjustment.maxGap) * (self.width + self.adjustment.maxGap)
        if minVal < val < maxVal:
            gap = self.height * self.width - val
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samefront,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)

        # Same Side
        val = subject.height * subject.depth
        minVal = (self.height - self.adjustment.maxGap) * (self.depth - self.adjustment.maxGap)
        maxVal = (self.height + self.adjustment.maxGap) * (self.depth + self.adjustment.maxGap)
        if minVal < val < maxVal:
            gap = self.height * self.depth - val
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.sameside,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)

        # Same Footprint
        val = subject.width * subject.depth
        minVal = (self.width - self.adjustment.maxGap) * (self.depth - self.adjustment.maxGap)
        maxVal = (self.width + self.adjustment.maxGap) * (self.depth + self.adjustment.maxGap)
        if minVal < val < maxVal:
            gap = self.width * self.depth - val
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samefootprint,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)

        # Same Surface
        val = (subject.width ** 2) + (subject.depth ** 2) + (subject.height ** 2)
        minVal = ((self.width - self.adjustment.maxGap) ** 2) + ((self.depth - self.adjustment.maxGap) ** 2) + ((self.height - self.adjustment.maxGap) ** 2)
        maxVal = ((self.width + self.adjustment.maxGap) ** 2) + ((self.depth + self.adjustment.maxGap) ** 2) + ((self.height + self.adjustment.maxGap) ** 2)
        if minVal < val < maxVal:
            gap = ((self.width ** 2) + (self.depth ** 2) + (self.height ** 2)) - val
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samesurface,
                object=self,
                delta=2.0 * gap,
                angle=theta
            )
            result.append(relation)

        # Same Volume
        val = subject.width * subject.depth * subject.height
        minVal = (self.width - self.adjustment.maxGap) * (self.depth - self.adjustment.maxGap) * (self.height - self.adjustment.maxGap)
        maxVal = (self.width + self.adjustment.maxGap) * (self.depth + self.adjustment.maxGap) * (self.height + self.adjustment.maxGap)
        if minVal < val < maxVal:
            gap = self.width * self.depth * self.height - val
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.samevolume,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)
            val_distance = (self.position - subject.position).length()
            angle_diff = abs(self.angle - subject.angle)
            if sameWidth and sameDepth and sameHeight and val_distance < self.adjustment.maxGap and angle_diff < self.adjustment.maxAngleDelta:
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.congruent,
                    object=self,
                    delta=gap,
                    angle=theta
                )
                result.append(relation)

        # Same Shape
        if self.shape == subject.shape and self.shape != ObjectShape.unknown and subject.shape != ObjectShape.unknown:
            gap = self.width * self.depth * self.height - val
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.sameshape,
                object=self,
                delta=gap,
                angle=theta
            )
            result.append(relation)

        return result

    # Comparisons Method
    def comparisons(self, subject: 'SpatialObject') -> List['SpatialRelation']:
        result: List['SpatialRelation'] = []
        relation: 'SpatialRelation'
        theta = subject.angle - self.angle
        objVal: float = 0.0
        subjVal: float = 0.0
        diff: float = 0.0
        shorterAdded: bool = False

        # Longer or Shorter Length
        objVal = self.length
        subjVal = subject.length
        diff = subjVal - objVal
        if diff > (self.adjustment.maxGap ** 3):
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.longer,
                object=self,
                delta=diff,
                angle=theta
            )
            result.append(relation)
        elif -diff > (self.adjustment.maxGap ** 3):
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.shorter,
                object=self,
                delta=diff,
                angle=theta
            )
            result.append(relation)
            shorterAdded = True

        # Taller or Shorter Height
        objVal = self.height
        subjVal = subject.height
        diff = subjVal - objVal
        if diff > self.adjustment.maxGap:
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.taller,
                object=self,
                delta=diff,
                angle=theta
            )
            result.append(relation)
        elif -diff > self.adjustment.maxGap and not shorterAdded:
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.shorter,
                object=self,
                delta=diff,
                angle=theta
            )
            result.append(relation)

        # Wider or Thinner Footprint
        if subject.mainDirection() == 2:
            objVal = self.footprint
            subjVal = subject.footprint
            diff = subjVal - objVal
            if diff > (self.adjustment.maxGap ** 2):
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.wider,
                    object=self,
                    delta=diff,
                    angle=theta
                )
                result.append(relation)
            elif -diff > (self.adjustment.maxGap ** 2):
                relation = SpatialRelation(
                    subject=subject,
                    predicate=SpatialPredicate.thinner,
                    object=self,
                    delta=diff,
                    angle=theta
                )
                result.append(relation)

        # Same Volume
        objVal = self.volume
        subjVal = subject.volume
        diff = subjVal - objVal
        if (self.width * self.depth * self.height) - subjVal > (self.adjustment.maxGap ** 3):
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.bigger,
                object=self,
                delta=diff,
                angle=theta
            )
            result.append(relation)
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.exceeding,
                object=self,
                delta=diff,
                angle=theta
            )
            result.append(relation)
        elif -diff > (self.adjustment.maxGap ** 3):
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.smaller,
                object=self,
                delta=diff,
                angle=theta
            )
            result.append(relation)

        # Fitting
        if self.height > subject.height and self.footprint > subject.footprint:
            relation = SpatialRelation(
                subject=subject,
                predicate=SpatialPredicate.fitting,
                object=self,
                delta=diff,
                angle=theta
            )
            result.append(relation)

        return result

    # Sector Relation Method
    def sector(self, subject: 'SpatialObject', nearBy: bool = False, epsilon: float = 0.0) -> 'SpatialRelation':
        center_vector = subject.center - self.center
        center_distance = center_vector.length()
        local_center = self.intoLocal(pt=subject.center)
        center_zone = self.sectorOf(point=local_center, nearBy=nearBy, epsilon=epsilon)
        theta = subject.angle - self.angle
        pred = SpatialPredicate.named(str(center_zone))
        return SpatialRelation(
            subject=subject,
            predicate=pred,
            object=self,
            delta=center_distance,
            angle=theta
        )

    # As Seen Relations Method
    def asseen(self, subject: 'SpatialObject', observer: 'SpatialObject') -> List['SpatialRelation']:
        result: List['SpatialRelation'] = []
        pos_vector = subject.position - self.position
        pos_distance = pos_vector.length()
        radius_sum = self.baseradius + subject.baseradius

        # Check for nearby
        if pos_distance < subject.nearbyRadius() + self.nearbyRadius():
            center_object = observer.intoLocal(pt=self.center)
            center_subject = observer.intoLocal(pt=subject.center)
            if center_subject.z > 0.0 and center_object.z > 0.0:  # both are ahead of observer
                # Turn both by view angle to become normal to observer
                rad = math.atan2(center_object.x, center_object.z)
                rotated = self.rotate(pts=[center_object, center_subject], by=-rad)
                center_object = rotated[0]
                center_subject = rotated[1]
                xgap = float(center_subject.x - center_object.x)
                zgap = float(center_subject.z - center_object.z)

                if abs(xgap) > min(self.width / 2.0, self.depth / 2.0) and abs(zgap) < radius_sum:
                    if xgap > 0.0:
                        relation = SpatialRelation(
                            subject=subject,
                            predicate=SpatialPredicate.seenleft,
                            object=self,
                            delta=abs(xgap),
                            angle=0.0
                        )
                        result.append(relation)
                    else:
                        relation = SpatialRelation(
                            subject=subject,
                            predicate=SpatialPredicate.seenright,
                            object=self,
                            delta=abs(xgap),
                            angle=0.0
                        )
                        result.append(relation)

                if abs(zgap) > min(self.width / 2.0, self.depth / 2.0) and abs(xgap) < radius_sum:
                    if zgap > 0.0:
                        relation = SpatialRelation(
                            subject=subject,
                            predicate=SpatialPredicate.atrear,
                            object=self,
                            delta=abs(zgap),
                            angle=0.0
                        )
                        result.append(relation)
                    else:
                        relation = SpatialRelation(
                            subject=subject,
                            predicate=SpatialPredicate.infront,
                            object=self,
                            delta=abs(zgap),
                            angle=0.0
                        )
                        result.append(relation)

        return result

    # Relate Method
    def relate(
        self,
        subject: 'SpatialObject',
        topology: bool = False,
        similarity: bool = False,
        comparison: bool = False
    ) -> List['SpatialRelation']:
        result: List['SpatialRelation'] = []
        if topology or (self.context and self.context.deduce.topology) or (self.context and self.context.deduce.connectivity):
            result.extend(self.topologies(subject=subject))
        if similarity or (self.context and self.context.deduce.similarity):
            result.extend(self.similarities(subject=subject))
        if comparison or (self.context and self.context.deduce.comparability):
            result.extend(self.comparisons(subject=subject))
        if self.context and self.context.observer and self.context.deduce.visibility:
            result.extend(self.asseen(subject=subject, observer=self.context.observer))
        return result

    # Relation Value Method
    def relationValue(self, relval: str, pre: List[int]) -> float:
        list_split = [part.strip() for part in relval.split(".")]
        if len(list_split) != 2 and self.context is None:
            return 0.0
        predicate = list_split[0]
        attribute = list_split[1]
        result_val: float = 0.0
        for i in pre:
            if self.context:
                rels = self.context.relationsWith(i, predicate=predicate)
                for rel in rels:
                    if rel.subject == self:
                        if attribute == "angle":
                            result_val = rel.angle
                        else:
                            result_val = rel.delta
        return result_val
    
    def rotate(self, pts: List[Vector3], by: float) -> List[Vector3]:
        """
        Rotates a list of Vector3 points around the Y-axis by the specified angle.

        Args:
            pts (List[Vector3]): The list of points to rotate.
            by_angle (float): The rotation angle in radians.

        Returns:
            List[Vector3]: A new list of rotated points.
        """
        result = []
        rotsin = math.sin(by)
        rotcos = math.cos(by)

        for pt in pts:
            new_x = pt.x * rotcos - pt.z * rotsin
            new_z = pt.x * rotsin + pt.z * rotcos
            # Y remains unchanged during Y-axis rotation
            rotated_pt = Vector3(x=new_x, y=pt.y, z=new_z)
            result.append(rotated_pt)

        return result

    # Visualization Functions
    """
    def bboxCube(self, color: Any) -> 'SCNNode':
        name = self.id if not self.label else self.label
        group = SCNNode()
        group.name = self.id
        box = SCNBox(width=self.width, height=self.height, length=self.depth, chamferRadius=0.0)
        box.firstMaterial.diffuse.contents = color
        box.firstMaterial.transparency = 1.0 - color.alpha
        boxNode = SCNNode(geometry=box)
        group.addChildNode(boxNode)

        # Set name at front
        text = SCNText(string=name, extrusionDepth=0.0)
        text.firstMaterial.diffuse.contents = color
        text.firstMaterial.lightingModel = .constant
        textNode = SCNNode(geometry=text)
        fontSize = 0.005
        min_bound, max_bound = textNode.boundingBox
        textNode.position.x = -((max_bound.x - min_bound.x) / 2.0 * fontSize)
        textNode.position.y = -self.height * 0.48
        textNode.position.z = self.depth / 2.0 + 0.2
        textNode.renderingOrder = 1
        textNode.eulerAngles.x = -math.pi / 2.0
        textNode.scale = Vector3(fontSize, fontSize, fontSize)
        group.addChildNode(textNode)

        group.eulerAngles.y = self.angle
        group.position = self.center
        return group

    def nearbySphere(self) -> 'SCNNode':
        r = self.nearbyRadius()
        sphere = SCNSphere(radius=r)
        sphere.firstMaterial.diffuse.contents = (0.1, 0.1, 0.1, 0.5)  # CGColor(gray: 0.1, alpha: 0.5)
        sphere.firstMaterial.transparency = 0.5
        node = SCNNode(geometry=sphere)
        node.name = f"Nearby sphere of {self.label if self.label else self.id}"
        node.position = self.center
        return node

    def sectorCube(self, sector: BBoxSector = BBoxSector.i, withLabel: bool = False) -> 'SCNNode':
        dims = self.sectorLenghts(sector)
        box = SCNBox(width=dims.x, height=dims.y, length=dims.z, chamferRadius=0.0)
        box.firstMaterial.diffuse.contents = (0.1, 0.1, 0.1, 0.5)  # CGColor(gray: 0.1, alpha: 0.5)
        box.firstMaterial.transparency = 0.5
        node = SCNNode(geometry=box)
        node.name = f"{sector.description} sector"

        shift = Vector3()
        if SpatialTerms.o in sector:
            shift.y = (self.height + dims.y) / 2.0
        elif SpatialTerms.u in sector:
            shift.y = (-self.height - dims.y) / 2.0

        if SpatialTerms.r in sector:
            shift.x = (-self.width - dims.x) / 2.0
        elif SpatialTerms.l in sector:
            shift.x = (self.width + dims.x) / 2.0

        if SpatialTerms.a in sector:
            shift.z = (self.depth + dims.z) / 2.0
        elif SpatialTerms.b in sector:
            shift.z = (-self.depth - dims.z) / 2.0

        node.position = self.center + shift

        if withLabel:
            text = SCNText(string=str(sector), extrusionDepth=0.0)
            text.firstMaterial.diffuse.contents = (1.0, 1.0, 0.0, 0.0)  # CGColor(red: 1.0, green: 1.0, blue: 0.0, alpha: 0.0)
            text.firstMaterial.lightingModel = .constant
            textNode = SCNNode(geometry=text)
            fontSize = 0.01
            min_bound, max_bound = textNode.boundingBox
            textNode.position.x = -((max_bound.x - min_bound.x) / 2.0 * fontSize)
            textNode.position.y = -0.2  # Adjust as needed
            textNode.position.z = 0.0
            textNode.renderingOrder = 1
            textNode.scale = Vector3(fontSize, fontSize, fontSize)
            node.addChildNode(textNode)

        return node

    def pointNodes(self, pts: Optional[List[Vector3]] = None) -> 'SCNNode':
        points = self.points() if not pts else pts
        group = SCNNode()
        group.name = f"BBox corners of {self.label if self.label else self.id}"
        for point in points:
            geometry = SCNSphere(radius=0.01)
            geometry.firstMaterial.diffuse.contents = (0.0, 1.0, 0.0, 0.0)  # CGColor(red: 0.0, green: 1.0, blue: 0.0, alpha: 0.0)
            node = SCNNode(geometry=geometry)
            node.position = point
            group.addChildNode(node)
        return group

    @staticmethod
    def export3D(to_url: str, nodes: List['SCNNode']):
        scene = SCNScene()
        for node in nodes:
            scene.rootNode.addChildNode(node)
        scene.write(to=to_url, options={}, delegate=None, progressHandler=None)

    # ... [End of the SpatialObject class]
    """
    
--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/SpatialPredicate.py <==
# src/spatial_predicate.py

from enum import Enum
from dataclasses import dataclass
from typing import List


class SpatialPredicate(Enum):
    undefined = "undefined"
    # TOPOLOGY
    # proximity: near by
    near = "near"                # A is near to B, is close
    far = "far"                  # not near
    # directionality: in relation to position and orientation of object comparing center
    left = "left"
    right = "right"
    above = "above"
    below = "below"
    ahead = "ahead"
    behind = "behind"
    # adjacency: near by and at one side
    ontop = "on top"             # A is on top of B, very close contact
    beneath = "beneath"          # A is beneath of B, very close contact
    upperside = "at upper side"  # A is at upper side of B
    lowerside = "at lower side"  # A is at lower side of B
    leftside = "at left side"    # A is left side from B
    rightside = "at right side"  # A is right side from B
    frontside = "at front side"  # A is at front side of B, ahead
    backside = "at back side"    # A is at back side of B, behind
    # orientations
    orthogonal = "orthogonal"    # A is orthogonal to B, perpendicular to
    opposite = "opposite"        # opposite alignment
    aligned = "aligned"          # equally aligned orientation, parallel with
    frontaligned = "front aligned"  # same orientation and in same front plane
    backaligned = "back aligned"    # same orientation and in same back plane
    leftaligned = "left aligned"    # same orientation and in same left plane
    rightaligned = "right aligned"  # same orientation and in same right plane
    # assembly
    disjoint = "disjoint"            # no space in common
    inside = "inside"                # A is inside B
    containing = "containing"        # A is containing/contains B
    overlapping = "overlapping"      # (partially) overlapping, intersecting
    crossing = "crossing"            # intersecting by going through object
    # dividing = "dividing"          # crossing and dividing into parts (commented out in Swift)
    touching = "touching"            # touching edge-to-edge or edge-to-side = at edge
    meeting = "meeting"              # meeting side-by-side
    beside = "beside"                # near but not above or below
    fitting = "fitting"              # is fitting into
    exceeding = "exceeding"          # not fitting into
    # COMPARABILITY
    # comparisons
    smaller = "smaller"              # volume
    bigger = "bigger"                # syn: larger
    shorter = "shorter"              # length, height
    longer = "longer"                # length
    taller = "taller"                # height
    thinner = "thinner"              # width, depth --> footprint, syn: narrower
    wider = "wider"                  # syn: thicker
    # SIMILARITY
    # fuzzy comparison considering max deviation
    samewidth = "same width"
    sameheight = "same height"
    samedepth = "same depth"
    samelength = "same length"       # same length of main direction
    samefront = "same front face"
    sameside = "same side face"
    samefootprint = "same footprint"
    samevolume = "same volume"
    samecenter = "same center"
    sameposition = "same position"  # on base
    samecuboid = "same cuboid"
    congruent = "congruent"          # A is congruent to B, similar w,h,d, center and orientation, identical
    sameshape = "same shape"
    samesurface = "samesurface"
    # samecause is commented out
    # VISIBILITY
    # perspectives: seen from user / observer
    seenleft = "seen left"           # A is seen left of B by P
    seenright = "seen right"
    infront = "in front"             # (partially) covering
    atrear = "at rear"               # at back
    tangible = "tangible"             # within arm reach by user
    eightoclock = "eight o'clock"   # at 8 o'clock
    nineoclock = "nine o'clock"
    tenoclock = "ten o'clock"
    elevenoclock = "eleven o'clock"
    twelveoclock = "twelve o'clock"
    oneoclock = "one o'clock"
    twooclock = "two o'clock"
    threeoclock = "three o'clock"
    fouroclock = "four o'clock"
    # multistage relations
    secondleft = "second left"
    secondright = "second right"
    mostleft = "most left"
    mostright = "most right"
    # CONNECTIVITY
    # contacts
    on = "on"                        # on top of, unilateral
    at = "at"                        # attached and aligned with, unilateral
    by = "by"                        # connected, bilateral
    in_ = "in"                       # within, unilateral (note: 'in' is a reserved keyword in Python)
    # SECTORIALITY
    # center within bbox sector
    i = "i"
    a = "a"
    b = "b"
    l = "l"
    r = "r"
    o = "o"
    u = "u"
    al = "al"
    ar = "ar"
    bl = "bl"
    br = "br"
    ao = "ao"
    au = "au"
    bo = "bo"
    bu = "bu"
    lo = "lo"
    lu = "lu"
    ro = "ro"
    ru = "ru"
    alo = "alo"
    aro = "aro"
    blo = "blo"
    bro = "bro"
    alu = "alu"
    aru = "aru"
    blu = "blu"
    bru = "bru"
    # GEOGRAPHY
    # geographic direction
    north = "north"
    south = "south"
    east = "east"
    west = "west"
    northwest = "northwest"
    northeast = "northeast"
    southwest = "southwest"
    southeast = "southeast"

    @staticmethod
    def named(name: str) -> 'SpatialPredicate':
        for member in SpatialPredicate:
            if member.value == name:
                return member
        return SpatialPredicate.undefined


@dataclass
class PredicateTerm:
    code: SpatialPredicate
    predicate: str  # subject - predicate - object
    preposition: str
    synonym: str = ""
    reverse: str = ""  # object - predicate - subject
    antonym: str = ""  # if not predicate then antonym
    verb: str = "is"


class SpatialTerms:
    # List of PredicateTerm instances
    list: List[PredicateTerm] = [
        # TOPOLOGY
        # proximity in WCS and OCS
        PredicateTerm(code=SpatialPredicate.near, predicate="near", preposition="to", synonym="close", reverse="near", antonym="far", verb="is"),
        PredicateTerm(code=SpatialPredicate.far, predicate="far", preposition="from", synonym="close", reverse="far", antonym="near", verb="is"),
        # directionality in OCS
        PredicateTerm(code=SpatialPredicate.left, predicate="left", preposition="of", synonym="to the left"),
        PredicateTerm(code=SpatialPredicate.right, predicate="right", preposition="of", synonym="to the right"),
        PredicateTerm(code=SpatialPredicate.ahead, predicate="ahead", preposition="of", synonym="before"),
        PredicateTerm(code=SpatialPredicate.behind, predicate="behind", preposition="", synonym="after"),
        PredicateTerm(code=SpatialPredicate.above, predicate="above", preposition="", synonym="over", reverse="below"),
        PredicateTerm(code=SpatialPredicate.below, predicate="below", preposition="", synonym="under", reverse="above"),
        
        PredicateTerm(code=SpatialPredicate.l, predicate="left", preposition="of", synonym="to the left"),
        PredicateTerm(code=SpatialPredicate.r, predicate="right", preposition="of", synonym="to the right"),
        PredicateTerm(code=SpatialPredicate.a, predicate="ahead", preposition="of", synonym="before"),
        PredicateTerm(code=SpatialPredicate.b, predicate="behind", preposition="", synonym="after"),
        PredicateTerm(code=SpatialPredicate.o, predicate="above", preposition="", synonym="over", reverse="below"),
        PredicateTerm(code=SpatialPredicate.u, predicate="below", preposition="", synonym="under", reverse="above"),
        # adjacency in OCS
        PredicateTerm(code=SpatialPredicate.ontop, predicate="on top", preposition="of", synonym="at the top", reverse="beneath"),
        PredicateTerm(code=SpatialPredicate.beneath, predicate="beneath", preposition="", synonym="underneath", reverse="on top"),
        PredicateTerm(code=SpatialPredicate.upperside, predicate="at upper side", preposition="of", reverse="at lower side"),
        PredicateTerm(code=SpatialPredicate.lowerside, predicate="at lower side", preposition="of", reverse="at upper side"),
        PredicateTerm(code=SpatialPredicate.leftside, predicate="at left side", preposition="of", synonym="at left-hand side"),
        PredicateTerm(code=SpatialPredicate.rightside, predicate="at right side", preposition="of", synonym="at right-hand side"),
        PredicateTerm(code=SpatialPredicate.frontside, predicate="at front side", preposition="of", synonym="at forefront"),
        PredicateTerm(code=SpatialPredicate.backside, predicate="at back side", preposition="of", synonym="at rear side"),
        # orientations
        PredicateTerm(code=SpatialPredicate.aligned, predicate="aligned", preposition="with", synonym="parallel", reverse="aligned"),
        PredicateTerm(code=SpatialPredicate.orthogonal, predicate="orthogonal", preposition="to", synonym="perpendicular", reverse="orthogonal"),
        PredicateTerm(code=SpatialPredicate.opposite, predicate="opposite", preposition="", synonym="vis-a-vis", reverse="opposite"),
        # topology
        PredicateTerm(code=SpatialPredicate.inside, predicate="inside", preposition="", synonym="within", reverse="containing"),
        PredicateTerm(code=SpatialPredicate.containing, predicate="containing", preposition="", synonym="contains", reverse="inside"),
        PredicateTerm(code=SpatialPredicate.crossing, predicate="crossing", preposition=""),
        PredicateTerm(code=SpatialPredicate.overlapping, predicate="overlapping", preposition="", synonym="intersecting", reverse="overlapping", antonym="disjoint"),
        PredicateTerm(code=SpatialPredicate.disjoint, predicate="disjoint", preposition="to", reverse="disjoint", antonym="overlapping"),
        PredicateTerm(code=SpatialPredicate.touching, predicate="touching", preposition="with", reverse="touching"),
        PredicateTerm(code=SpatialPredicate.frontaligned, predicate="front aligned", preposition="with", reverse="front aligned"),
        PredicateTerm(code=SpatialPredicate.meeting, predicate="meeting", preposition="", reverse="meeting"),
        PredicateTerm(code=SpatialPredicate.beside, predicate="beside", preposition="", reverse="beside"),
        PredicateTerm(code=SpatialPredicate.fitting, predicate="fitting", preposition="into", reverse="exceeding"),
        PredicateTerm(code=SpatialPredicate.exceeding, predicate="exceeding", preposition="into", reverse="fitting"),
        # connectivity
        PredicateTerm(code=SpatialPredicate.on, predicate="on", preposition="", reverse="beneath"),
        PredicateTerm(code=SpatialPredicate.at, predicate="at", preposition="", reverse="meeting"),
        PredicateTerm(code=SpatialPredicate.by, predicate="by", preposition="", reverse="by"),
        PredicateTerm(code=SpatialPredicate.in_, predicate="in", preposition="", reverse="containing"),
        # similarity
        PredicateTerm(code=SpatialPredicate.samewidth, predicate="same width", preposition="as", synonym="similar width", reverse="same width", verb="has"),
        PredicateTerm(code=SpatialPredicate.sameheight, predicate="same height", preposition="as", synonym="similar height", reverse="same height", verb="has"),
        PredicateTerm(code=SpatialPredicate.samedepth, predicate="same depth", preposition="as", synonym="similar depth", reverse="same depth", verb="has"),
        PredicateTerm(code=SpatialPredicate.samelength, predicate="same length", preposition="as", synonym="similar length", reverse="same length", verb="has"),
        PredicateTerm(code=SpatialPredicate.samefootprint, predicate="same footprint", preposition="as", synonym="similar base area", reverse="same footprint", verb="has"),
        PredicateTerm(code=SpatialPredicate.samefront, predicate="same front face", preposition="as", synonym="similar front face", reverse="same front face", verb="has"),
        PredicateTerm(code=SpatialPredicate.sameside, predicate="same side face", preposition="as", synonym="similar side face", reverse="same side face", verb="has"),
        PredicateTerm(code=SpatialPredicate.samevolume, predicate="same volume", preposition="as", synonym="similar volume", reverse="same volume", verb="has"),
        PredicateTerm(code=SpatialPredicate.samecuboid, predicate="same cuboid", preposition="as", synonym="similar cuboid", reverse="same cuboid", verb="has"),
        PredicateTerm(code=SpatialPredicate.samecenter, predicate="same center", preposition="as", synonym="similar center", reverse="same center", verb="has"),
        PredicateTerm(code=SpatialPredicate.sameshape, predicate="same shape", preposition="as", synonym="similar shape", reverse="same shape", verb="has"),
        PredicateTerm(code=SpatialPredicate.congruent, predicate="congruent", preposition="as", reverse="congruent"),
        # comparisons
        PredicateTerm(code=SpatialPredicate.smaller, predicate="smaller", preposition="than", synonym="tinier", reverse="bigger"),
        PredicateTerm(code=SpatialPredicate.bigger, predicate="bigger", preposition="than", synonym="larger", reverse="smaller"),
        PredicateTerm(code=SpatialPredicate.shorter, predicate="shorter", preposition="than", reverse="longer"),
        PredicateTerm(code=SpatialPredicate.longer, predicate="longer", preposition="than", reverse="shorter"),
        PredicateTerm(code=SpatialPredicate.taller, predicate="taller", preposition="than", reverse="shorter"),
        PredicateTerm(code=SpatialPredicate.thinner, predicate="thinner", preposition="than", synonym="narrower", reverse="wider"),
        PredicateTerm(code=SpatialPredicate.wider, predicate="wider", preposition="than", synonym="thicker", reverse="thinner"),
    ]

    @staticmethod
    def predicate(name: str) -> SpatialPredicate:
        pred = SpatialPredicate.named(name)
        if pred != SpatialPredicate.undefined:
            return pred
        for term in SpatialTerms.list:
            if term.predicate == name:
                return term.code
            if term.synonym == name:
                return term.code
        return SpatialPredicate.undefined

    @staticmethod
    def term(code: SpatialPredicate) -> str:
        for term in SpatialTerms.list:
            if term.code == code:
                return term.predicate
        if code != SpatialPredicate.undefined:
            return code.value
        return "undefined"

    @staticmethod
    def termWithPreposition(code: SpatialPredicate) -> str:
        for term in SpatialTerms.list:
            if term.code == code:
                if term.preposition:
                    return f"{term.predicate} {term.preposition}"
                return term.predicate
        return "undefined"

    @staticmethod
    def termWithVerbAndPreposition(code: SpatialPredicate) -> str:
        for term in SpatialTerms.list:
            if term.code == code:
                if term.preposition:
                    return f"{term.verb} {term.predicate} {term.preposition}"
                return f"{term.verb} {term.predicate}"
        return "undefined"

    @staticmethod
    def symmetric(code: SpatialPredicate) -> bool:
        for term in SpatialTerms.list:
            if term.code == code:
                return term.predicate == term.reverse
        return False

    @staticmethod
    def inverse(predicate: str) -> SpatialPredicate:
        for term in SpatialTerms.list:
            if term.predicate == predicate and term.reverse:
                # Handle 'in' differently due to Python keyword
                if term.reverse == "in":
                    return SpatialPredicate.in_
                try:
                    return SpatialPredicate(term.reverse)
                except ValueError:
                    return SpatialPredicate.undefined
        return SpatialPredicate.undefined

    @staticmethod
    def negation(predicate: str) -> SpatialPredicate:
        for term in SpatialTerms.list:
            if term.predicate == predicate and term.antonym:
                try:
                    return SpatialPredicate(term.antonym)
                except ValueError:
                    return SpatialPredicate.undefined
        return SpatialPredicate.undefined


# Global lists combining SpatialPredicate enums
proximity: List[SpatialPredicate] = [SpatialPredicate.near, SpatialPredicate.far]
directionality: List[SpatialPredicate] = [SpatialPredicate.left, SpatialPredicate.right, SpatialPredicate.above, SpatialPredicate.below, SpatialPredicate.ahead, SpatialPredicate.behind]
adjacency: List[SpatialPredicate] = [
    SpatialPredicate.leftside, SpatialPredicate.rightside, SpatialPredicate.ontop, SpatialPredicate.beneath,
    SpatialPredicate.upperside, SpatialPredicate.lowerside, SpatialPredicate.frontside, SpatialPredicate.backside
]
orientations: List[SpatialPredicate] = [
    SpatialPredicate.orthogonal, SpatialPredicate.opposite, SpatialPredicate.aligned,
    SpatialPredicate.frontaligned, SpatialPredicate.backaligned, SpatialPredicate.rightaligned,
    SpatialPredicate.leftaligned
]
assembly: List[SpatialPredicate] = [
    SpatialPredicate.disjoint, SpatialPredicate.inside, SpatialPredicate.containing,
    SpatialPredicate.overlapping, SpatialPredicate.crossing, SpatialPredicate.touching,
    SpatialPredicate.meeting, SpatialPredicate.beside
]
topology: List[SpatialPredicate] = proximity + directionality + adjacency + orientations + assembly
contacts: List[SpatialPredicate] = [SpatialPredicate.on, SpatialPredicate.at, SpatialPredicate.by, SpatialPredicate.in_]
connectivity: List[SpatialPredicate] = contacts.copy()
comparability: List[SpatialPredicate] = [
    SpatialPredicate.smaller, SpatialPredicate.bigger, SpatialPredicate.shorter, SpatialPredicate.longer,
    SpatialPredicate.taller, SpatialPredicate.thinner, SpatialPredicate.wider, SpatialPredicate.fitting,
    SpatialPredicate.exceeding
]
similarity: List[SpatialPredicate] = [
    SpatialPredicate.sameheight, SpatialPredicate.samewidth, SpatialPredicate.samedepth,
    SpatialPredicate.samelength, SpatialPredicate.samefront, SpatialPredicate.sameside,
    SpatialPredicate.samefootprint, SpatialPredicate.samevolume, SpatialPredicate.samecenter,
    SpatialPredicate.samecuboid, SpatialPredicate.congruent, SpatialPredicate.sameshape
]
visibility: List[SpatialPredicate] = [
    SpatialPredicate.seenleft, SpatialPredicate.seenright, SpatialPredicate.infront,
    SpatialPredicate.atrear, SpatialPredicate.tangible, SpatialPredicate.eightoclock,
    SpatialPredicate.nineoclock, SpatialPredicate.tenoclock, SpatialPredicate.elevenoclock,
    SpatialPredicate.twelveoclock, SpatialPredicate.oneoclock, SpatialPredicate.twooclock,
    SpatialPredicate.threeoclock, SpatialPredicate.fouroclock
]
geography: List[SpatialPredicate] = [
    SpatialPredicate.north, SpatialPredicate.south, SpatialPredicate.east, SpatialPredicate.west,
    SpatialPredicate.northwest, SpatialPredicate.northeast, SpatialPredicate.southwest, SpatialPredicate.southeast
]
sectors: List[SpatialPredicate] = [
    SpatialPredicate.i, SpatialPredicate.a, SpatialPredicate.b, SpatialPredicate.o, SpatialPredicate.u,
    SpatialPredicate.l, SpatialPredicate.r, SpatialPredicate.al, SpatialPredicate.ar, SpatialPredicate.bl,
    SpatialPredicate.br, SpatialPredicate.ao, SpatialPredicate.au, SpatialPredicate.bo, SpatialPredicate.bu,
    SpatialPredicate.lo, SpatialPredicate.lu, SpatialPredicate.ro, SpatialPredicate.ru, SpatialPredicate.alo,
    SpatialPredicate.aro, SpatialPredicate.blo, SpatialPredicate.bro, SpatialPredicate.alu, SpatialPredicate.aru,
    SpatialPredicate.blu, SpatialPredicate.bru
]

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/SpatialReasoner.py <==
import datetime
from typing import List, Dict, Optional, Any
from pathlib import Path
import json

# Import the SpatialObject and dependencies
from src.vector3 import Vector3
from src.SpatialBasics import (
    NearbySchema,
    SectorSchema,
    SpatialAdjustment,
    SpatialPredicateCategories,
    ObjectConfidence,
    SpatialAtribute,
    SpatialExistence,
    ObjectCause,
    MotionState,
    ObjectShape,
    ObjectHandling,
    defaultAdjustment
)
from src.SpatialPredicate import (
    SpatialPredicate,
    PredicateTerm,
    SpatialTerms,
    proximity,
    directionality,
    adjacency,
    orientations,
    assembly,
    topology,
    contacts,
    connectivity,
    comparability,
    similarity,
    visibility,
    geography,
    sectors,
)
from .SpatialObject import SpatialObject
from .SpatialRelation import SpatialRelation
from .SpatialInference import SpatialInference


class SpatialReasoner:
    def __init__(self):
        # === Settings ===
        self.adjustment = SpatialAdjustment()
        self.deduce = SpatialPredicateCategories()
        self.north = Vector2(dx=0.0, dy=-1.0)  # North direction, e.g., defined by ARKit

        # === Data ===
        self.objects: List[SpatialObject] = []
        self.observer: Optional[SpatialObject] = None
        self.relMap: Dict[int, List[SpatialRelation]] = {}  # index: [SpatialRelation]
        self.chain: List[SpatialInference] = []
        self.base: Dict[str, Any] = {}  # Fact base for read/write access of expression evaluation
        self.snapTime: datetime.datetime = datetime.datetime.now()  # Load or update time of fact base

        # === Logging ===
        self.pipeline: str = ""  # Last used inference pipeline
        self.name: str = ""  # Used as title for log
        self.description: str = ""  # Used in log output
        self.logCnt: int = 0
        self.logFolder: Optional[Path] = None  # If None, Downloads folder will be used

    # === Loading Methods ===

    def load(self, objs: Optional[List[SpatialObject]] = None):
        """
        Load SpatialObjects into the reasoner.
        """
        if objs is not None:
            self.objects = objs
        self.observer = None
        self.relMap = {}
        self.base["objects"] = []

        if self.objects:
            objList = []
            for obj in self.objects:
                obj.context = self
                objList.append(obj.as_dict())
                if obj.observing:
                    self.observer = obj
            self.base["objects"] = objList

        self.snapTime = datetime.datetime.now()
        self.base["snaptime"] = self.snapTime.isoformat()

    def object_with_id(self, id: str) -> Optional[SpatialObject]:
        """
        Retrieve a SpatialObject by its ID.
        """
        for obj in self.objects:
            if obj.id == id:
                return obj
        return None

    def index_of_id(self, id: str) -> Optional[int]:
        """
        Retrieve the index of a SpatialObject by its ID.
        """
        for idx, obj in enumerate(self.objects):
            if obj.id == id:
                return idx
        return None

    def set_data(self, key: str, value: Any):
        """
        Set additional arbitrary data in the fact base.
        """
        dict_data = self.base.get("data", {})
        dict_data[key] = value
        self.base["data"] = dict_data

    def sync_to_objects(self):
        """
        Synchronize the fact base to SpatialObjects.
        """
        self.objects = []
        self.observer = None
        self.relMap = {}
        obj_dicts = self.base.get("objects", [])

        for obj_dict in obj_dicts:
            obj = SpatialObject(id=obj_dict["id"])
            obj.from_any(obj_dict)
            self.objects.append(obj)
            if obj.observing:
                self.observer = obj

    def load_from_dicts(self, objs: List[Dict[str, Any]]):
        """
        Load SpatialObjects from a list of dictionaries.
        """
        self.base["objects"] = objs
        self.sync_to_objects()
        self.base["snaptime"] = self.snapTime.isoformat()
        self.snapTime = datetime.datetime.now()

    def load_from_json(self, json_str: str):
        """
        Load SpatialObjects from a JSON string.
        """
        try:
            data = json.loads(json_str)
            if isinstance(data, list):
                self.load_from_dicts(data)
        except json.JSONDecodeError as e:
            print(f"JSON decode error: {e}")

    def take_snapshot(self) -> Dict[str, Any]:
        """
        Take a snapshot of the current fact base.
        """
        return self.base.copy()

    def load_snapshot(self, snapshot: Dict[str, Any]):
        """
        Load a snapshot into the fact base.
        """
        self.base = snapshot.copy()
        self.sync_to_objects()

    # === Recording and Backtracing ===

    def record(self, inference: SpatialInference):
        """
        Record a SpatialInference in the chain and fact base.
        """
        self.chain.append(inference)
        chain_list = self.base.get("chain", [])
        chain_list.append(inference.as_dict())
        self.base["chain"] = chain_list

    def backtrace(self) -> List[int]:
        """
        Backtrace to find the input indices of the last manipulating inference.
        """
        for inference in reversed(self.chain):
            if inference.is_manipulating():
                return inference.input
        return []

    # === Running the Inference Pipeline ===

    def run(self, pipeline: str) -> bool:
        """
        Run the spatial reasoning pipeline.
        """
        self.pipeline = pipeline
        self.logCnt = 0
        self.chain = []
        self.base["chain"] = []

        operations = [op.strip() for op in pipeline.split("|")]
        indices = list(range(len(self.objects)))

        for op in operations:
            if op.startswith("log(") and op.endswith(")"):
                content = op[4:-1].strip()
                self.log(content)
            elif op.startswith("adjust(") and op.endswith(")"):
                content = op[7:-1].strip()
                ok = self.adjust(content)
                if not ok:
                    self.log_error()
                    break
            elif op.startswith("deduce(") and op.endswith(")"):
                content = op[7:-1].strip()
                self.deduce_categories(content)
            else:
                input_chain = self.chain[-1].output if self.chain else indices
                inference = SpatialInference(input=input_chain, operation=op, reasoner=self)
                self.record(inference)
                if inference.has_failed():
                    self.log_error()
                    break

        self.sync_to_objects()

        if self.chain:
            return self.chain[-1].succeeded
        elif "log(" in pipeline:
            return True
        return False

    # === Retrieving Results ===

    def result(self) -> List[SpatialObject]:
        """
        Retrieve the resulting SpatialObjects after running the pipeline.
        """
        if self.chain:
            return [self.objects[idx] for idx in self.chain[-1].output]
        return []

    # === Logging Methods ===

    def log_error(self):
        """
        Log the last error from the inference chain.
        """
        if self.chain:
            print(self.chain[-1].error)

    @staticmethod
    def print_relations(relations: List[SpatialRelation]):
        """
        Print a list of SpatialRelations in a readable format.
        """
        for relation in relations:
            print(f"{relation.subject.id} {relation.predicate} {relation.object.id} | Δ:{relation.delta:.2f}  α:{relation.yaw:.1f}°")

    def relations_of(self, idx: int) -> List[SpatialRelation]:
        """
        Retrieve all SpatialRelations for the object at the given index.
        """
        if idx in self.relMap:
            return self.relMap[idx]
        relations = []
        for subject in self.objects:
            if subject != self.objects[idx]:
                relations.extend(self.objects[idx].relate(subject=subject))
        self.relMap[idx] = relations
        return relations

    def relations_with(self, obj_idx: int, predicate: str) -> List[SpatialRelation]:
        """
        Retrieve SpatialRelations with a specific predicate for the object at obj_idx.
        """
        rels = []
        if obj_idx >= 0:
            for relation in self.relations_of(obj_idx):
                if relation.predicate.value == predicate:
                    rels.append(relation)
        return rels

    def does(self, subject: SpatialObject, have: str, with_obj_idx: int) -> bool:
        """
        Check if the subject has a specific predicate relation with the object at with_obj_idx.
        """
        for relation in self.relations_of(with_obj_idx):
            if relation.subject == subject and relation.predicate.value == have:
                return True
        return False

    # === Adjustment and Deduction ===

    def adjust(self, settings: str) -> bool:
        """
        Adjust the reasoning engine's settings based on a settings string.
        """
        error = ""
        settings_list = [s.strip() for s in settings.split(";")]

        for setting in settings_list:
            parts = setting.split()
            first = parts[0] if len(parts) > 0 else ""
            second = parts[1] if len(parts) > 1 else ""
            number = parts[2] if len(parts) > 2 else ""

            if first == "max":
                if second == "gap":
                    if number:
                        try:
                            val = float(number)
                            self.adjustment.maxGap = val
                        except ValueError:
                            error = f"Invalid max gap value: {number}"
                elif second in ["angle", "delta"]:
                    if number:
                        try:
                            val = float(number)
                            self.adjustment.maxAngleDelta = val
                        except ValueError:
                            error = f"Invalid max angle value: {number}"
                else:
                    error = f"Unknown max setting: {second}"

            elif first == "sector":
                set_factor = True
                if second == "fixed":
                    self.adjustment.sectorSchema = "fixed"
                elif second == "dimension":
                    self.adjustment.sectorSchema = "dimension"
                elif second == "perimeter":
                    self.adjustment.sectorSchema = "perimeter"
                elif second == "area":
                    self.adjustment.sectorSchema = "area"
                elif second == "nearby":
                    self.adjustment.sectorSchema = "nearby"
                elif second == "factor":
                    set_factor = True
                elif second == "limit":
                    set_factor = False
                    if number:
                        try:
                            val = float(number)
                            self.adjustment.sectorLimit = val
                        except ValueError:
                            error = f"Invalid sector limit value: {number}"
                else:
                    error = f"Unknown sector setting: {second}"

                if set_factor and number:
                    try:
                        val = float(number)
                        self.adjustment.sectorLimit = val
                    except ValueError:
                        error = f"Invalid sector limit value: {number}"

            elif first == "nearby":
                set_factor = True
                if second == "fixed":
                    self.adjustment.nearbySchema = "fixed"
                elif second == "circle":
                    self.adjustment.nearbySchema = "circle"
                elif second == "sphere":
                    self.adjustment.nearbySchema = "sphere"
                elif second == "perimeter":
                    self.adjustment.nearbySchema = "perimeter"
                elif second == "area":
                    self.adjustment.nearbySchema = "area"
                elif second == "factor":
                    set_factor = True
                elif second == "limit":
                    set_factor = False
                    if number:
                        try:
                            val = float(number)
                            self.adjustment.nearbyLimit = val
                        except ValueError:
                            error = f"Invalid nearby limit value: {number}"
                else:
                    error = f"Unknown nearby setting: {second}"

                if set_factor and number:
                    try:
                        val = float(number)
                        self.adjustment.nearbyFactor = val
                    except ValueError:
                        error = f"Invalid nearby factor value: {number}"

            elif first == "long":
                if second == "ratio":
                    if number:
                        try:
                            val = float(number)
                            self.adjustment.longRatio = val
                        except ValueError:
                            error = f"Invalid long ratio value: {number}"

            elif first == "thin":
                if second == "ratio":
                    if number:
                        try:
                            val = float(number)
                            self.adjustment.thinRatio = val
                        except ValueError:
                            error = f"Invalid thin ratio value: {number}"

            else:
                error = f"Unknown adjust setting: {first}"

        if error:
            print(f"Error: {error}")
            error_state = SpatialInference(input=[], operation=f"adjust({settings})", reasoner=self)
            error_state.error = error
            return False
        return True

    def deduce_categories(self, categories: str):
        """
        Deduce which spatial predicate categories to enable based on input string.
        """
        self.deduce.topology = "topo" in categories
        self.deduce.connectivity = "connect" in categories
        self.deduce.comparability = "compar" in categories
        self.deduce.similarity = "simil" in categories
        self.deduce.sectoriality = "sector" in categories
        self.deduce.visibility = "visib" in categories
        self.deduce.geography = "geo" in categories

    # === Logging Implementation ===

    def log(self, predicates: str):
        """
        Log the specified predicates. Excludes visualization-related logging.
        """
        # Initialize log folder if not set
        if self.logFolder is None:
            try:
                self.logFolder = Path.home() / "Downloads"
                if not self.logFolder.exists():
                    self.logFolder = Path.home()
            except Exception as e:
                self.logFolder = Path.home()

        self.logCnt += 1
        all_indices = list(range(len(self.objects)))
        indices = self.chain[-1].output if self.chain else all_indices
        predicates_list = [p.strip() for p in predicates.split(" ")]

        if "base" in predicates_list:
            predicates_list.remove("base")
            self.log_base()
        if "3D" in predicates_list:
            predicates_list.remove("3D")
            # Visualization code for 3D logging is omitted as per instruction

        # Build Markdown content
        md = f"# {self.name if self.name else 'Spatial Reasoning Log'}\n"
        md += f"{self.description if self.description else ''}\n\n"
        md += "## Inference Pipeline\n\n```\n" + self.pipeline + "\n```\n\n"
        md += "## Inference Chain\n\n```\n"
        for idx, inference in enumerate(self.chain):
            if idx > 0:
                md += "| "
            md += f"{inference.operation}  ->  {inference.output}\n"
        md += "```\n\n"

        md += "## Spatial Objects\n\n### Fact Base\n\n"
        for i in all_indices:
            obj = self.objects[i]
            md += f"{i}.  __{obj.id}__: {obj.desc()}\n"

        md += "\n### Resulting Objects (Output)\n\n"
        mmd_objs = ""
        mmd_rels = ""
        mmd_contacts = ""
        rels = ""
        for i in indices:
            obj = self.objects[i]
            mmd_objs += f"    {obj.id}\n"
            md += f"{i}.  __{obj.id}__: {obj.desc()}\n"

            for relation in self.relations_of(i):
                do_add = False
                if predicates_list:
                    if relation.predicate.value in predicates_list:
                        do_add = True
                else:
                    do_add = True

                if do_add:
                    left_link = " -- "
                    if relation.predicate.is_symmetric():
                        left_link = " <-- "
                        search_by = f"{relation.object.id}{left_link}{relation.predicate.value} --> {relation.subject.id}"
                        if search_by in mmd_rels:
                            do_add = False
                    if do_add:
                        mmd_rels += f"    {relation.subject.id}{left_link}{relation.predicate.value} --> {relation.object.id}\n"

                if relation.predicate in SpatialPredicateCategories.contacts:
                    do_add_contact = True
                    left_link = " -- "
                    if relation.predicate == SpatialPredicate.by:
                        left_link = " <-- "
                        search_by = f"{relation.object.id}{left_link}{relation.predicate.value} --> {relation.subject.id}"
                        if search_by in mmd_contacts:
                            do_add_contact = False
                    if do_add_contact:
                        mmd_contacts += f"    {relation.subject.id}{left_link}{relation.predicate.value} --> {relation.object.id}\n"

                if relation.predicate in SpatialPredicateCategories.contacts:
                    rels += f"* {relation.desc()}\n"

        # Append Spatial Relations Graph
        if mmd_rels:
            md += "\n## Spatial Relations Graph\n\n```mermaid\ngraph LR;\n" + mmd_objs + mmd_rels + "```\n"

        # Append Connectivity Graph
        if mmd_contacts:
            md += "\n## Connectivity Graph\n\n```mermaid\ngraph TD;\n" + mmd_contacts + "```\n"

        # Append Spatial Relations List
        md += "\n## Spatial Relations\n\n" + rels + "\n"

        # Determine log file name
        multiple_logs = pipeline.count("log(") > 2
        counter_str = str(self.logCnt) if multiple_logs else ""
        log_filename = f"log{counter_str}.md"
        log_path = self.logFolder / log_filename

        # Write Markdown to file
        try:
            with open(log_path, "w", encoding="utf-16") as f:
                f.write(md)
        except Exception as e:
            print(f"Error writing log file: {e}")

    def log_base(self):
        """
        Log the fact base to a JSON file.
        """
        try:
            log_base_path = self.logFolder / "logBase.json"
            with open(log_base_path, "w", encoding="utf-8") as f:
                json.dump(self.base, f, indent=4)
        except Exception as e:
            print(f"Error writing log base: {e}")

    # === Visualization Methods ===
    # All visualization-related methods (e.g., log3D) are omitted as per instruction.

    # === Additional Methods ===

    @staticmethod
    def print_relations(relations: List[SpatialRelation]):
        """
        Print a list of SpatialRelations in a readable format.
        """
        for relation in relations:
            print(f"{relation.subject.id} {relation.predicate} {relation.object.id} | Δ:{relation.delta:.2f}  α:{relation.yaw:.1f}°")
--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/SpatialRelation.py <==
# SpatialRelation.py

from typing import Any
from typing import TYPE_CHECKING
import math

if TYPE_CHECKING:
    from .SpatialObject import SpatialObject  # Prevents circular import at runtime

from .SpatialPredicate import SpatialPredicate, SpatialTerms


class SpatialRelation:
    """
    Represents a spatial relation as a triple: subject - predicate - object.
    """

    def __init__(
        self,
        subject: 'SpatialObject',
        predicate: SpatialPredicate,
        object: 'SpatialObject',
        delta: float = 0.0,
        angle: float = 0.0
    ):
        """
        Initializes a SpatialRelation instance.

        Args:
            subject (SpatialObject): The target subject.
            predicate (SpatialPredicate): The spatial predicate matching spatial condition and max deviation.
            object (SpatialObject): The reference object.
            delta (float, optional): Difference of predicate value between subject and object, e.g., distance. Defaults to 0.0.
            angle (float, optional): Angle deviation of object direction in radians. Defaults to 0.0.
        """
        self.subject: 'SpatialObject' = subject
        self.predicate: SpatialPredicate = predicate
        self.object: 'SpatialObject' = object
        self.delta: float = delta
        self.angle: float = angle

    @property
    def yaw(self) -> float:
        """
        Calculates the angle deviation in degrees.

        Returns:
            float: Angle deviation in degrees.
        """
        return self.angle * 180.0 / math.pi

    @property
    def subject_id(self) -> str:
        """
        Retrieves the ID of the subject.

        Returns:
            str: The subject's ID.
        """
        return self.subject.id

    @property
    def object_id(self) -> str:
        """
        Retrieves the ID of the object.

        Returns:
            str: The object's ID.
        """
        return self.object.id

    def desc(self) -> str:
        """
        Generates a descriptive string for the spatial relation.

        The format is:
        "<subject> <predicate> <object> (<predicate_raw_value> Δ:<delta> 𝜶:<yaw>°)"

        Returns:
            str: The descriptive string of the spatial relation.
        """
        # Determine subject representation
        if self.subject.label:
            subject_str = self.subject.label
        elif self.subject.type:
            subject_str = self.subject.type
        else:
            subject_str = self.subject.id

        # Get predicate as verb + preposition using SpatialTerms
        predicate_str = SpatialTerms.term_with_verb_and_preposition(self.predicate)

        # Determine object representation
        if self.object.label:
            object_str = self.object.label
        elif self.object.type:
            object_str = self.object.type
        else:
            object_str = self.object.id

        # Format the description string
        description = (
            f"{subject_str} {predicate_str} {object_str} "
            f"({self.predicate.value} Δ:{self.delta:.2f} 𝜶:{self.yaw:.1f}°)"
        )
        return description

    def __repr__(self) -> str:
        """
        Returns the official string representation of the SpatialRelation.

        Returns:
            str: Official string representation.
        """
        return (
            f"SpatialRelation(subject={self.subject}, "
            f"predicate={self.predicate}, object={self.object}, "
            f"delta={self.delta}, angle={self.angle})"
        )
--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/Vector2.py <==
import numpy as np
from typing import List, Optional

class Vector2:
    def __init__(self, x: float = 0.0, y: float = 0.0):
        """
        Initialize a 2D vector.
        
        Args:
            x (float): The x-component of the vector. Defaults to 0.0.
            y (float): The y-component of the vector. Defaults to 0.0.
        """
        self.array = np.array([x, y], dtype=float)
        self.dx = x
        self.dy = y
    
    @property
    def x(self) -> float:
        """Get the x-component of the vector."""
        return self.array[0]
    
    @property
    def y(self) -> float:
        """Get the y-component of the vector."""
        return self.array[1]
    
    def __add__(self, other: 'Vector2') -> 'Vector2':
        """
        Add two vectors.
        
        Args:
            other (Vector2): The vector to add.
        
        Returns:
            Vector2: The resulting vector.
        """
        if not isinstance(other, Vector2):
            raise TypeError("Addition is supported between Vector2 instances only.")
        return Vector2(*(self.array + other.array))
    
    def __sub__(self, other: 'Vector2') -> 'Vector2':
        """
        Subtract one vector from another.
        
        Args:
            other (Vector2): The vector to subtract.
        
        Returns:
            Vector2: The resulting vector.
        """
        if not isinstance(other, Vector2):
            raise TypeError("Subtraction is supported between Vector2 instances only.")
        return Vector2(*(self.array - other.array))
    
    def dot(self, other: 'Vector2') -> float:
        """
        Compute the dot product of two vectors.
        
        Args:
            other (Vector2): The other vector.
        
        Returns:
            float: The dot product.
        """
        if not isinstance(other, Vector2):
            raise TypeError("Dot product is supported between Vector2 instances only.")
        return np.dot(self.array, other.array)
    
    def magnitude(self) -> float:
        """
        Compute the magnitude (length) of the vector.
        
        Returns:
            float: The magnitude.
        """
        return np.linalg.norm(self.array)
    
    def length(self) -> float:
        """
        Alias for magnitude.
        
        Returns:
            float: The magnitude.
        """
        return self.magnitude()
    
    def normalize(self) -> 'Vector2':
        """
        Normalize the vector (make it unit length).
        
        Returns:
            Vector2: The normalized vector.
        """
        norm = self.magnitude()
        if norm == 0:
            return Vector2()
        return Vector2(*(self.array / norm))
    
    def rotate(self, radians: float) -> 'Vector2':
        """
        Rotate the vector by a given angle in radians.
        
        Args:
            radians (float): The angle to rotate the vector.
        
        Returns:
            Vector2: The rotated vector.
        """
        rotation_matrix = np.array([
            [np.cos(radians), -np.sin(radians)],
            [np.sin(radians),  np.cos(radians)]
        ])
        rotated = rotation_matrix.dot(self.array)
        return Vector2(*rotated)
    
    def distance_to(self, other: 'Vector2') -> float:
        """
        Compute the distance to another vector.
        
        Args:
            other (Vector2): The other vector.
        
        Returns:
            float: The distance.
        """
        if not isinstance(other, Vector2):
            raise TypeError("Distance can only be computed between Vector2 instances.")
        return np.linalg.norm(self.array - other.array)
    
    def nearest(self, points: List['Vector2']) -> List['Vector2']:
        """
        Find the nearest point(s) to this vector from a list of points.
        
        Args:
            points (List[Vector2]): The list of points to search.
        
        Returns:
            List[Vector2]: A list of the nearest point(s).
        """
        if not points:
            return []
        distances = [self.distance_to(p) for p in points]
        min_distance = min(distances)
        nearest_points = [p for p, d in zip(points, distances) if np.isclose(d, min_distance)]
        return nearest_points
    
    def __eq__(self, other: Any) -> bool:
        """
        Check if two vectors are equal within a tolerance.
        
        Args:
            other (Any): The object to compare.
        
        Returns:
            bool: True if vectors are equal, False otherwise.
        """
        if not isinstance(other, Vector2):
            return False
        return np.allclose(self.array, other.array, atol=1e-8)
    
    def __repr__(self) -> str:
        """
        Return the string representation of the vector.
        
        Returns:
            str: The string representation.
        """
        return f"Vector2(x={self.x}, y={self.y})"

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/__init__.py <==
from .BBoxSector import BBoxSector, BBoxSectorFlags

from .SpatialBasics import (
    NearbySchema,
    SectorSchema,
    SpatialAdjustment,
    SpatialPredicateCategories,
    ObjectConfidence,
    SpatialAtribute,
    SpatialExistence,
    ObjectCause,
    MotionState,
    ObjectShape,
    ObjectHandling
)

from .SpatialPredicate import (
    SpatialPredicate,
    PredicateTerm,
    SpatialTerms,
    proximity,
    directionality,
    adjacency,
    orientations,
    assembly,
    topology,
    contacts,
    connectivity,
    comparability,
    similarity,
    visibility,
    geography,
    sectors
)

from .SpatialObject import ( SpatialObject )
from .SpatialRelation import SpatialRelation 
--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/__pycache__/BBoxSector.cpython-312.pyc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/__pycache__/SpatialBasics.cpython-312.pyc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/__pycache__/SpatialInference.cpython-312.pyc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/__pycache__/SpatialObject.cpython-312.pyc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/__pycache__/SpatialPredicate.cpython-312.pyc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/__pycache__/SpatialReasoner.cpython-312.pyc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/__pycache__/SpatialRelation.cpython-312.pyc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/__pycache__/__init__.cpython-312.pyc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/__pycache__/vector3.cpython-312.pyc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/src/vector3.py <==
# src/vector3.py
import numpy as np

class Vector3:
    def __init__(self, x=0.0, y=0.0, z=0.0):
        self.array = np.array([x, y, z], dtype=float)
    
    @property
    def x(self):
        return self.array[0]
    
    @property
    def y(self):
        return self.array[1]
    
    @property
    def z(self):
        return self.array[2]
    
    def __add__(self, other):
        return Vector3(*(self.array + other.array))
    
    def __sub__(self, other):
        #if other is not Vector3 but number
        if not isinstance(other, Vector3):
            return Vector3(*(self.array - other))
        return Vector3(*(self.array - other.array))
    def __truediv__(self, other):
        return Vector3(*(self.array / other))

    
    def dot(self, other):
        return np.dot(self.array, other.array)
    
    def cross(self, other):
        return Vector3(*np.cross(self.array, other.array))
    
    def magnitude(self):
        return np.linalg.norm(self.array)
    
    def length(self):
        return self.magnitude()
    
    def normalize(self):
        norm = self.magnitude()
        if norm == 0:
            return Vector3()
        return Vector3(*(self.array / norm))
    
    def rotate(self, radians):
        rotation_matrix = np.array([
            [np.cos(radians), 0, np.sin(radians)],
            [0, 1, 0],
            [-np.sin(radians), 0, np.cos(radians)]
        ])
        rotated = rotation_matrix.dot(self.array)
        return Vector3(*rotated)
    
    def __eq__(self, other):
        if not isinstance(other, Vector3):
            return False
        return np.allclose(self.array, other.array, atol=1e-8)
    
    def __repr__(self):
        return f"Vector3(x={self.x}, y={self.y}, z={self.z})"

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/tests/BBoxSector_test.py <==
# tests/BBoxSector_test.py

import unittest
from src.BBoxSector import BBoxSector, BBoxSectorFlags

class TestBBoxSector(unittest.TestCase):
    def test_individual_flags(self):
        for flag in BBoxSectorFlags:
            if flag == BBoxSectorFlags.none:
                continue
            sector = BBoxSector(flag)
            self.assertEqual(str(sector), BBoxSector.debug_descriptions.get(flag, "".join([name for name, member in BBoxSectorFlags.__members__.items() if member == flag])))

    def test_composite_flags(self):
        composite_flags = [
            BBoxSectorFlags.al,
            BBoxSectorFlags.ar,
            BBoxSectorFlags.bl,
            BBoxSectorFlags.br,
            # ... [Add all composite flags as needed] ...
        ]
        for flag in composite_flags:
            sector = BBoxSector(flag)
            self.assertEqual(str(sector), BBoxSector.debug_descriptions.get(flag, "unknown"))

    def test_invalid_combination(self):
        sector = BBoxSector()
        sector.insert(BBoxSectorFlags.a)
        sector.insert(BBoxSectorFlags.b)
        sector.insert(BBoxSectorFlags.l)
        self.assertEqual(str(sector), "abl")

    def test_str_representation_invalid(self):
        sector = BBoxSector()
        sector.insert(BBoxSectorFlags.a)
        sector.insert(BBoxSectorFlags.b)
        sector.insert(BBoxSectorFlags.l)
        sector.insert(BBoxSectorFlags.r)
        self.assertEqual(str(sector), "ablr")

    def test_no_sector(self):
        sector = BBoxSector()
        self.assertEqual(str(sector), "no sector")

    def test_inside_sector(self):
        sector = BBoxSector(BBoxSectorFlags.i)
        self.assertEqual(str(sector), "i")
        self.assertEqual(sector.divergencies(), 0)

    def test_multiple_flags(self):
        sector = BBoxSector()
        sector.insert(BBoxSectorFlags.a)
        sector.insert(BBoxSectorFlags.l)
        sector.insert(BBoxSectorFlags.o)
        self.assertEqual(str(sector), "alo")
        self.assertEqual(sector.divergencies(), 3)

    # ... [Additional tests as needed] ...

# Run the tests
if __name__ == '__main__':
    unittest.main()

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/tests/Sector_test.py <==
# tests/SectorTests.py

import unittest
import math

# Import the necessary classes and enums from your modules
from src.vector3 import Vector3
from src.SpatialObject import SpatialObject
from src.SpatialPredicate import SpatialPredicate
from src.SpatialRelation import SpatialRelation
from src.BBoxSector import BBoxSector, BBoxSectorFlags

class TestBBoxSectors(unittest.TestCase):
    def setUp(self):
        """
        Initialize SpatialObject instances before each test.
        """
        # Object against which subjects are tested
        self.obj = SpatialObject(
            id="obj",
            position=Vector3(x=0, y=0.0, z=0),
            width=1.1,
            height=1.1,
            depth=1.1
        )
    
    def test_sector_o(self):
        """
        Test that a subject located in sector 'o' (over) of an object is correctly identified.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=0, y=1.61, z=0.1),
            width=0.5,
            height=0.5,
            depth=0.5
        )
        
        relation = self.obj.sector(subject)
        self.assertEqual(relation.predicate, SpatialPredicate.o)
    
    def test_sector_al(self):
        """
        Test that a subject located in sector 'al' (ahead-left) of an object is correctly identified.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=1.2, y=0.21, z=1.4),
            width=0.5,
            height=0.5,
            depth=0.5
        )
        relation = self.obj.sector(subject)
        self.assertEqual(relation.predicate, SpatialPredicate.al)
    
    def test_sector_bru(self):
        """
        Test that a subject located in sector 'bru' (behind-right-under) of an object is correctly identified.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=-1.2, y=-1.21, z=-1.4),
            width=0.5,
            height=0.5,
            depth=0.5
        )
        relation = self.obj.sector(subject)
        self.assertEqual(relation.predicate, SpatialPredicate.bru)
    
    def test_sector_i(self):
        """
        Test that a subject located in sector 'i' (inside) of an object is correctly identified.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=0, y=0, z=0.1),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        relation = self.obj.sector(subject)
        self.assertEqual(relation.predicate, SpatialPredicate.i)
    
    def test_nosector_not_nearby(self):
        """
        Test that a subject not located within the nearby sector of an object is correctly identified as 'undefined'.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=8, y=0, z=0.1),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        
        relation = self.obj.sector(subject, nearBy=True)
        self.assertEqual(relation.predicate, SpatialPredicate.undefined)

# Run the tests
if __name__ == '__main__':
    unittest.main()

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/tests/SpatialBasics_test.py <==
# tests/SpatialBasics_test.py

import unittest
from src.SpatialBasics import (
    NearbySchema,
    SectorSchema,
    SpatialAdjustment,
    SpatialPredicateCategories,
    ObjectConfidence,
    SpatialAtribute,
    SpatialExistence,
    ObjectCause,
    MotionState,
    ObjectShape,
    ObjectHandling
)
import math


class TestNearbySchema(unittest.TestCase):
    def test_enum_members(self):
        """Test that all NearbySchema members exist and have correct values."""
        self.assertEqual(NearbySchema.fixed.value, "fixed")
        self.assertEqual(NearbySchema.circle.value, "circle")
        self.assertEqual(NearbySchema.sphere.value, "sphere")
        self.assertEqual(NearbySchema.perimeter.value, "perimeter")
        self.assertEqual(NearbySchema.area.value, "area")

    def test_named_method_valid(self):
        """Test the named method with valid names."""
        self.assertEqual(NearbySchema.named("fixed"), NearbySchema.fixed)
        self.assertEqual(NearbySchema.named("circle"), NearbySchema.circle)
        self.assertEqual(NearbySchema.named("sphere"), NearbySchema.sphere)
        self.assertEqual(NearbySchema.named("perimeter"), NearbySchema.perimeter)
        self.assertEqual(NearbySchema.named("area"), NearbySchema.area)

    def test_named_method_invalid(self):
        """Test the named method with invalid names."""
        self.assertIsNone(NearbySchema.named("invalid"))
        self.assertIsNone(NearbySchema.named(""))
        self.assertIsNone(NearbySchema.named("Fixed"))  # Case-sensitive


class TestSectorSchema(unittest.TestCase):
    def test_enum_members(self):
        """Test that all SectorSchema members exist and have correct values."""
        self.assertEqual(SectorSchema.fixed.value, "fixed")
        self.assertEqual(SectorSchema.dimension.value, "dimension")
        self.assertEqual(SectorSchema.perimeter.value, "perimeter")
        self.assertEqual(SectorSchema.area.value, "area")
        self.assertEqual(SectorSchema.nearby.value, "nearby")

    def test_named_method_valid(self):
        """Test the named method with valid names."""
        self.assertEqual(SectorSchema.named("fixed"), SectorSchema.fixed)
        self.assertEqual(SectorSchema.named("dimension"), SectorSchema.dimension)
        self.assertEqual(SectorSchema.named("perimeter"), SectorSchema.perimeter)
        self.assertEqual(SectorSchema.named("area"), SectorSchema.area)
        self.assertEqual(SectorSchema.named("nearby"), SectorSchema.nearby)

    def test_named_method_invalid(self):
        """Test the named method with invalid names."""
        self.assertIsNone(SectorSchema.named("invalid"))
        self.assertIsNone(SectorSchema.named(""))
        self.assertIsNone(SectorSchema.named("Fixed"))  # Case-sensitive


class TestSpatialAdjustment(unittest.TestCase):
    def test_default_initialization(self):
        """Test the default initialization of SpatialAdjustment."""
        adjustment = SpatialAdjustment()
        self.assertEqual(adjustment.maxGap, 0.02)
        self.assertAlmostEqual(adjustment.maxAngleDelta, 0.05 * math.pi)
        self.assertEqual(adjustment.sectorSchema, SectorSchema.nearby)
        self.assertEqual(adjustment.sectorFactor, 1.0)
        self.assertEqual(adjustment.sectorLimit, 2.5)
        self.assertEqual(adjustment.nearbySchema, NearbySchema.circle)
        self.assertEqual(adjustment.nearbyFactor, 2.0)
        self.assertEqual(adjustment.nearbyLimit, 2.5)
        self.assertEqual(adjustment.longRatio, 4.0)
        self.assertEqual(adjustment.thinRatio, 10.0)

    def test_custom_initialization(self):
        """Test custom initialization of SpatialAdjustment."""
        adjustment = SpatialAdjustment(
            maxGap=0.05,
            angle=math.pi / 4,
            sector_schema=SectorSchema.fixed,
            sector_factor=2.0,
            sector_limit=5.0,
            nearby_schema=NearbySchema.sphere,
            nearby_factor=3.0,
            nearby_limit=6.0
        )
        self.assertEqual(adjustment.maxGap, 0.05)
        self.assertAlmostEqual(adjustment.maxAngleDelta, math.pi / 4)
        self.assertEqual(adjustment.sectorSchema, SectorSchema.fixed)
        self.assertEqual(adjustment.sectorFactor, 2.0)
        self.assertEqual(adjustment.sectorLimit, 5.0)
        self.assertEqual(adjustment.nearbySchema, NearbySchema.sphere)
        self.assertEqual(adjustment.nearbyFactor, 3.0)
        self.assertEqual(adjustment.nearbyLimit, 6.0)
        self.assertEqual(adjustment.longRatio, 4.0)
        self.assertEqual(adjustment.thinRatio, 10.0)

    def test_yaw_property(self):
        """Test the yaw property of SpatialAdjustment."""
        adjustment = SpatialAdjustment(angle=math.pi / 6)
        self.assertAlmostEqual(adjustment.yaw, 30.0)  # 30 degrees

    def test_setYaw_method(self):
        """Test the setYaw method of SpatialAdjustment."""
        adjustment = SpatialAdjustment()
        adjustment.setYaw(45.0)
        self.assertAlmostEqual(adjustment.maxAngleDelta, math.pi / 4)
        self.assertAlmostEqual(adjustment.yaw, 45.0)


class TestSpatialPredicateCategories(unittest.TestCase):
    def test_default_initialization(self):
        """Test the default initialization of SpatialPredicateCategories."""
        categories = SpatialPredicateCategories()
        self.assertTrue(categories.topology)
        self.assertTrue(categories.connectivity)
        self.assertFalse(categories.comparability)
        self.assertFalse(categories.similarity)
        self.assertFalse(categories.sectoriality)
        self.assertFalse(categories.visibility)
        self.assertFalse(categories.geography)

    def test_custom_initialization(self):
        """Test custom initialization of SpatialPredicateCategories."""
        categories = SpatialPredicateCategories()
        categories.topology = False
        categories.connectivity = False
        categories.comparability = True
        categories.similarity = True
        categories.sectoriality = True
        categories.visibility = True
        categories.geography = True

        self.assertFalse(categories.topology)
        self.assertFalse(categories.connectivity)
        self.assertTrue(categories.comparability)
        self.assertTrue(categories.similarity)
        self.assertTrue(categories.sectoriality)
        self.assertTrue(categories.visibility)
        self.assertTrue(categories.geography)


class TestObjectConfidence(unittest.TestCase):
    def test_default_initialization(self):
        """Test the default initialization of ObjectConfidence."""
        confidence = ObjectConfidence()
        self.assertEqual(confidence.pose, 0.0)
        self.assertEqual(confidence.dimension, 0.0)
        self.assertEqual(confidence.label, 0.0)
        self.assertEqual(confidence.look, 0.0)
        self.assertEqual(confidence.value, 0.0)
        self.assertEqual(confidence.spatial, 0.0)

    def test_setValue_method(self):
        """Test the setValue method of ObjectConfidence."""
        confidence = ObjectConfidence()
        confidence.setValue(0.6)
        self.assertEqual(confidence.pose, 0.6)
        self.assertEqual(confidence.dimension, 0.6)
        self.assertEqual(confidence.label, 0.6)
        self.assertEqual(confidence.value, 0.6)
        self.assertEqual(confidence.spatial, 0.6)

    def test_setSpatial_method(self):
        """Test the setSpatial method of ObjectConfidence."""
        confidence = ObjectConfidence()
        confidence.setSpatial(0.8)
        self.assertEqual(confidence.pose, 0.8)
        self.assertEqual(confidence.dimension, 0.8)
        self.assertEqual(confidence.spatial, 0.8)

    def test_asDict_method(self):
        """Test the asDict method of ObjectConfidence."""
        confidence = ObjectConfidence()
        confidence.pose = 0.7
        confidence.dimension = 0.5
        confidence.label = 0.9
        confidence.look = 0.3
        expected_dict = {
            "pose": 0.7,
            "dimension": 0.5,
            "label": 0.9,
            "look": 0.3
        }
        self.assertEqual(confidence.asDict(), expected_dict)


class TestSpatialAtribute(unittest.TestCase):
    def test_enum_members(self):
        """Test that all SpatialAtribute members exist and have correct values."""
        self.assertEqual(SpatialAtribute.none.value, "none")
        self.assertEqual(SpatialAtribute.width.value, "width")
        self.assertEqual(SpatialAtribute.height.value, "height")
        self.assertEqual(SpatialAtribute.depth.value, "depth")
        self.assertEqual(SpatialAtribute.length.value, "length")
        self.assertEqual(SpatialAtribute.angle.value, "angle")
        self.assertEqual(SpatialAtribute.yaw.value, "yaw")
        self.assertEqual(SpatialAtribute.azimuth.value, "azimuth")
        self.assertEqual(SpatialAtribute.footprint.value, "footprint")
        self.assertEqual(SpatialAtribute.frontface.value, "frontface")
        self.assertEqual(SpatialAtribute.sideface.value, "sideface")
        self.assertEqual(SpatialAtribute.surface.value, "surface")
        self.assertEqual(SpatialAtribute.volume.value, "volume")
        self.assertEqual(SpatialAtribute.perimeter.value, "perimeter")
        self.assertEqual(SpatialAtribute.baseradius.value, "baseradius")
        self.assertEqual(SpatialAtribute.radius.value, "radius")
        self.assertEqual(SpatialAtribute.speed.value, "speed")
        self.assertEqual(SpatialAtribute.confidence.value, "confidence")
        self.assertEqual(SpatialAtribute.lifespan.value, "lifespan")


class TestSpatialExistence(unittest.TestCase):
    def test_enum_members(self):
        """Test that all SpatialExistence members exist and have correct values."""
        self.assertEqual(SpatialExistence.undefined.value, "undefined")
        self.assertEqual(SpatialExistence.real.value, "real")
        self.assertEqual(SpatialExistence.virtual.value, "virtual")
        self.assertEqual(SpatialExistence.conceptual.value, "conceptual")
        self.assertEqual(SpatialExistence.aggregational.value, "aggregational")

    def test_named_method_valid(self):
        """Test the named method with valid names."""
        self.assertEqual(SpatialExistence.named("real"), SpatialExistence.real)
        self.assertEqual(SpatialExistence.named("virtual"), SpatialExistence.virtual)
        self.assertEqual(SpatialExistence.named("conceptual"), SpatialExistence.conceptual)
        self.assertEqual(SpatialExistence.named("aggregational"), SpatialExistence.aggregational)
        self.assertEqual(SpatialExistence.named("undefined"), SpatialExistence.undefined)

    def test_named_method_invalid(self):
        """Test the named method with invalid names."""
        self.assertEqual(SpatialExistence.named("invalid"), SpatialExistence.undefined)
        self.assertEqual(SpatialExistence.named(""), SpatialExistence.undefined)
        self.assertEqual(SpatialExistence.named("Real"), SpatialExistence.undefined)  # Case-sensitive


class TestObjectCause(unittest.TestCase):
    def test_enum_members(self):
        """Test that all ObjectCause members exist and have correct values."""
        self.assertEqual(ObjectCause.unknown.value, "unknown")
        self.assertEqual(ObjectCause.plane_detected.value, "plane_detected")
        self.assertEqual(ObjectCause.object_detected.value, "object_detected")
        self.assertEqual(ObjectCause.self_tracked.value, "self_tracked")
        self.assertEqual(ObjectCause.user_captured.value, "user_captured")
        self.assertEqual(ObjectCause.user_generated.value, "user_generated")
        self.assertEqual(ObjectCause.rule_produced.value, "rule_produced")
        self.assertEqual(ObjectCause.remote_created.value, "remote_created")

    def test_named_method_valid(self):
        """Test the named method with valid names."""
        self.assertEqual(ObjectCause.named("unknown"), ObjectCause.unknown)
        self.assertEqual(ObjectCause.named("plane_detected"), ObjectCause.plane_detected)
        self.assertEqual(ObjectCause.named("object_detected"), ObjectCause.object_detected)
        self.assertEqual(ObjectCause.named("self_tracked"), ObjectCause.self_tracked)
        self.assertEqual(ObjectCause.named("user_captured"), ObjectCause.user_captured)
        self.assertEqual(ObjectCause.named("user_generated"), ObjectCause.user_generated)
        self.assertEqual(ObjectCause.named("rule_produced"), ObjectCause.rule_produced)
        self.assertEqual(ObjectCause.named("remote_created"), ObjectCause.remote_created)

    def test_named_method_invalid(self):
        """Test the named method with invalid names."""
        self.assertEqual(ObjectCause.named("invalid"), ObjectCause.unknown)
        self.assertEqual(ObjectCause.named(""), ObjectCause.unknown)
        self.assertEqual(ObjectCause.named("Unknown"), ObjectCause.unknown)  # Case-sensitive


class TestMotionState(unittest.TestCase):
    def test_enum_members(self):
        """Test that all MotionState members exist and have correct values."""
        self.assertEqual(MotionState.unknown.value, "unknown")
        self.assertEqual(MotionState.stationary.value, "stationary")
        self.assertEqual(MotionState.idle.value, "idle")
        self.assertEqual(MotionState.moving.value, "moving")


class TestObjectShape(unittest.TestCase):
    def test_enum_members(self):
        """Test that all ObjectShape members exist and have correct values."""
        self.assertEqual(ObjectShape.unknown.value, "unknown")
        self.assertEqual(ObjectShape.planar.value, "planar")
        self.assertEqual(ObjectShape.cubical.value, "cubical")
        self.assertEqual(ObjectShape.spherical.value, "spherical")
        self.assertEqual(ObjectShape.cylindrical.value, "cylindrical")
        self.assertEqual(ObjectShape.conical.value, "conical")
        self.assertEqual(ObjectShape.irregular.value, "irregular")
        self.assertEqual(ObjectShape.changing.value, "changing")

    def test_named_method_valid(self):
        """Test the named method with valid names."""
        self.assertEqual(ObjectShape.named("unknown"), ObjectShape.unknown)
        self.assertEqual(ObjectShape.named("planar"), ObjectShape.planar)
        self.assertEqual(ObjectShape.named("cubical"), ObjectShape.cubical)
        self.assertEqual(ObjectShape.named("spherical"), ObjectShape.spherical)
        self.assertEqual(ObjectShape.named("cylindrical"), ObjectShape.cylindrical)
        self.assertEqual(ObjectShape.named("conical"), ObjectShape.conical)
        self.assertEqual(ObjectShape.named("irregular"), ObjectShape.irregular)
        self.assertEqual(ObjectShape.named("changing"), ObjectShape.changing)

    def test_named_method_invalid(self):
        """Test the named method with invalid names."""
        self.assertEqual(ObjectShape.named("invalid"), ObjectShape.unknown)
        self.assertEqual(ObjectShape.named(""), ObjectShape.unknown)
        self.assertEqual(ObjectShape.named("Unknown"), ObjectShape.unknown)  # Case-sensitive


class TestObjectHandling(unittest.TestCase):
    def test_enum_members(self):
        """Test that all ObjectHandling members exist and have correct values."""
        self.assertEqual(ObjectHandling.none.value, "none")
        self.assertEqual(ObjectHandling.movable.value, "movable")
        self.assertEqual(ObjectHandling.slidable.value, "slidable")
        self.assertEqual(ObjectHandling.liftable.value, "liftable")
        self.assertEqual(ObjectHandling.portable.value, "portable")
        self.assertEqual(ObjectHandling.rotatable.value, "rotatable")
        self.assertEqual(ObjectHandling.openable.value, "openable")

    def test_enum_members_tangible_not_present(self):
        """Test that 'tangible' is not present in ObjectHandling."""
        self.assertNotIn('tangible', ObjectHandling.__members__)

    def test_enum_usage(self):
        """Test usage of ObjectHandling enum."""
        handling = ObjectHandling.movable
        self.assertEqual(handling, ObjectHandling.movable)
        self.assertEqual(handling.value, "movable")

    def test_enum_invalid_access(self):
        """Test accessing an invalid member of ObjectHandling."""
        with self.assertRaises(KeyError):
            ObjectHandling['tangible']


if __name__ == '__main__':
    unittest.main()

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/tests/SpatialObject_test.py <==
# tests/SpatialObject_test.py

import unittest
import math
from unittest.mock import MagicMock
import datetime  # Added import for datetime operations

# Import the necessary classes and enums from your modules
from src.vector3 import Vector3
from src.SpatialBasics import (
    NearbySchema,
    SectorSchema,
    SpatialAdjustment,
    SpatialPredicateCategories,
    ObjectConfidence,
    SpatialAtribute,
    SpatialExistence,
    ObjectCause,
    MotionState,
    ObjectShape,
    ObjectHandling,
    defaultAdjustment
)
from src.SpatialPredicate import (
    SpatialPredicate,
    PredicateTerm,
    SpatialTerms,
    proximity,
    directionality,
    adjacency,
    orientations,
    assembly,
    topology,
    contacts,
    connectivity,
    comparability,
    similarity,
    visibility,
    geography,
    sectors,
)
from src.SpatialReasoner import SpatialReasoner
from src.SpatialRelation import SpatialRelation  # Ensure correct import
from src.SpatialObject import SpatialObject
from src.BBoxSector import BBoxSector, BBoxSectorFlags  # Import BBoxSector and its flags


class TestSpatialObjectInitialization(unittest.TestCase):
    def test_default_initialization(self):
        obj = SpatialObject(
            id="obj1",
            position=Vector3(),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        self.assertEqual(obj.id, "obj1")
        self.assertEqual(obj.position, Vector3())
        self.assertEqual(obj.width, 1.0)
        self.assertEqual(obj.height, 1.0)
        self.assertEqual(obj.depth, 1.0)
        self.assertEqual(obj.angle, 0.0)
        self.assertEqual(obj.label, "")
        self.assertEqual(obj.confidence.value, 0.0)
        self.assertFalse(obj.immobile)
        self.assertEqual(obj.shape, ObjectShape.unknown)
        self.assertFalse(obj.visible)
        self.assertFalse(obj.focused)

    def test_custom_initialization(self):
        position = Vector3(1.0, 2.0, 3.0)
        obj = SpatialObject(
            id="obj2",
            position=position,
            width=2.0,
            height=3.0,
            depth=4.0,
            angle=math.pi / 4,
            label="Test Object",
            confidence=0.8
        )
        self.assertEqual(obj.id, "obj2")
        self.assertEqual(obj.position, position)
        self.assertEqual(obj.width, 2.0)
        self.assertEqual(obj.height, 3.0)
        self.assertEqual(obj.depth, 4.0)
        self.assertAlmostEqual(obj.angle, math.pi / 4, places=5)
        self.assertEqual(obj.label, "Test Object")
        self.assertAlmostEqual(obj.confidence.value, 0.8, places=5)
        self.assertFalse(obj.immobile)
        self.assertEqual(obj.shape, ObjectShape.unknown)
        self.assertFalse(obj.visible)
        self.assertFalse(obj.focused)


class TestSpatialObjectDerivedProperties(unittest.TestCase):
    def setUp(self):
        self.obj = SpatialObject(
            id="obj3",
            position=Vector3(0.0, 0.0, 0.0),
            width=2.0,
            height=4.0,
            depth=6.0
        )

    def test_center_property(self):
        # Assuming center is calculated as (position.x + width/2, position.y + height/2, position.z + depth/2)
        expected_center = Vector3(1.0, 2.0, 3.0)
        self.assertEqual(self.obj.center, expected_center)

    def test_volume_property(self):
        expected_volume = 2.0 * 4.0 * 6.0
        self.assertEqual(self.obj.volume, expected_volume)

    def test_footprint_property(self):
        expected_footprint = 2.0 * 6.0  # width * depth
        self.assertEqual(self.obj.footprint, expected_footprint)

    def test_surface_property(self):
        # Surface area = 2*(wh + wd + hd)
        expected_surface = 2.0 * (4.0 * 2.0 + 6.0 * 2.0 + 6.0 * 4.0)
        self.assertEqual(self.obj.surface, expected_surface)

    def test_radius_property(self):
        # Assuming radius is the magnitude from the center to a corner
        expected_radius = Vector3(1.0, 2.0, 3.0).magnitude()
        self.assertAlmostEqual(self.obj.radius, expected_radius, places=5)

    def test_baseradius_property(self):
        # Assuming baseradius is the hypotenuse of width/2 and depth/2
        expected_baseradius = math.hypot(2.0 / 2.0, 6.0 / 2.0)
        self.assertAlmostEqual(self.obj.baseradius, expected_baseradius, places=5)


class TestSpatialObjectPositionMethods(unittest.TestCase):
    def setUp(self):
        self.obj = SpatialObject(
            id="obj4",
            position=Vector3(1.0, 1.0, 1.0),
            width=2.0,
            height=2.0,
            depth=2.0,
            confidence=0.0
        )
        self.obj.adjustment = SpatialAdjustment()

    def test_set_position_updates_velocity(self):
        # Mock the 'updated' timestamp to simulate elapsed time
        self.obj.updated = datetime.datetime.now() - datetime.timedelta(seconds=1)
        new_position = Vector3(2.0, 2.0, 2.0)
        self.obj.setPosition(new_position)
        expected_velocity = (new_position - Vector3(1.0, 1.0, 1.0)) / 1.0  # Assuming delta time is 1 second
        self.assertAlmostEqual(self.obj.velocity, expected_velocity,places=2)
        self.assertAlmostEqual(self.obj.position, new_position,places=2)

    def test_set_position_without_movement(self):
        # If the object is immobile, velocity should not update
        self.obj.immobile = True
        self.obj.updated = datetime.datetime.now() - datetime.timedelta(seconds=1)
        new_position = Vector3(3.0, 3.0, 3.0)
        self.obj.setPosition(new_position)
        self.assertEqual(self.obj.velocity, Vector3())  # Velocity remains unchanged
        self.assertEqual(self.obj.position, new_position)

    def test_set_center(self):
        new_center = Vector3(5.0, 5.0, 5.0)
        self.obj.setCenter(new_center)
        # Assuming setCenter adjusts the position to make the center the new_center
        expected_position = Vector3(
            new_center.x - self.obj.width / 2.0,
            new_center.y - self.obj.height / 2.0,
            new_center.z - self.obj.depth / 2.0
        )
        self.assertEqual(self.obj.position, expected_position)


class TestSpatialObjectRotation(unittest.TestCase):
    def setUp(self):
        self.obj = SpatialObject(
            id="obj5",
            position=Vector3(0.0, 0.0, 0.0),
            width=2.0,
            height=2.0,
            depth=2.0,
            angle=0.0
        )

    def test_rotate_pts(self):
        pts = [Vector3(1.0, 0.0, 1.0), Vector3(0.0, 0.0, 1.0)]
        rotated = self.obj.rotate_pts(pts, math.pi / 2)
        expected = [Vector3(-1.0, 0.0, 1.0), Vector3(-1.0, 0.0, 0.0)]
        for r, e in zip(rotated, expected):
            self.assertAlmostEqual(r.x, e.x, places=5)
            self.assertAlmostEqual(r.y, e.y, places=5)
            self.assertAlmostEqual(r.z, e.z, places=5)

    def test_into_local(self):
        global_pt = Vector3(1.0, 0.0, 1.0)
        self.obj.angle = math.pi / 2  # 90 degrees
        local_pt = self.obj.intoLocal(global_pt)
        # After rotating -90 degrees, (1, 0, 1) becomes (1.0, 0.0, -1.0)
        expected_local_pt = Vector3(1.0, 0.0, -1.0)
        self.assertAlmostEqual(local_pt.x, expected_local_pt.x, places=5)
        self.assertAlmostEqual(local_pt.y, expected_local_pt.y, places=5)
        self.assertAlmostEqual(local_pt.z, expected_local_pt.z, places=5)


class TestSpatialObjectSectorMethods(unittest.TestCase):
    def setUp(self):
        self.obj = SpatialObject(
            id="obj6",
            position=Vector3(0.0, 0.0, 0.0),
            width=4.0,
            height=4.0,
            depth=4.0
        )
        self.obj.adjustment = SpatialAdjustment(maxGap=0.5)

    def test_sector_of_inside_point(self):
        point = Vector3(1.0, 1.0, 1.0)
        
        subject = SpatialObject(
            id="subj",
            position=point,
            width=0.5,
            height=0.5,
            depth=0.5
        )
        center = self.obj.intoLocal(subject.center)
        sector = self.obj.sectorOf(center)
        # Check if 'i' flag is set
        self.assertTrue(sector.contains(BBoxSectorFlags.i))
        self.assertEqual(sector, BBoxSectorFlags.i)

    def test_sector_of_left_point(self):
        point = Vector3(3.0, 1.0, 1.0)  # Beyond width/2 + maxGap (4/2 + 0.5 = 2.5)
        subject = SpatialObject(
            id="subj",
            position=point,
            width=0.5,
            height=0.5,
            depth=0.5
        )
        center = self.obj.intoLocal(subject.center)
        sector = self.obj.sectorOf(center)
        self.assertTrue(sector.contains(BBoxSectorFlags.l))

    def test_sector_of_right_point(self):
        point = Vector3(-3.0, 1.0, 1.0)  # Beyond -width/2 - maxGap
        sector = self.obj.sectorOf(point)
        self.assertTrue(sector.contains(BBoxSectorFlags.r))

    def test_sector_of_ahead_point(self):
        point = Vector3(1.0, 1.0, 3.0)  # Beyond depth/2 + maxGap
        sector = self.obj.sectorOf(point)
        self.assertTrue(sector.contains(BBoxSectorFlags.a))

    def test_sector_of_behind_point(self):
        point = Vector3(1.0, 1.0, -3.0)  # Beyond -depth/2 - maxGap
        sector = self.obj.sectorOf(point)
        self.assertTrue(sector.contains(BBoxSectorFlags.b))

    def test_sector_of_above_point(self):
        point = Vector3(1.0, 5.0, 1.0)  # Above height
        sector = self.obj.sectorOf(point)
        self.assertTrue(sector.contains(BBoxSectorFlags.o))

    def test_sector_of_under_point(self):
        point = Vector3(1.0, -1.0, 1.0)  # Below 0
        sector = self.obj.sectorOf(point)
        self.assertTrue(sector.contains(BBoxSectorFlags.u))


class TestSpatialObjectSpatialRelations(unittest.TestCase):
    def setUp(self):
        self.obj1 = SpatialObject(
            id="obj7",
            position=Vector3(0.0, 0.0, 0.0),
            width=2.0,
            height=2.0,
            depth=2.0,
            confidence=0.0
        )
        self.obj2 = SpatialObject(
            id="obj8",
            position=Vector3(1.0, 0.0, 1.0),
            width=2.0,
            height=2.0,
            depth=2.0,
            confidence=0.0
        )
        # Mock SpatialRelation and SpatialPredicate if needed
        # Assuming SpatialRelation is correctly implemented
        adjustment = SpatialAdjustment(maxGap=0.5)
        self.obj1.adjustment = adjustment
        self.obj2.adjustment = adjustment
        # create the spatial context SpatialReasoner
        self.obj1.context = MagicMock()

    def test_near_relation(self):
        relations = self.obj1.topologies(self.obj2)
        near_rel = next((rel for rel in relations if rel.predicate == SpatialPredicate.near), None)
        self.assertIsNotNone(near_rel)
        expected_gap = (self.obj2.center - self.obj1.center).magnitude()
        self.assertAlmostEqual(near_rel.delta, expected_gap, places=5)

    def test_far_relation(self):
        self.obj2.position = Vector3(10.0, 0.0, 10.0)
        relations = self.obj1.topologies(self.obj2)
        far_rel = next((rel for rel in relations if rel.predicate == SpatialPredicate.far), None)
        self.assertIsNotNone(far_rel)
        expected_gap = (self.obj2.center - self.obj1.center).magnitude()
        self.assertAlmostEqual(far_rel.delta, expected_gap, places=5)

    def test_overlapping_relation(self):
        # Objects overlap
        self.obj2.position = Vector3(1.0, 0.0, 1.0)  # Overlaps with obj1
        relations = self.obj1.topologies(self.obj2)
        overlapping_rel = next((rel for rel in relations if rel.predicate == SpatialPredicate.overlapping), None)
        self.assertIsNotNone(overlapping_rel)

    def test_disjoint_relation(self):
        # Objects are disjoint
        self.obj2.position = Vector3(5.0, 0.0, 5.0)
        relations = self.obj1.topologies(self.obj2)
        disjoint_rel = next((rel for rel in relations if rel.predicate == SpatialPredicate.disjoint), None)
        self.assertIsNotNone(disjoint_rel)

    def test_inside_relation(self):
        # obj2 is inside obj1
        self.obj1.width = 10.0
        self.obj1.height = 10.0
        self.obj1.depth = 10.0
        self.obj2.position = Vector3(1.0, 1.0, 1.0)
        relations = self.obj1.topologies(self.obj2)
        inside_rel = next((rel for rel in relations if rel.predicate == SpatialPredicate.inside), None)
        self.assertIsNotNone(inside_rel)

    def test_containing_relation(self):
        # obj1 is contained within obj2
        self.obj1.width = 1.0
        self.obj1.height = 1.0
        self.obj1.depth = 1.0
        self.obj2.width = 5.0
        self.obj2.height = 5.0
        self.obj2.depth = 5.0
        relations = self.obj2.topologies(self.obj1)
        containing_rel = next((rel for rel in relations if rel.predicate == SpatialPredicate.containing), None)
        self.assertIsNotNone(containing_rel)

    def test_same_center_relation(self):
        # Both objects have the same center
        self.obj1.position = Vector3(0.0, 0.0, 0.0)
        self.obj2.position = Vector3(0.0, 0.0, 0.0)
        relations = self.obj1.topologies(self.obj2)
        samecenter_rel = next((rel for rel in relations if rel.predicate == SpatialPredicate.samecenter), None)
        self.assertIsNotNone(samecenter_rel)
        self.assertEqual(samecenter_rel.delta, 0.0)


class TestSpatialObjectSerialization(unittest.TestCase):
    def setUp(self):
        self.obj = SpatialObject(
            id="obj9",
            position=Vector3(1.0, 2.0, 3.0),
            width=4.0,
            height=5.0,
            depth=6.0,
            angle=math.pi / 3,
            label="Serializable Object",
            confidence=0.9
        )
        self.obj.cause = ObjectCause.object_detected
        self.obj.existence = SpatialExistence.real
        self.obj.shape = ObjectShape.cubical
        self.obj.visible = True
        self.obj.focused = False
        self.obj.setData("extra_attr", 123.456)

    def test_as_dict(self):
        obj_dict = self.obj.asDict()
        self.assertEqual(obj_dict["id"], "obj9")
        self.assertEqual(obj_dict["position"], [1.0, 2.0, 3.0])
        self.assertEqual(obj_dict["width"], 4.0)
        self.assertEqual(obj_dict["height"], 5.0)
        self.assertEqual(obj_dict["depth"], 6.0)
        self.assertEqual(obj_dict["angle"], math.pi / 3)
        self.assertEqual(obj_dict["label"], "Serializable Object")
        self.assertEqual(obj_dict["cause"], ObjectCause.object_detected.value)
        self.assertEqual(obj_dict["existence"], SpatialExistence.real.value)
        self.assertEqual(obj_dict["shape"], ObjectShape.cubical.value)
        self.assertTrue(obj_dict["visible"])
        self.assertFalse(obj_dict["focused"])
        self.assertEqual(obj_dict["extra_attr"], 123.456)

    def test_to_any(self):
        obj_any = self.obj.toAny()
        self.assertEqual(obj_any["id"], "obj9")
        self.assertEqual(obj_any["position"], [1.0, 2.0, 3.0])
        self.assertEqual(obj_any["width"], 4.0)
        self.assertEqual(obj_any["height"], 5.0)
        self.assertEqual(obj_any["depth"], 6.0)
        self.assertEqual(obj_any["angle"], math.pi / 3)
        self.assertEqual(obj_any["label"], "Serializable Object")
        self.assertEqual(obj_any["type"], "")  # Default type
        self.assertEqual(obj_any["supertype"], "")  # Default supertype
        self.assertEqual(obj_any["cause"], ObjectCause.object_detected.value)
        self.assertEqual(obj_any["existence"], SpatialExistence.real.value)
        self.assertEqual(obj_any["shape"], ObjectShape.cubical.value)
        self.assertTrue(obj_any["visible"])
        self.assertFalse(obj_any["focused"])
        self.assertEqual(obj_any["extra_attr"], 123.456)

    def test_from_any(self):
        input_data = {
            "id": "obj10",
            "position": [7.0, 8.0, 9.0],
            "width": 10.0,
            "height": 11.0,
            "depth": 12.0,
            "angle": math.pi / 4,
            "label": "Updated Object",
            "type": "Box",
            "supertype": "Container",
            "confidence": 0.95,
            "cause": "user_generated",
            "existence": "virtual",
            "immobile": True,
            "shape": "spherical",
            "look": "Shiny",
            "visible": False,
            "focused": True,
            "new_attr": "additional data"
        }
        self.obj.fromAny(input_data)
        self.assertEqual(self.obj.id, "obj10")
        self.assertEqual(self.obj.position, Vector3(7.0, 8.0, 9.0))
        self.assertEqual(self.obj.width, 10.0)
        self.assertEqual(self.obj.height, 11.0)
        self.assertEqual(self.obj.depth, 12.0)
        self.assertAlmostEqual(self.obj.angle, math.pi / 4, places=5)
        self.assertEqual(self.obj.label, "Updated Object")
        self.assertEqual(self.obj.type, "Box")
        self.assertEqual(self.obj.supertype, "Container")
        self.assertAlmostEqual(self.obj.confidence.value, 0.95, places=5)
        self.assertEqual(self.obj.cause, ObjectCause.user_generated)
        self.assertEqual(self.obj.existence, SpatialExistence.virtual)
        self.assertTrue(self.obj.immobile)
        self.assertEqual(self.obj.shape, ObjectShape.spherical)
        self.assertEqual(self.obj.look, "Shiny")
        self.assertFalse(self.obj.visible)
        self.assertTrue(self.obj.focused)
        self.assertEqual(self.obj.data["new_attr"], "additional data")


class TestSpatialObjectRelationValue(unittest.TestCase):
    def setUp(self):
        self.obj1 = SpatialObject(
            id="obj11",
            position=Vector3(0.0, 0.0, 0.0),
            width=2.0,
            height=2.0,
            depth=2.0,
            angle=0.0,
            confidence=0.0
        )
        self.obj2 = SpatialObject(
            id="obj12",
            position=Vector3(1.0, 0.0, 1.0),
            width=2.0,
            height=2.0,
            depth=2.0,
            angle=math.pi / 2,
            confidence=0.0
        )
        # Mock the context and SpatialRelation
        self.obj1.context = MagicMock()
        relation = SpatialRelation(
            subject=self.obj1,
            predicate=SpatialPredicate.near,
            object=self.obj2,
            delta=1.414,
            angle=math.pi / 2
        )
        self.obj1.context.relationsWith.return_value = [relation]

    def test_relation_value_angle(self):
        value = self.obj1.relationValue("near.angle", [0])
        self.assertAlmostEqual(value, math.pi / 2, places=5)

    def test_relation_value_delta(self):
        value = self.obj1.relationValue("near.delta", [0])
        self.assertAlmostEqual(value, 1.414, places=5)

    def test_relation_value_nonexistent_predicate(self):
        value = self.obj1.relationValue("far.delta", [0])
        self.assertEqual(value, 0.0)

    def test_relation_value_no_context(self):
        self.obj1.context = None
        value = self.obj1.relationValue("near.delta", [0])
        self.assertEqual(value, 0.0)

    def test_relation_value_invalid_attribute(self):
        value = self.obj1.relationValue("near.invalid", [0])
        self.assertEqual(value, 0.0)


class TestSpatialObjectSerializationEdgeCases(unittest.TestCase):
    def test_serialization_with_missing_attributes(self):
        # Create an object with some missing attributes
        obj = SpatialObject(
            id="obj13",
            position=Vector3(),
            width=1.0,
            height=1.0,
            depth=1.0,
            confidence=0.0
        )
        obj.setData("optional_attr", "value")
        obj_dict = obj.asDict()
        self.assertIn("optional_attr", obj_dict)
        self.assertEqual(obj_dict["optional_attr"], "value")

    def test_deserialization_with_extra_attributes(self):
        input_data = {
            "id": "obj14",
            "position": [2.0, 3.0, 4.0],
            "width": 5.0,
            "height": 6.0,
            "depth": 7.0,
            "angle": math.pi / 6,
            "label": "Extra Object",
            "type": "Sphere",
            "supertype": "Shape",
            "confidence": 0.85,
            "cause": "remote_created",
            "existence": "conceptual",
            "immobile": False,
            "shape": "spherical",
            "look": "Smooth",
            "visible": True,
            "focused": True,
            "additional_info": {"key1": "value1", "key2": 2.0}
        }
        obj = SpatialObject(
            id="obj15",
            position=Vector3(),
            width=1.0,
            height=1.0,
            depth=1.0,
            confidence=0.0
        )
        obj.fromAny(input_data)
        self.assertEqual(obj.id, "obj14")
        self.assertEqual(obj.position, Vector3(2.0, 3.0, 4.0))
        self.assertEqual(obj.width, 5.0)
        self.assertEqual(obj.height, 6.0)
        self.assertEqual(obj.depth, 7.0)
        self.assertAlmostEqual(obj.angle, math.pi / 6, places=5)
        self.assertEqual(obj.label, "Extra Object")
        self.assertEqual(obj.type, "Sphere")
        self.assertEqual(obj.supertype, "Shape")
        self.assertAlmostEqual(obj.confidence.value, 0.85, places=5)
        self.assertEqual(obj.cause, ObjectCause.remote_created)
        self.assertEqual(obj.existence, SpatialExistence.conceptual)
        self.assertFalse(obj.immobile)
        self.assertEqual(obj.shape, ObjectShape.spherical)
        self.assertEqual(obj.look, "Smooth")
        self.assertTrue(obj.visible)
        self.assertTrue(obj.focused)
        self.assertEqual(obj.data["additional_info"], {"key1": "value1", "key2": 2.0})


class TestSpatialObjectUtilityMethods(unittest.TestCase):
    def setUp(self):
        self.obj = SpatialObject(
            id="obj16",
            position=Vector3(0.0, 0.0, 0.0),
            width=2.0,
            height=4.0,
            depth=6.0,
            confidence=0.0
        )
        self.obj.adjustment = SpatialAdjustment()

    def test_main_direction(self):
        # Initial dimensions: width=2.0, height=4.0, depth=6.0
        # Dominant dimension: depth (0)
        self.assertEqual(self.obj.mainDirection(), 0)  # Depth is dominant

        # Change dimensions: width=1.0, height=4.0, depth=1.0
        # Dominant dimension: height (2)
        self.obj.width = 1.0
        self.obj.height = 4.0
        self.obj.depth = 1.0
        self.assertEqual(self.obj.mainDirection(), 2)  # Height is dominant

        # Change dimensions: width=5.0, height=2.0, depth=2.0
        # Dominant dimension: width (1)
        self.obj.width = 5.0
        self.obj.height = 2.0
        self.obj.depth = 2.0
        self.assertEqual(self.obj.mainDirection(), 1)  # Width is dominant

    def test_thin_ratio(self):
        self.assertFalse(self.obj.thin)
        self.obj.width = 0.1
        self.obj.height = 10.0
        self.obj.depth = 10.0
        self.assertTrue(self.obj.thin)

    def test_long_ratio(self):
        self.assertEqual(self.obj.long_ratio(), 0)
        self.obj.width = 1.0
        self.obj.height = 5.0
        self.obj.depth = 1.0
        self.assertEqual(self.obj.long_ratio(), 2)

    def test_yaw_property(self):
        self.obj.angle = math.pi
        self.assertAlmostEqual(self.obj.yaw, 180.0, places=5)

    def test_azimuth_property_with_no_context(self):
        self.obj.angle = math.pi / 2
        self.assertEqual(self.obj.azimuth, 0.0)  # Assuming default north is along +x

    def test_azimuth_property_with_context(self):
        # Mock the context and north
        north_vector = Vector3(1.0, 0.0, 0.0)
        self.obj.context = MagicMock()
        self.obj.context.north = north_vector
        # Calculate expected azimuth
        north_angle = math.atan2(north_vector.y, north_vector.x) * 180.0 / math.pi  # 0 degrees
        expected_azimuth = (-math.degrees(self.obj.angle) - north_angle) % 360.0  # Correct formula
        self.assertAlmostEqual(self.obj.azimuth, expected_azimuth, places=5)

    def test_lifespan_property(self):
        self.obj.created = datetime.datetime.now() - datetime.timedelta(seconds=10)
        lifespan = self.obj.lifespan
        self.assertTrue(9.0 <= lifespan <= 11.0)

    def test_update_interval_property(self):
        self.obj.updated = datetime.datetime.now() - datetime.timedelta(seconds=5)
        interval = self.obj.updateInterval
        self.assertTrue(4.0 <= interval <= 6.0)


class TestSpatialObjectSerializationAndDeserialization(unittest.TestCase):
    def test_serialization_deserialization_cycle(self):
        original_obj = SpatialObject(
            id="obj17",
            position=Vector3(3.0, 4.0, 5.0),
            width=6.0,
            height=7.0,
            depth=8.0,
            angle=math.pi / 6,
            label="Cycle Object",
            confidence=0.7
        )
        original_obj.cause = ObjectCause.object_detected
        original_obj.existence = SpatialExistence.real
        original_obj.shape = ObjectShape.spherical
        original_obj.visible = True
        original_obj.focused = True
        original_obj.setData("cycle_attr", "cycle_value")

        obj_dict = original_obj.asDict()
        new_obj = SpatialObject(
            id="dummy",
            position=Vector3(),
            width=1.0,
            height=1.0,
            depth=1.0,
            confidence=0.0
        )
        new_obj.fromAny(obj_dict)

        self.assertEqual(new_obj.id, original_obj.id)
        self.assertEqual(new_obj.position, original_obj.position)
        self.assertEqual(new_obj.width, original_obj.width)
        self.assertEqual(new_obj.height, original_obj.height)
        self.assertEqual(new_obj.depth, original_obj.depth)
        self.assertAlmostEqual(new_obj.angle, original_obj.angle, places=5)
        self.assertEqual(new_obj.label, original_obj.label)
        self.assertEqual(new_obj.cause, original_obj.cause)
        self.assertEqual(new_obj.existence, original_obj.existence)
        self.assertEqual(new_obj.shape, original_obj.shape)
        self.assertTrue(new_obj.visible)
        self.assertTrue(new_obj.focused)
        self.assertEqual(new_obj.data["cycle_attr"], "cycle_value")


class TestSpatialObjectRelationValue(unittest.TestCase):
    def setUp(self):
        self.obj1 = SpatialObject(
            id="obj11",
            position=Vector3(0.0, 0.0, 0.0),
            width=2.0,
            height=2.0,
            depth=2.0,
            angle=0.0,
            confidence=0.0
        )
        self.obj2 = SpatialObject(
            id="obj12",
            position=Vector3(1.0, 0.0, 1.0),
            width=2.0,
            height=2.0,
            depth=2.0,
            angle=math.pi / 2,
            confidence=0.0
        )
        # Mock the context and SpatialRelation
        self.obj1.context = MagicMock()
        relation = SpatialRelation(
            subject=self.obj1,
            predicate=SpatialPredicate.near,
            object=self.obj2,
            delta=1.414,
            angle=math.pi / 2
        )
        self.obj1.context.relationsWith.return_value = [relation]

    def test_relation_value_angle(self):
        value = self.obj1.relationValue("near.angle", [0])
        self.assertAlmostEqual(value, math.pi / 2, places=5)

    def test_relation_value_delta(self):
        value = self.obj1.relationValue("near.delta", [0])
        self.assertAlmostEqual(value, 1.414, places=5)

    def test_relation_value_nonexistent_predicate(self):
        value = self.obj1.relationValue("far.delta", [0])
        self.assertEqual(value, 0.0)

    def test_relation_value_no_context(self):
        self.obj1.context = None
        value = self.obj1.relationValue("near.delta", [0])
        self.assertEqual(value, 0.0)

    def test_relation_value_invalid_attribute(self):
        value = self.obj1.relationValue("near.invalid", [0])
        self.assertEqual(value, 0.0)


class TestSpatialObjectSerializationEdgeCases(unittest.TestCase):
    def test_serialization_with_missing_attributes(self):
        # Create an object with some missing attributes
        obj = SpatialObject(
            id="obj13",
            position=Vector3(),
            width=1.0,
            height=1.0,
            depth=1.0,
            confidence=0.0
        )
        obj.setData("optional_attr", "value")
        obj_dict = obj.asDict()
        self.assertIn("optional_attr", obj_dict)
        self.assertEqual(obj_dict["optional_attr"], "value")

    def test_deserialization_with_extra_attributes(self):
        input_data = {
            "id": "obj14",
            "position": [2.0, 3.0, 4.0],
            "width": 5.0,
            "height": 6.0,
            "depth": 7.0,
            "angle": math.pi / 6,
            "label": "Extra Object",
            "type": "Sphere",
            "supertype": "Shape",
            "confidence": 0.85,
            "cause": "remote_created",
            "existence": "conceptual",
            "immobile": False,
            "shape": "spherical",
            "look": "Smooth",
            "visible": True,
            "focused": True,
            "additional_info": {"key1": "value1", "key2": 2.0}
        }
        obj = SpatialObject(
            id="obj15",
            position=Vector3(),
            width=1.0,
            height=1.0,
            depth=1.0,
            confidence=0.0
        )
        obj.fromAny(input_data)
        self.assertEqual(obj.id, "obj14")
        self.assertEqual(obj.position, Vector3(2.0, 3.0, 4.0))
        self.assertEqual(obj.width, 5.0)
        self.assertEqual(obj.height, 6.0)
        self.assertEqual(obj.depth, 7.0)
        self.assertAlmostEqual(obj.angle, math.pi / 6, places=5)
        self.assertEqual(obj.label, "Extra Object")
        self.assertEqual(obj.type, "Sphere")
        self.assertEqual(obj.supertype, "Shape")
        self.assertAlmostEqual(obj.confidence.value, 0.85, places=5)
        self.assertEqual(obj.cause, ObjectCause.remote_created)
        self.assertEqual(obj.existence, SpatialExistence.conceptual)
        self.assertFalse(obj.immobile)
        self.assertEqual(obj.shape, ObjectShape.spherical)
        self.assertEqual(obj.look, "Smooth")
        self.assertTrue(obj.visible)
        self.assertTrue(obj.focused)
        self.assertEqual(obj.data["additional_info"], {"key1": "value1", "key2": 2.0})


class TestSpatialObjectUtilityMethods(unittest.TestCase):
    def setUp(self):
        self.obj = SpatialObject(
            id="obj16",
            position=Vector3(0.0, 0.0, 0.0),
            width=2.0,
            height=4.0,
            depth=6.0,
            confidence=0.0
        )
        self.obj.adjustment = SpatialAdjustment()

    def test_main_direction(self):
        # Initial dimensions: width=2.0, height=4.0, depth=6.0
        # Dominant dimension: depth (0)
        self.assertEqual(self.obj.mainDirection(), 0)  # Depth is dominant

        # Change dimensions: width=1.0, height=4.0, depth=1.0
        # Dominant dimension: height (2)
        self.obj.width = 1.0
        self.obj.height = 4.0
        self.obj.depth = 1.0
        self.assertEqual(self.obj.mainDirection(), 2)  # Height is dominant

        # Change dimensions: width=5.0, height=2.0, depth=2.0
        # Dominant dimension: width (1)
        self.obj.width = 5.0
        self.obj.height = 2.0
        self.obj.depth = 2.0
        self.assertEqual(self.obj.mainDirection(), 1)  # Width is dominant

    def test_thin_ratio(self):
        self.assertFalse(self.obj.thin)
        self.obj.width = 0.1
        self.obj.height = 10.0
        self.obj.depth = 10.0
        self.assertTrue(self.obj.thin)

    def test_long_ratio(self):
        self.assertEqual(self.obj.long_ratio(), 0)
        self.obj.width = 1.0
        self.obj.height = 5.0
        self.obj.depth = 1.0
        self.assertEqual(self.obj.long_ratio(), 2)

    def test_yaw_property(self):
        self.obj.angle = math.pi
        self.assertAlmostEqual(self.obj.yaw, 180.0, places=5)

    def test_azimuth_property_with_no_context(self):
        self.obj.angle = math.pi / 2
        self.assertEqual(self.obj.azimuth, 0.0)  # Assuming default north is along +x

    def test_azimuth_property_with_context(self):
        # Mock the context and north
        north_vector = Vector3(1.0, 0.0, 0.0)
        self.obj.context = MagicMock()
        self.obj.context.north = north_vector
        # Calculate expected azimuth
        north_angle = math.atan2(north_vector.y, north_vector.x) * 180.0 / math.pi  # 0 degrees
        expected_azimuth = (-math.degrees(self.obj.angle) - north_angle) % 360.0  # Correct formula
        self.assertAlmostEqual(self.obj.azimuth, expected_azimuth, places=5)

    def test_lifespan_property(self):
        self.obj.created = datetime.datetime.now() - datetime.timedelta(seconds=10)
        lifespan = self.obj.lifespan
        self.assertTrue(9.0 <= lifespan <= 11.0)

    def test_update_interval_property(self):
        self.obj.updated = datetime.datetime.now() - datetime.timedelta(seconds=5)
        interval = self.obj.updateInterval
        self.assertTrue(4.0 <= interval <= 6.0)


class TestSpatialObjectSerializationAndDeserialization(unittest.TestCase):
    def test_serialization_deserialization_cycle(self):
        original_obj = SpatialObject(
            id="obj17",
            position=Vector3(3.0, 4.0, 5.0),
            width=6.0,
            height=7.0,
            depth=8.0,
            angle=math.pi / 6,
            label="Cycle Object",
            confidence=0.7
        )
        original_obj.cause = ObjectCause.object_detected
        original_obj.existence = SpatialExistence.real
        original_obj.shape = ObjectShape.spherical
        original_obj.visible = True
        original_obj.focused = True
        original_obj.setData("cycle_attr", "cycle_value")

        obj_dict = original_obj.asDict()
        new_obj = SpatialObject(
            id="dummy",
            position=Vector3(),
            width=1.0,
            height=1.0,
            depth=1.0,
            confidence=0.0
        )
        new_obj.fromAny(obj_dict)

        self.assertEqual(new_obj.id, original_obj.id)
        self.assertEqual(new_obj.position, original_obj.position)
        self.assertEqual(new_obj.width, original_obj.width)
        self.assertEqual(new_obj.height, original_obj.height)
        self.assertEqual(new_obj.depth, original_obj.depth)
        self.assertAlmostEqual(new_obj.angle, original_obj.angle, places=5)
        self.assertEqual(new_obj.label, original_obj.label)
        self.assertEqual(new_obj.cause, original_obj.cause)
        self.assertEqual(new_obj.existence, original_obj.existence)
        self.assertEqual(new_obj.shape, original_obj.shape)
        self.assertTrue(new_obj.visible)
        self.assertTrue(new_obj.focused)
        self.assertEqual(new_obj.data["cycle_attr"], "cycle_value")


if __name__ == '__main__':
    unittest.main()

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/tests/SpatialPredicate_test.py <==
# tests/test_spatial_predicate.py

import unittest
from src.SpatialPredicate import (
    SpatialPredicate,
    PredicateTerm,
    SpatialTerms,
    proximity,
    directionality,
    adjacency,
    orientations,
    assembly,
    topology,
    contacts,
    connectivity,
    comparability,
    similarity,
    visibility,
    geography,
    sectors
)
class TestSpatialPredicateEnum(unittest.TestCase):
    def test_enum_members(self):
        """Test that all SpatialPredicate members exist and have correct values."""
        self.assertEqual(SpatialPredicate.undefined.value, "undefined")
        self.assertEqual(SpatialPredicate.near.value, "near")
        self.assertEqual(SpatialPredicate.far.value, "far")
        self.assertEqual(SpatialPredicate.left.value, "left")
        self.assertEqual(SpatialPredicate.right.value, "right")
        self.assertEqual(SpatialPredicate.above.value, "above")
        self.assertEqual(SpatialPredicate.below.value, "below")
        self.assertEqual(SpatialPredicate.ahead.value, "ahead")
        self.assertEqual(SpatialPredicate.behind.value, "behind")
        self.assertEqual(SpatialPredicate.ontop.value, "on top")
        self.assertEqual(SpatialPredicate.beneath.value, "beneath")
        self.assertEqual(SpatialPredicate.upperside.value, "at upper side")
        self.assertEqual(SpatialPredicate.lowerside.value, "at lower side")
        self.assertEqual(SpatialPredicate.leftside.value, "at left side")
        self.assertEqual(SpatialPredicate.rightside.value, "at right side")
        self.assertEqual(SpatialPredicate.frontside.value, "at front side")
        self.assertEqual(SpatialPredicate.backside.value, "at back side")
        self.assertEqual(SpatialPredicate.orthogonal.value, "orthogonal")
        self.assertEqual(SpatialPredicate.opposite.value, "opposite")
        self.assertEqual(SpatialPredicate.aligned.value, "aligned")
        self.assertEqual(SpatialPredicate.frontaligned.value, "front aligned")
        self.assertEqual(SpatialPredicate.backaligned.value, "back aligned")
        self.assertEqual(SpatialPredicate.leftaligned.value, "left aligned")
        self.assertEqual(SpatialPredicate.rightaligned.value, "right aligned")
        self.assertEqual(SpatialPredicate.disjoint.value, "disjoint")
        self.assertEqual(SpatialPredicate.inside.value, "inside")
        self.assertEqual(SpatialPredicate.containing.value, "containing")
        self.assertEqual(SpatialPredicate.overlapping.value, "overlapping")
        self.assertEqual(SpatialPredicate.crossing.value, "crossing")
        self.assertEqual(SpatialPredicate.touching.value, "touching")
        self.assertEqual(SpatialPredicate.meeting.value, "meeting")
        self.assertEqual(SpatialPredicate.beside.value, "beside")
        self.assertEqual(SpatialPredicate.fitting.value, "fitting")
        self.assertEqual(SpatialPredicate.exceeding.value, "exceeding")
        self.assertEqual(SpatialPredicate.smaller.value, "smaller")
        self.assertEqual(SpatialPredicate.bigger.value, "bigger")
        self.assertEqual(SpatialPredicate.shorter.value, "shorter")
        self.assertEqual(SpatialPredicate.longer.value, "longer")
        self.assertEqual(SpatialPredicate.taller.value, "taller")
        self.assertEqual(SpatialPredicate.thinner.value, "thinner")
        self.assertEqual(SpatialPredicate.wider.value, "wider")
        self.assertEqual(SpatialPredicate.samewidth.value, "same width")
        self.assertEqual(SpatialPredicate.sameheight.value, "same height")
        self.assertEqual(SpatialPredicate.samedepth.value, "same depth")
        self.assertEqual(SpatialPredicate.samelength.value, "same length")
        self.assertEqual(SpatialPredicate.samefront.value, "same front face")
        self.assertEqual(SpatialPredicate.sameside.value, "same side face")
        self.assertEqual(SpatialPredicate.samefootprint.value, "same footprint")
        self.assertEqual(SpatialPredicate.samevolume.value, "same volume")
        self.assertEqual(SpatialPredicate.samecenter.value, "same center")
        self.assertEqual(SpatialPredicate.sameposition.value, "same position")
        self.assertEqual(SpatialPredicate.samecuboid.value, "same cuboid")
        self.assertEqual(SpatialPredicate.congruent.value, "congruent")
        self.assertEqual(SpatialPredicate.sameshape.value, "same shape")
        self.assertEqual(SpatialPredicate.seenleft.value, "seen left")
        self.assertEqual(SpatialPredicate.seenright.value, "seen right")
        self.assertEqual(SpatialPredicate.infront.value, "in front")
        self.assertEqual(SpatialPredicate.atrear.value, "at rear")
        self.assertEqual(SpatialPredicate.tangible.value, "tangible")
        self.assertEqual(SpatialPredicate.eightoclock.value, "eight o'clock")
        self.assertEqual(SpatialPredicate.nineoclock.value, "nine o'clock")
        self.assertEqual(SpatialPredicate.tenoclock.value, "ten o'clock")
        self.assertEqual(SpatialPredicate.elevenoclock.value, "eleven o'clock")
        self.assertEqual(SpatialPredicate.twelveoclock.value, "twelve o'clock")
        self.assertEqual(SpatialPredicate.oneoclock.value, "one o'clock")
        self.assertEqual(SpatialPredicate.twooclock.value, "two o'clock")
        self.assertEqual(SpatialPredicate.threeoclock.value, "three o'clock")
        self.assertEqual(SpatialPredicate.fouroclock.value, "four o'clock")
        self.assertEqual(SpatialPredicate.secondleft.value, "second left")
        self.assertEqual(SpatialPredicate.secondright.value, "second right")
        self.assertEqual(SpatialPredicate.mostleft.value, "most left")
        self.assertEqual(SpatialPredicate.mostright.value, "most right")
        self.assertEqual(SpatialPredicate.on.value, "on")
        self.assertEqual(SpatialPredicate.at.value, "at")
        self.assertEqual(SpatialPredicate.by.value, "by")
        self.assertEqual(SpatialPredicate.in_.value, "in")
        self.assertEqual(SpatialPredicate.i.value, "i")
        self.assertEqual(SpatialPredicate.a.value, "a")
        self.assertEqual(SpatialPredicate.b.value, "b")
        self.assertEqual(SpatialPredicate.l.value, "l")
        self.assertEqual(SpatialPredicate.r.value, "r")
        self.assertEqual(SpatialPredicate.o.value, "o")
        self.assertEqual(SpatialPredicate.u.value, "u")
        self.assertEqual(SpatialPredicate.al.value, "al")
        self.assertEqual(SpatialPredicate.ar.value, "ar")
        self.assertEqual(SpatialPredicate.bl.value, "bl")
        self.assertEqual(SpatialPredicate.br.value, "br")
        self.assertEqual(SpatialPredicate.ao.value, "ao")
        self.assertEqual(SpatialPredicate.au.value, "au")
        self.assertEqual(SpatialPredicate.bo.value, "bo")
        self.assertEqual(SpatialPredicate.bu.value, "bu")
        self.assertEqual(SpatialPredicate.lo.value, "lo")
        self.assertEqual(SpatialPredicate.lu.value, "lu")
        self.assertEqual(SpatialPredicate.ro.value, "ro")
        self.assertEqual(SpatialPredicate.ru.value, "ru")
        self.assertEqual(SpatialPredicate.alo.value, "alo")
        self.assertEqual(SpatialPredicate.aro.value, "aro")
        self.assertEqual(SpatialPredicate.blo.value, "blo")
        self.assertEqual(SpatialPredicate.bro.value, "bro")
        self.assertEqual(SpatialPredicate.alu.value, "alu")
        self.assertEqual(SpatialPredicate.aru.value, "aru")
        self.assertEqual(SpatialPredicate.blu.value, "blu")
        self.assertEqual(SpatialPredicate.bru.value, "bru")
        self.assertEqual(SpatialPredicate.north.value, "north")
        self.assertEqual(SpatialPredicate.south.value, "south")
        self.assertEqual(SpatialPredicate.east.value, "east")
        self.assertEqual(SpatialPredicate.west.value, "west")
        self.assertEqual(SpatialPredicate.northwest.value, "northwest")
        self.assertEqual(SpatialPredicate.northeast.value, "northeast")
        self.assertEqual(SpatialPredicate.southwest.value, "southwest")
        self.assertEqual(SpatialPredicate.southeast.value, "southeast")


class TestPredicateTerm(unittest.TestCase):
    def test_predicate_term_initialization(self):
        """Test the initialization of PredicateTerm."""
        term = PredicateTerm(
            code=SpatialPredicate.near,
            predicate="near",
            preposition="to",
            synonym="close",
            reverse="near",
            antonym="far",
            verb="is"
        )
        self.assertEqual(term.code, SpatialPredicate.near)
        self.assertEqual(term.predicate, "near")
        self.assertEqual(term.preposition, "to")
        self.assertEqual(term.synonym, "close")
        self.assertEqual(term.reverse, "near")
        self.assertEqual(term.antonym, "far")
        self.assertEqual(term.verb, "is")

    def test_predicate_term_defaults(self):
        """Test the default values of PredicateTerm."""
        term = PredicateTerm(
            code=SpatialPredicate.far,
            predicate="far",
            preposition="from",
            synonym="close",      # Explicitly set synonym
            reverse="far",
            antonym="near",
            verb="is"
        )
        self.assertEqual(term.code, SpatialPredicate.far)
        self.assertEqual(term.predicate, "far")
        self.assertEqual(term.preposition, "from")
        self.assertEqual(term.synonym, "close")  # Now correctly set
        self.assertEqual(term.reverse, "far")
        self.assertEqual(term.antonym, "near")
        self.assertEqual(term.verb, "is")


class TestSpatialTerms(unittest.TestCase):
    def test_list_population(self):
        """Test that SpatialTerms.list is correctly populated."""
        self.assertTrue(len(SpatialTerms.list) > 0)
        # Example: Check first term
        first_term = SpatialTerms.list[0]
        self.assertEqual(first_term.code, SpatialPredicate.near)
        self.assertEqual(first_term.predicate, "near")
        self.assertEqual(first_term.preposition, "to")
        self.assertEqual(first_term.synonym, "close")
        self.assertEqual(first_term.reverse, "near")
        self.assertEqual(first_term.antonym, "far")
        self.assertEqual(first_term.verb, "is")

    def test_predicate_method(self):
        """Test the SpatialTerms.predicate method."""
        self.assertEqual(SpatialTerms.predicate("near"), SpatialPredicate.near)
        self.assertEqual(SpatialTerms.predicate("close"), SpatialPredicate.near)
        self.assertEqual(SpatialTerms.predicate("far"), SpatialPredicate.far)
        self.assertEqual(SpatialTerms.predicate("on top"), SpatialPredicate.ontop)
        self.assertEqual(SpatialTerms.predicate("at the top"), SpatialPredicate.ontop)
        self.assertEqual(SpatialTerms.predicate("fitting"), SpatialPredicate.fitting)
        self.assertEqual(SpatialTerms.predicate("exceeding"), SpatialPredicate.exceeding)
        self.assertEqual(SpatialTerms.predicate("same width"), SpatialPredicate.samewidth)
        self.assertEqual(SpatialTerms.predicate("similar width"), SpatialPredicate.samewidth)
        self.assertEqual(SpatialTerms.predicate("similar depth"), SpatialPredicate.samedepth)
        self.assertEqual(SpatialTerms.predicate("nonexistent"), SpatialPredicate.undefined)

    def test_term_method(self):
        """Test the SpatialTerms.term method."""
        self.assertEqual(SpatialTerms.term(SpatialPredicate.near), "near")
        self.assertEqual(SpatialTerms.term(SpatialPredicate.far), "far")
        self.assertEqual(SpatialTerms.term(SpatialPredicate.ontop), "on top")
        self.assertEqual(SpatialTerms.term(SpatialPredicate.beneath), "beneath")
        self.assertEqual(SpatialTerms.term(SpatialPredicate.samewidth), "same width")
        self.assertEqual(SpatialTerms.term(SpatialPredicate.undefined), "undefined")

    def test_termWithPreposition_method(self):
        """Test the SpatialTerms.termWithPreposition method."""
        self.assertEqual(SpatialTerms.termWithPreposition(SpatialPredicate.near), "near to")
        self.assertEqual(SpatialTerms.termWithPreposition(SpatialPredicate.far), "far from")
        self.assertEqual(SpatialTerms.termWithPreposition(SpatialPredicate.left), "left of")
        self.assertEqual(SpatialTerms.termWithPreposition(SpatialPredicate.above), "above")
        self.assertEqual(SpatialTerms.termWithPreposition(SpatialPredicate.ontop), "on top of")
        self.assertEqual(SpatialTerms.termWithPreposition(SpatialPredicate.samewidth), "same width as")
        self.assertEqual(SpatialTerms.termWithPreposition(SpatialPredicate.undefined), "undefined")

    def test_termWithVerbAndPreposition_method(self):
        """Test the SpatialTerms.termWithVerbAndPreposition method."""
        self.assertEqual(SpatialTerms.termWithVerbAndPreposition(SpatialPredicate.near), "is near to")
        self.assertEqual(SpatialTerms.termWithVerbAndPreposition(SpatialPredicate.far), "is far from")
        self.assertEqual(SpatialTerms.termWithVerbAndPreposition(SpatialPredicate.left), "is left of")
        self.assertEqual(SpatialTerms.termWithVerbAndPreposition(SpatialPredicate.above), "is above")
        self.assertEqual(SpatialTerms.termWithVerbAndPreposition(SpatialPredicate.ontop), "is on top of")
        self.assertEqual(SpatialTerms.termWithVerbAndPreposition(SpatialPredicate.samewidth), "has same width as")
        self.assertEqual(SpatialTerms.termWithVerbAndPreposition(SpatialPredicate.undefined), "undefined")

    def test_symmetric_method(self):
        """Test the SpatialTerms.symmetric method."""
        self.assertTrue(SpatialTerms.symmetric(SpatialPredicate.orthogonal))
        self.assertTrue(SpatialTerms.symmetric(SpatialPredicate.opposite))
        self.assertFalse(SpatialTerms.symmetric(SpatialPredicate.left))
        self.assertTrue(SpatialTerms.symmetric(SpatialPredicate.near))  # Updated expectation
        self.assertTrue(SpatialTerms.symmetric(SpatialPredicate.congruent))

    def test_inverse_method(self):
        """Test the SpatialTerms.inverse method."""
        self.assertEqual(SpatialTerms.inverse("on top"), SpatialPredicate.beneath)
        self.assertEqual(SpatialTerms.inverse("beneath"), SpatialPredicate.ontop)
        self.assertEqual(SpatialTerms.inverse("near"), SpatialPredicate.near)
        self.assertEqual(SpatialTerms.inverse("unknown"), SpatialPredicate.undefined)

    def test_negation_method(self):
        """Test the SpatialTerms.negation method."""
        self.assertEqual(SpatialTerms.negation("near"), SpatialPredicate.far)
        self.assertEqual(SpatialTerms.negation("far"), SpatialPredicate.near)
        self.assertEqual(SpatialTerms.negation("overlapping"), SpatialPredicate.disjoint)
        self.assertEqual(SpatialTerms.negation("disjoint"), SpatialPredicate.overlapping)
        self.assertEqual(SpatialTerms.negation("unknown"), SpatialPredicate.undefined)


class TestSpatialPredicateCategories(unittest.TestCase):
    def test_category_membership(self):
        """Test that global lists contain correct SpatialPredicate members."""
        # Proximity
        self.assertListEqual(proximity, [SpatialPredicate.near, SpatialPredicate.far])
        # Directionality
        self.assertListEqual(directionality, [SpatialPredicate.left, SpatialPredicate.right, SpatialPredicate.above, SpatialPredicate.below, SpatialPredicate.ahead, SpatialPredicate.behind])
        # Adjacency
        self.assertListEqual(adjacency, [
            SpatialPredicate.leftside, SpatialPredicate.rightside, SpatialPredicate.ontop, SpatialPredicate.beneath,
            SpatialPredicate.upperside, SpatialPredicate.lowerside, SpatialPredicate.frontside, SpatialPredicate.backside
        ])
        # Orientations
        self.assertListEqual(orientations, [
            SpatialPredicate.orthogonal, SpatialPredicate.opposite, SpatialPredicate.aligned,
            SpatialPredicate.frontaligned, SpatialPredicate.backaligned, SpatialPredicate.rightaligned,
            SpatialPredicate.leftaligned
        ])
        # Assembly
        self.assertListEqual(assembly, [
            SpatialPredicate.disjoint, SpatialPredicate.inside, SpatialPredicate.containing,
            SpatialPredicate.overlapping, SpatialPredicate.crossing, SpatialPredicate.touching,
            SpatialPredicate.meeting, SpatialPredicate.beside
        ])
        # Topology
        self.assertListEqual(topology, proximity + directionality + adjacency + orientations + assembly)
        # Contacts
        self.assertListEqual(contacts, [SpatialPredicate.on, SpatialPredicate.at, SpatialPredicate.by, SpatialPredicate.in_])
        # Connectivity
        self.assertListEqual(connectivity, [SpatialPredicate.on, SpatialPredicate.at, SpatialPredicate.by, SpatialPredicate.in_])
        # Comparability
        self.assertListEqual(comparability, [
            SpatialPredicate.smaller, SpatialPredicate.bigger, SpatialPredicate.shorter, SpatialPredicate.longer,
            SpatialPredicate.taller, SpatialPredicate.thinner, SpatialPredicate.wider, SpatialPredicate.fitting,
            SpatialPredicate.exceeding
        ])
        # Similarity
        self.assertListEqual(similarity, [
            SpatialPredicate.sameheight, SpatialPredicate.samewidth, SpatialPredicate.samedepth,
            SpatialPredicate.samelength, SpatialPredicate.samefront, SpatialPredicate.sameside,
            SpatialPredicate.samefootprint, SpatialPredicate.samevolume, SpatialPredicate.samecenter,
            SpatialPredicate.samecuboid, SpatialPredicate.congruent, SpatialPredicate.sameshape
        ])
        # Visibility
        self.assertListEqual(visibility, [
            SpatialPredicate.seenleft, SpatialPredicate.seenright, SpatialPredicate.infront,
            SpatialPredicate.atrear, SpatialPredicate.tangible, SpatialPredicate.eightoclock,
            SpatialPredicate.nineoclock, SpatialPredicate.tenoclock, SpatialPredicate.elevenoclock,
            SpatialPredicate.twelveoclock, SpatialPredicate.oneoclock, SpatialPredicate.twooclock,
            SpatialPredicate.threeoclock, SpatialPredicate.fouroclock
        ])
        # Geography
        self.assertListEqual(geography, [
            SpatialPredicate.north, SpatialPredicate.south, SpatialPredicate.east, SpatialPredicate.west,
            SpatialPredicate.northwest, SpatialPredicate.northeast, SpatialPredicate.southwest, SpatialPredicate.southeast
        ])
        # Sectors
        self.assertListEqual(sectors, [
            SpatialPredicate.i, SpatialPredicate.a, SpatialPredicate.b, SpatialPredicate.o, SpatialPredicate.u,
            SpatialPredicate.l, SpatialPredicate.r, SpatialPredicate.al, SpatialPredicate.ar, SpatialPredicate.bl,
            SpatialPredicate.br, SpatialPredicate.ao, SpatialPredicate.au, SpatialPredicate.bo, SpatialPredicate.bu,
            SpatialPredicate.lo, SpatialPredicate.lu, SpatialPredicate.ro, SpatialPredicate.ru, SpatialPredicate.alo,
            SpatialPredicate.aro, SpatialPredicate.blo, SpatialPredicate.bro, SpatialPredicate.alu, SpatialPredicate.aru,
            SpatialPredicate.blu, SpatialPredicate.bru
        ])

if __name__ == '__main__':
    unittest.main()

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/tests/SpatialRelation_test.py <==
# tests/SpatialRelationsTests.py

import unittest
import math
from unittest.mock import MagicMock

# Import the necessary classes and enums from your modules
from src.vector3 import Vector3
from src.SpatialBasics import (
    NearbySchema,
    SectorSchema,
    SpatialAdjustment,
    SpatialPredicateCategories,
    ObjectConfidence,
    SpatialAtribute,
    SpatialExistence,
    ObjectCause,
    MotionState,
    ObjectShape,
    ObjectHandling,
    defaultAdjustment
)
from src.SpatialPredicate import (
    SpatialPredicate,
    PredicateTerm,
    SpatialTerms,
    proximity,
    directionality,
    adjacency,
    orientations,
    assembly,
    topology,
    contacts,
    connectivity,
    comparability,
    similarity,
    visibility,
    geography,
    sectors,
)
from src.SpatialRelation import (SpatialRelation)  # Ensure correct import
from src.SpatialObject import SpatialObject
from src.BBoxSector import BBoxSector, BBoxSectorFlags  # Import BBoxSector and its flags


class TestSpatialRelations(unittest.TestCase):
    def setUp(self):
        # Setup any common configurations or objects here if needed
        # For example, setting defaultAdjustment if it's a global or shared resource
        # Assuming defaultAdjustment is a singleton or global instance
        self.original_nearby_factor = defaultAdjustment.nearbyFactor

    def tearDown(self):
        # Reset any global settings after each test
        defaultAdjustment.nearbyFactor = self.original_nearby_factor

    def print_relations(self, relations):
        for relation in relations:
            print(f"{relation.subject.id} {relation.predicate} {relation.object.id} | Δ:{relation.delta:.2f}  α:{relation.yaw:.1f}°")

    @unittest.skip("Export functionality is ignored as per user instructions")
    def export(self, nodes):
        pass  # Export functionality is ignored

    def test_near(self):
        """
        Test that a subject is near to an object.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=1.75, y=0.0, z=0.01),
            width=1.4,
            height=1.4,
            depth=1.4
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0, y=0.0, z=0),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        # Adjust nearbyFactor before relating
        defaultAdjustment.nearbyFactor = 1.5
        relations = obj.relate(subject=subject, topology=True)
        self.print_relations(relations)
        # Export is ignored
        # self.export([...])

        # Check that relations contain 'near' and 'disjoint'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.near, predicates)
        self.assertIn(SpatialPredicate.disjoint, predicates)

        # Reset nearbyFactor
        defaultAdjustment.nearbyFactor = self.original_nearby_factor

    def test_notnear(self):
        """
        Test that a subject is far from an object.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=4.2, y=0.0, z=0),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0, y=0.0, z=0),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        relations = obj.relate(subject=subject, topology=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'far' and do not contain 'near'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.far, predicates)
        self.assertNotIn(SpatialPredicate.near, predicates)

    def test_inside(self):
        """
        Test that a subject is inside an object.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=0.0, y=0.2, z=0),
            width=0.5,
            height=0.5,
            depth=0.5
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0, y=0.0, z=0),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        relations = obj.relate(subject=subject, topology=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'inside' and do not contain 'disjoint'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.inside, predicates)
        self.assertNotIn(SpatialPredicate.disjoint, predicates)

    def test_containing(self):
        """
        Test that a subject is containing an object.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=0, y=0.0, z=0),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0.0, y=0.2, z=0),
            width=0.5,
            height=0.5,
            depth=0.5
        )
        relations = obj.relate(subject=subject, topology=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'containing' and do not contain 'disjoint'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.containing, predicates)
        self.assertNotIn(SpatialPredicate.disjoint, predicates)

    def test_door_inside_wall(self):
        """
        Test that a door is inside a wall.
        """
        wall1 = SpatialObject.createBuildingElement_from_vectors(
            id="wall1",
            from_pos=Vector3(x=-2, y=0, z=0),
            to_pos=Vector3(x=2, y=0, z=0),
            height=2.3
        )
        door = SpatialObject.createBuildingElement_from_vectors(
            id="door",
            from_pos=Vector3(x=0.4, y=0, z=0),
            to_pos=Vector3(x=1.3, y=0, z=0),
            height=2.05
        )
        relations = wall1.relate(subject=door, topology=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'inside'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.inside, predicates)

    def test_window_inside_wall(self):
        """
        Test that a window is inside a wall.
        """
        wall2 = SpatialObject.createBuildingElement_from_vectors(
            id="wall2",
            from_pos=Vector3(x=2, y=0, z=0),
            to_pos=Vector3(x=2, y=0, z=2.5),
            height=2.3
        )
        window = SpatialObject.createBuildingElement_from_vectors(
            id="window",
            from_pos=Vector3(x=2, y=0.7, z=1),
            to_pos=Vector3(x=2, y=0.7, z=2.2),
            height=1.35
        )
        relations = wall2.relate(subject=window, topology=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'inside'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.inside, predicates)

    def test_below(self):
        """
        Test that a subject is below an object.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=0, y=-1.10, z=0.05),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0, y=0.0, z=0),
            width=1.1,
            height=1.1,
            depth=1.1
        )
        relations = obj.relate(subject=subject, topology=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'below'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.below, predicates)

    def test_above(self):
        """
        Test that a subject is above an object.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=0, y=1.61, z=0.1),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0, y=0.0, z=0),
            width=1.1,
            height=1.1,
            depth=1.1
        )
        relations = obj.relate(subject=subject, topology=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'above'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.above, predicates)

    def test_ontop(self):
        """
        Test that a subject is on top of an object.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=0, y=1.01, z=0),
            width=0.8,
            height=0.6,
            depth=0.25
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0, y=0, z=0),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        relations = obj.relate(subject=subject, topology=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'ontop'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.ontop, predicates)

    def test_overlapping(self):
        """
        Test that a subject is overlapping an object.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=0.4, y=0.4, z=0.2),
            width=1.1,
            height=1.1,
            depth=1.1
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0, y=0, z=0),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        relations = obj.relate(subject=subject, topology=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'overlapping'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.overlapping, predicates)

    def test_crossing_hor(self):
        """
        Test that a subject is crossing an object horizontally.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=0, y=0.45, z=0),
            width=2.8,
            height=0.3,
            depth=0.4,
            angle=math.radians(20.0)  # Convert degrees to radians
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0, y=0, z=0),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        relations = obj.relate(subject=subject, topology=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'crossing'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.crossing, predicates)

    def test_crossing_vert(self):
        """
        Test that a subject is crossing an object vertically.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=-0.2, y=-0.5, z=-0.1),
            width=0.4,
            height=1.8,
            depth=0.5
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0, y=0, z=0),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        relations = obj.relate(subject=subject, topology=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'crossing'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.crossing, predicates)

    def test_touching(self):
        """
        Test that a subject is touching and beside an object.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=0.83, y=0, z=-0.2),
            width=0.4,
            height=0.8,
            depth=0.5
        )
        subject.setYaw(math.radians(0.0))  # Assuming setYaw takes radians
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0, y=0, z=0),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        relations = obj.relate(subject=subject, topology=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'touching' and 'beside'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.touching, predicates)
        self.assertIn(SpatialPredicate.beside, predicates)

    def test_meeting(self):
        """
        Test that a subject is meeting an object.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=0.76, y=0, z=-0.5),
            width=0.8,
            height=0.8,
            depth=0.5
        )
        subject.setYaw(math.radians(90.0))  # Assuming setYaw takes radians
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0, y=0, z=0),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        relations = obj.relate(subject=subject, topology=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'meeting'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.meeting, predicates)

    def test_congruent(self):
        """
        Test that a subject is congruent with an object.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=0.3, y=0, z=0.8),
            width=1.01,
            height=1.005,
            depth=1.002,
            angle=math.pi / 4.0 - 0.05  # Approximately 40 degrees
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0.3, y=0, z=0.8),
            width=1.0,
            height=1.0,
            depth=1.0,
            angle=math.pi / 4.0  # 45 degrees
        )
        relations = obj.relate(subject=subject, similarity=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'congruent'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.congruent, predicates)

    def test_seen_right(self):
        """
        Test that a subject is seen to the right from an observer's perspective.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=-0.5, y=0, z=0.8),
            width=1.01,
            height=1.03,
            depth=1.02
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0.5, y=0, z=0.8),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        observer = SpatialObject.createPerson(
            id="ego",
            position=Vector3(x=0.3, y=0, z=-2.0),
            name="ego"
        )
        relations = obj.asseen(subject=subject, observer=observer)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'seenright'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.seenright, predicates)

    def test_seen_left(self):
        """
        Test that a subject is seen to the left from an observer's perspective.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=-0.55, y=0, z=0.8),
            width=1.01,
            height=1.03,
            depth=1.02
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0.5, y=0, z=0.8),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        observer = SpatialObject.createPerson(
            id="ego",
            position=Vector3(x=0.3, y=0, z=3.8),
            name="ego"
        )
        observer.angle = math.radians(90.0) + 1.1  # Assuming angle is in radians
        relations = obj.asseen(subject=subject, observer=observer)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'seenleft'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.seenleft, predicates)

    def test_infront(self):
        """
        Test that a subject is in front of an object.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=-0.2, y=0, z=-1.1),
            width=1.01,
            height=1.03,
            depth=1.02,
            angle=0.2  # Assuming angle is in radians
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0.1, y=0, z=0.0),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        observer = SpatialObject.createPerson(
            id="ego",
            position=Vector3(x=0.3, y=0, z=-3.8),
            name="user"
        )
        relations = obj.asseen(subject=subject, observer=observer)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'infront'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.infront, predicates)

    def test_rear(self):
        """
        Test that a subject is at the rear of an object.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=-0.2, y=0, z=0.95),
            width=0.8,
            height=0.8,
            depth=0.8
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0.1, y=0, z=-0.15),
            width=1.0,
            height=1.0,
            depth=1.0
        )
        observer = SpatialObject.createPerson(
            id="ego",
            position=Vector3(x=0.3, y=0, z=-2.7)
        )
        relations = obj.asseen(subject=subject, observer=observer)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'atrear'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.atrear, predicates)

    def test_at11clock(self):
        """
        Test that a subject is at 11 o'clock from the observer's perspective.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=0.65, y=0, z=1.6),
            width=0.4,
            height=0.6,
            depth=0.5
        )
        observer = SpatialObject.createPerson(
            id="ego",
            position=Vector3(x=0, y=0, z=0),
            name="user"
        )
        relations = observer.relate(subject=subject, topology=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'elevenoclock'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.elevenoclock, predicates)

    def test_at2clock(self):
        """
        Test that a subject is at 2 o'clock from the observer's perspective.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=-0.95, y=0, z=0.45),
            width=0.4,
            height=0.6,
            depth=0.5
        )
        observer = SpatialObject.createPerson(
            id="ego",
            position=Vector3(x=0, y=0, z=0),
            name="user"
        )
        relations = observer.relate(subject=subject, topology=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'twooclock'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.twooclock, predicates)

    def test_thinner(self):
        """
        Test that a subject is thinner than an object.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=-0.2, y=0, z=0.8),
            width=0.2,
            height=0.9,
            depth=0.2
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0.6, y=0, z=0.8),
            width=0.25,
            height=1.0,
            depth=0.25
        )
        relations = obj.relate(subject=subject, comparison=True)
        self.print_relations(relations)
        # Export is ignored

        # Check that relations contain 'thinner'
        predicates = [rel.predicate for rel in relations]
        self.assertIn(SpatialPredicate.thinner, predicates)

    def test_corners(self):
        """
        Test corner relationships between objects.
        """
        subject = SpatialObject(
            id="subj",
            position=Vector3(x=-0.2, y=0, z=0.8),
            width=0.2,
            height=0.9,
            depth=0.2,
            angle=0.2
        )
        obj = SpatialObject(
            id="obj",
            position=Vector3(x=0.6, y=0, z=0.8),
            width=0.25,
            height=1.0,
            depth=0.25,
            angle=-0.2
        )
        relations = obj.relate(subject=subject, comparison=True)
        self.print_relations(relations)
        # Export is ignored

        # No specific assertion provided in Swift, so we'll assume no check needed

    def test_thin_ratio_edge_case(self):
        """
        Additional test to ensure thin ratio functionality if applicable.
        """
        # Implemented as per need based on the actual SpatialObject implementation
        pass

    # Add more tests as necessary based on additional predicates or functionalities


# Run the tests
if __name__ == '__main__':
    unittest.main()

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/tests/__init__.py <==

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/tests/__pycache__/BBoxSector_test.cpython-312.pyc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/tests/__pycache__/Sector_test.cpython-312.pyc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/tests/__pycache__/SpatialBasics_test.cpython-312.pyc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/tests/__pycache__/SpatialObject_test.cpython-312.pyc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/tests/__pycache__/SpatialPredicate_test.cpython-312.pyc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/tests/__pycache__/SpatialRelation_test.cpython-312.pyc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/tests/__pycache__/__init__.cpython-312.pyc <==
==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/tests/test.py <==
# tests/test.py

import unittest

def run_tests():
    loader = unittest.TestLoader()
    suite = loader.discover('.', pattern='*_test.py')
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    return result

if __name__ == '__main__':
    run_tests()

--------------------------------------------------------------

==> /Users/stevenhaesler/Documents/ZHAW/Spatial_Reasoning/SRpy/to_text.sh <==
#!/bin/bash

# =============================================================================
# Script Name: display_all_files_to_txt.sh
# Description: Recursively displays the contents of all files in the
#              'include' and 'src' directories using the `bat` command and
#              saves the output to a specified text file.
# =============================================================================

# ----------------------------- Configuration ----------------------------------

# Define the directories to search

DIRECTORIES=("include" "src" $(pwd) )

# Define the output file (default: all_files_output.txt)
OUTPUT_FILE="all_files_output.txt"

# ------------------------------- Functions ------------------------------------

# Function to check if 'bat' is installed
check_bat_installed() {
    if ! command -v bat &> /dev/null
    then
        echo "Error: 'bat' is not installed on your system."
        echo "Please install 'bat' to use this script. You can install it via Homebrew:"
        echo "  brew install bat"
        exit 1
    fi
}

# Function to initialize the output file
initialize_output_file() {
    echo "Generating documentation of all files in 'include' and 'src' directories..." > "$OUTPUT_FILE"
    echo "==============================================================" >> "$OUTPUT_FILE"
    echo "Output File: $OUTPUT_FILE"
    echo "Generated on: $(date)" >> "$OUTPUT_FILE"
    echo "==============================================================\n" >> "$OUTPUT_FILE"
}

# Function to display files in a given directory and append to the output file
display_files_in_directory() {
    local dir="$1"
    echo "Processing Directory: $dir"

    # Find all regular files in the directory recursively
    find "$dir" -type f | sort | while read -r file; do
        echo "==> ${file} <==" >> "$OUTPUT_FILE"
        #ignore so,jpeg,png,tiff,"TIFF, and build dir"
        if [[ $file == *.pyc ]] ||[[ $file == *.so ]] || [[ $file == *.jpeg ]]|| [[ $file == *.jpg ]] || [[ $file == *.png ]] || [[ $file == *.tiff ]] || [[ $file == *.TIF ]] || [[ $file == *build* ]]|| [[ $file == *.git* ]]|| [[ $file == *algorithms* ]]; then
            continue
        fi

        bat --style=plain "$file" >> "$OUTPUT_FILE" 2>/dev/null
        if [ $? -ne 0 ]; then
            echo "Failed to display file: $file" >> "$OUTPUT_FILE"
        fi
        echo -e "\n--------------------------------------------------------------\n" >> "$OUTPUT_FILE" 
    done
}

write_tree_to_file() {
    #use tree command to write the directory structure to a file
    
    #append the tree to the output file
    echo "==============================================================" >> "$OUTPUT_FILE"
    echo "Directory Structure" >> "$OUTPUT_FILE"
    echo "==============================================================" >> "$OUTPUT_FILE"
    tree -a -I '.git|build|*.png' > "$tree.txt" >> "$OUTPUT_FILE"
    
}
# ------------------------------ Main Script ----------------------------------

# ------------------------------ Main Script ----------------------------------

# Check if 'bat' is installed
check_bat_installed

# Initialize the output file
initialize_output_file

# Iterate over each specified directory
for dir in "${DIRECTORIES[@]}"; do
    if [ -d "$dir" ]; then
        display_files_in_directory "$dir"
    else
        echo "Warning: Directory '$dir' does not exist. Skipping." >> "$OUTPUT_FILE"
    fi
done

write_tree_to_file
echo "All files have been processed and saved to '$OUTPUT_FILE'."

# End of Script
--------------------------------------------------------------

==============================================================
Directory Structure
==============================================================
.
├── .gitignore
├── .nosync
├── .txt
├── LICENSE
├── README.md
├── all_files_output.txt
├── src
│   ├── BBoxSector.py
│   ├── SpatialBasics.py
│   ├── SpatialInference.py
│   ├── SpatialObject.py
│   ├── SpatialPredicate.py
│   ├── SpatialReasoner.py
│   ├── SpatialRelation.py
│   ├── Vector2.py
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── BBoxSector.cpython-312.pyc
│   │   ├── SpatialBasics.cpython-312.pyc
│   │   ├── SpatialInference.cpython-312.pyc
│   │   ├── SpatialObject.cpython-312.pyc
│   │   ├── SpatialPredicate.cpython-312.pyc
│   │   ├── SpatialReasoner.cpython-312.pyc
│   │   ├── SpatialRelation.cpython-312.pyc
│   │   ├── __init__.cpython-312.pyc
│   │   └── vector3.cpython-312.pyc
│   └── vector3.py
├── tests
│   ├── BBoxSector_test.py
│   ├── Sector_test.py
│   ├── SpatialBasics_test.py
│   ├── SpatialObject_test.py
│   ├── SpatialPredicate_test.py
│   ├── SpatialRelation_test.py
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── BBoxSector_test.cpython-312.pyc
│   │   ├── Sector_test.cpython-312.pyc
│   │   ├── SpatialBasics_test.cpython-312.pyc
│   │   ├── SpatialObject_test.cpython-312.pyc
│   │   ├── SpatialPredicate_test.cpython-312.pyc
│   │   ├── SpatialRelation_test.cpython-312.pyc
│   │   └── __init__.cpython-312.pyc
│   └── test.py
└── to_text.sh

5 directories, 41 files
